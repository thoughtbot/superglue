{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Superglue is a library that thoughtfully pairs Rails and React. Its built with The Rails Way in mind and aims to provide a simple developer experience that is on par with Hotwire, Stimulus, and Turbo. Confidently use Rails routes, controllers, views as you normally would in a multi-page application and integrate with React's vast ecosystem.</p> <p>Warning</p> <p>Superglue is in active development as it approaches 1.0.  While its interface and behavior are stablizing, changes are expected.</p>"},{"location":"#who-is-it-for","title":"Who is it for?","text":"<p>Superglue is built from the ground up for Rails developers who</p> <ul> <li>Have a complex React integration and want to move back to to a simple rails   workflow without giving up components already built.</li> <li>Want to use normal controllers, server side routing, views, helpers, etc. to   develop interactive React applications</li> <li>Want to hit the ground running with React and easily access all the components   that the React eco-system offers.</li> <li>Don't want to write another custom React integration</li> <li>Don't want to build APIs.</li> <li>Are tired of JS complexity and just want to get work done!</li> </ul>"},{"location":"#one-stop-shop","title":"One-stop shop","text":"<p>We know first hand how complex React can be, but we don't shy away from complexity. We want to make things better for everyone and to that end, we built a supporting cast of tooling under one shop to bring ease and consistancy to your team.</p> <ul> <li> <p>Superglue Rails</p> <p>Integrates Superglue with Rails, and generates a new app.</p> </li> <li> <p>PropsTemplate</p> <p>A very fast JSON builder. The secret sauce that enabled much more than just Rails/React integration</p> <p> props_template</p> </li> <li> <p>Humid</p> <p>Server Side Rendering using MiniRacer and V8 isolates.</p> <p> Humid</p> </li> <li> <p>Form Props</p> <p>Just use Rails forms with React. Combine it with React components.</p> <p> form_props</p> </li> </ul>"},{"location":"#how-does-it-work","title":"How does it work?","text":""},{"location":"#its-rails","title":"It\u2019s Rails","text":"<p>Superglue leans on Rails' ability to respond to different mime types on the same route and divides the usual <code>foobar.html.erb</code> into three familiar templates.</p> <ul> <li><code>foobar.json.props</code> A presenter written in a jbuilder-like template that   builds your page props.</li> <li><code>foobar.js</code> Your page component that receives the props from above.</li> <li><code>foobar.html.erb</code> Injects your page props into Redux when the browser loads   it.</li> </ul> <p>Shape your <code>props</code> to roughly how your components are presented. For example:</p> <pre><code>json.header do\n  json.username @user.username\n  json.linkToProfile url_for(@user)\nend\n\njson.rightDrawer do\n  json.cart(partial: 'cart') do\n  end\n  json.dailySpecials(partial: 'specials') do\n  end\nend\n\njson.body do\n  json.productFilter do\n    form_props(url: \"/\", method: \"GET\") do |f|\n      f.select(:category, [\"lifestyle\", \"programming\", \"spiritual\"])\n      f.submit\n    end\n  end\n\n  json.products do\n    json.array! @products do |product|\n      json.title product.title\n      json.urlToProduct url_for(product)\n    end\n  end\nend\n\njson.footer do\n  json.copyrightYear \"2023\"\nend\n</code></pre> <p>Familiar Rails conveniences include [form props], a fork of <code>form_with</code> made for React; the [flash] is integrated as a [Redux slice]; and [Unobtrusive Javascript] (UJS) helpers.</p>"},{"location":"#its-react","title":"It\u2019s React","text":"<p>But there are no APIs! The above is injected as a script tag in the DOM so everything loads in the initial request. Its added to [your Redux state] and passed to <code>foobar.js</code> as props, for example:</p> <pre><code>import React from 'react';\nimport { useSelector } from 'react-redux';\nimport { Drawer, Header, Footer, ProductList, ProductFilter } from './components';\n\nexport default function FooBar({ header, products = [], productFilter, rightDrawer, footer }) {\n  const flash = useSelector((state) =&gt; state.flash);\n\n  return (\n    &lt;&gt;\n      &lt;p id=\"notice\"&gt;{flash &amp;&amp; flash.notice}&lt;/p&gt;\n      &lt;Header {...header}&gt;\n        &lt;Drawer {...rightDrawer} /&gt;\n      &lt;/Header&gt;\n\n      &lt;ProductList {...products}&gt;\n        &lt;ProductFilter {...productFilter} /&gt;\n      &lt;/ProductList&gt;\n\n      &lt;Footer {...footer} /&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"#its-turbolinks-and-ujs","title":"It\u2019s Turbolinks and UJS","text":"<p>At heart, Superglue is a fork of [Turbolinks 3], but instead of sending your <code>foobar.html.erb</code> over the wire and swapping the <code>&lt;body&gt;</code>, it sends <code>foobar.json.props</code> over the wire to your React and Redux app and swaps the page component.</p> <p>This behavior is opt-in. Superglue provides UJS helpers that you can use with your React components to SPA transition to the next page.</p> <pre><code>&lt;a href=\u201d/next_page\u201d data-sg-visit&gt; Next Page &lt;/a&gt;\n</code></pre>"},{"location":"#its-more","title":"It\u2019s more!","text":"<p>Being able to easily use React in place of ERB isn't enough. Superglue\u2019s secret sauce is that your <code>foobar.json.props</code> is diggable; making any part of your page dynamic by using a query string. It\u2019s a simpler approach to Turbo Frames and Turbo Stream.</p> <p>Need to reload a part of the page? Just add a query parameter and combine with the [UJS helper] attribute <code>data-sg-remote</code>:</p> <pre><code>&lt;Header {...header}&gt;\n  &lt;Drawer {...rightDrawer} /&gt;\n\n  &lt;a data-sg-remote href=\"/some_current_page?props_at=data.rightDrawer.dailySpecials\"&gt;\n    Reload Daily Specials\n  &lt;/a&gt;\n&lt;/Header&gt;\n</code></pre> <p>The above will traverse <code>foobar.json.props</code>, grab <code>dailySpecials</code> while skipping other nodes, and immutably graft it to your Redux store.</p> <p>This works well for [modals], chat, streaming, and [more]!</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#application_visitjs","title":"<code>application_visit.js</code>","text":"<p>Hint</p> <p>If you want a progress bar, this is likely the first thing you'll want to configure after installation.</p> <p>This file contains the factory that builds the remote and visit function that will be passed to your page components and used by the data-sg-visit and data-sg-remote UJS attributes.</p> <p>This file is meant for you to customize. For example, you'll likely want to add a progress bar, control how visits work, or flash when the internet is down.</p>"},{"location":"configuration/#page_to_page_mappingjs","title":"<code>page_to_page_mapping.js</code>","text":"<p>Hint</p> <p>Stop by the tutorial to get an idea of how to work with this file.</p> <p>This file exports a mapping between a <code>componentIdentifier</code> to an imported page component. This gets used in your <code>application.js</code> so that superglue knows which component to render with which identifier.</p> <p>For example:</p> <pre><code>const pageIdentifierToPageComponent = {\n  'posts/edit': PostsEdit,\n  'posts/new': PostsNew,\n  'posts/show': PostsShow,\n  'posts/index': PostsIndex,\n}\n</code></pre> <p>It's not uncommon to have multiple identifiers pointing to the same component. This can be used when building <code>index</code> pages use modals instead of a new page for <code>show</code>.</p> <pre><code>const pageIdentifierToPageComponent = {\n  'posts/index': PostsIndex,\n  'posts/show': PostsIndex,\n}\n</code></pre>"},{"location":"configuration/#applicationjs","title":"<code>application.js</code>","text":"<p>Hint</p> <p>Normally you wouldn't need to configure this class as it'll be generated for you.</p> <p>Your <code>Application</code> component inherits from Superglue's ApplicationBase abstract class and is the entry point for your Superglue app. It overrides the methods buildStore, visitAndRemote, and mapping, to perform setup of redux, UJS, and other functionality.</p> <pre><code>import { ApplicationBase } from '@thoughtbot/superglue'\n\nexport default class Application extends ApplicationBase {\n  ...\n}\n</code></pre> <ul> <li> See complete reference      for <code>ApplicationBase</code></li> </ul>"},{"location":"configuration/#flashjs","title":"<code>flash.js</code>","text":"<p>The installation generator will add a <code>flash.js</code> slice to <code>app/javascript/slices</code> and will work with the Rails <code>flash</code>. You can modify this however you like, out of the box:</p> <ul> <li>When using <code>data-sg-visit</code>, all data in the flash slice will be cleared before the request.</li> <li>When using <code>data-sg-visit</code> or <code>data-sg-remote</code>, the recieved flash     will be merged with the current flash. You can change this behavior     by modifying the flash slice.</li> </ul> <p>Hint</p> <p>If you're curious how this works, in your layout, <code>application.json.props</code>, the flash is serialized using <code>flash.to_h</code></p> <p>To use in your page components, simply use a selector.</p> <pre><code>import { useSelector } from 'react-redux'\n\n...\n\nconst flash = useSelector((state) =&gt; state.flash)\n</code></pre> <p>then use the flash as you would normally in a controller</p> <pre><code>def create\n  flash[:success] = \"Post was saved!\"\nend\n</code></pre>"},{"location":"deferments/","title":"Deferments","text":"<p>Sometimes you may want to load parts of your page later, like a slow sidebar, a graph that takes extra time to load, or tab content that shouldn't appear immediately. These scenarios are perfect use cases for Deferments.</p> <p>Deferments are a low effort way to load content later, both automatically and manually. Better yet, most of the work takes place in Rails land in your views.</p>"},{"location":"deferments/#defer-auto","title":"<code>defer: :auto</code>","text":"<p>This option make it easy to defer content in a single setting.</p> views/posts/index.json.propsviews/layouts/application.json.props <pre><code>  json.metrics(defer: [:auto, placeholder: {totalVisitors: 0}]) do\n    sleep 10 # expensive operation\n    json.totalVisitors 30\n  end\n</code></pre> <pre><code>  json.data do\n    yield\n  end\n</code></pre> <p>And that's it! </p>"},{"location":"deferments/#behind-the-scenes","title":"Behind the scenes","text":"<p>When a user lands on a page Superglue will receive</p> <pre><code>{\n  data: {\n    metrics: {\n      totalVisitors: 0\n    }\n  },\n  defers:[\n    {url: '/dashboard?props_at=data.metrics', type: \"auto\"}\n  ],\n  ...other\n}\n</code></pre> <p>Your page components will receive <code>{metrics: {totalVisitors: 0}}</code> and render. Superglue will then make a remote request:</p> <pre><code>remote(\"/dashboard?props_at=data.metrics\")\n</code></pre> <p>10 seconds later the response succeeds with <code>{total_visitors: 30}</code>. Superglue then immutably grafts that payload into the <code>/dashboard</code> page at the path <code>data.metrics</code>. The page state would look like the following:</p> <pre><code>{\n  data: {\n    metrics: {\n      totalVisitors: 30\n    }\n  },\n  defers:[...others],\n  ...other\n}\n</code></pre> <p>Your page component finally recieves the new props and rerenders. For more control, you may provide a <code>success_action</code> or <code>fail_action</code>, and Superglue will dispatch these actions when the promise resolves successfully or fails.</p> <pre><code>json.metrics(defer: [:auto, placeholder: {totalVisitors: 0}, success_action: \"SUCCESS\", fail_action: \"FAIL\"]) do\n  sleep 10 # expensive operation\n  json.totalVisitors 30\nend\n</code></pre>"},{"location":"deferments/#defer-manual","title":"<code>defer: :manual</code>","text":"<p>When you want control over when deferred content loads, e.g., tabbed content, use <code>defer: :manual</code> to stop the content from loading</p> <pre><code>json.metrics(defer: [:manual, placeholder: {totalVisitors: 0}]) do\n  sleep 10 # expensive operation\n  json.totalVisitors 30\nend\n</code></pre> <p>and manually use <code>remote</code></p> <pre><code>remote(\"/dashboard?props_at=data.metrics\")\n</code></pre>"},{"location":"demo/","title":"Demo Application","text":"<p>We have a non-trivial demo application built using Superglue and the original Rails and StimulusJS version built by Sean Doyle The intent is to help you compare and contrast both approaches and showcase how enjoyable and Rails-like Superglue/React/Redux can be.</p> <p></p> <p>We recommend going over the meticulously verbose commit history on Sean's version and comparing that with the Superglue version.</p>"},{"location":"digging/","title":"Digging","text":"<p>Beyond full page navigation, Superglue can make selective updates to parts of the page without a full load through digging. You may recognize digging from earlier docs:</p> <pre><code>/some_current_page?props_at=data.rightDrawer.dailySpecials\n</code></pre> <p>By simply adding a <code>props_at</code> parameter to your requests, you can selectively fetch parts of the page without incurring the cost of loading unneeded content. This is great for functionality like modals, tabs, etc.</p>"},{"location":"digging/#the-props_at-param","title":"The <code>props_at</code> param","text":"<p>The <code>props_at</code> param is a keypath to the content in your PropsTemplate. As a simplified example, imagine this page with no layouts:</p> <pre><code>path = param_to_search_path(params[:props_at])\njson.data(search: path) do\n  json.header do\n    json.search do\n      # Results is a leaf node\n      json.results Post.search(params[:some_search_str])\n    end\n  end\n\n  json.content do\n    json.barChart do\n       ...bar chart data\n    end\n\n    ...\n  end\n\n  ...\nend\n</code></pre> <p>To fetch the <code>json.search</code> node, we would need to walk to <code>data</code> then <code>header</code> then <code>search</code>. Translating that to a url with a <code>props_at</code> param:</p> <pre><code>/dashboard?props_at=data.header.search&amp;some_search_str=haircuts\n</code></pre> <p>Digging is normally combined with using data-sg-remote or remote to update content in async fashion.</p> <p>Info</p> <p><code>props_at</code> can be used with <code>data-sg-visit</code>, but only combined with data-sg-placeholder.</p>"},{"location":"digging/#collections","title":"Collections","text":"<p>There are two ways to query collections. Looking at the following example:</p> <pre><code>path = param_to_search_path(params[:props_at])\njson.data(search: path) do\n  json.posts do\n    json.array! @posts do |post|\n      json.details do\n        json.title post.title\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"digging/#index-based-selection","title":"Index-based selection","text":"<p>You may use an index-based key to fetch an item in a list like so:</p> <pre><code>remote('/dashboard?props_at=data.posts.0.details')\n</code></pre> <p>To enable this functionality, you are required to implement <code>member_at(index)</code> on the passed collection.</p> <p>?&gt; PropsTemplate includes a <code>Array</code> extension which delegates to <code>at</code>. If you've used the Superglue generators, it will be included in an initializer.</p> <p>While traversing by index works fine, it can lead the wrong post being updated if your Redux state has changed by the time the request comes back.</p>"},{"location":"digging/#attribute-based-selection","title":"Attribute-based selection","text":"<p>Attribute-based keys for collections look like this:</p> <pre><code>remote('/dashboard?props_at=data.posts.some_id=1.details')\n</code></pre> <p>Notice that we're now referencing the collection member by <code>some_id=1</code> instead of index. This will fetch the node from the backend and graft it correctly in Redux.</p> <p>To enable this, you are required to implement <code>member_by(attribute, value)</code> on the passed collection AND use the option <code>:key</code> in <code>json.array!</code>. For example:</p> <pre><code>path = param_to_search_path(params[:props_at])\njson.data(search: params[:props_at]) do\n  json.posts do\n    json.array! @posts, key: :some_id do |post|\n      json.details do\n        json.title post.title\n      end\n\n      # The following will be auto appended by the key: option\n      # json.some_id post.some_id\n    end\n  end\nend\n</code></pre>"},{"location":"digging/#partials","title":"Partials","text":"<p>You can even query into partials.</p> <pre><code>remote('/dashboard?props_at=data.posts.some_id=1.details')\n</code></pre> <pre><code>json.data(search: params[:props_at]) do\n  json.posts(partial: 'list_of_posts')do\n  end\nend\n</code></pre> <pre><code># list_of_posts.json.props\njson.array! @posts , key: :some_id do |post|\n  json.details do\n    json.title post.title\n  end\n\n  # The following will be auto appended by the key: option\n  # json.some_id post.some_id\nend\n</code></pre> <p>Info</p> <p>When querying, Superglue will disable caching and deferment until the target node is reached.</p> <p>With digging, many modern SPA functionality can be achieved by just a keypath and a few lines of code.</p>"},{"location":"fragments-and-slices/","title":"Fragments and Slices","text":"<p>Warning</p> <p>This functionality is experimental</p> <p>When building pages, we commonly use partials to extract crosscutting concerns. For example, a shared header:</p> <pre><code>app/\n|-- controllers/\n|-- views/\n|   |-- shared/\n|   |   |-- _header.json.props\n|   |-- posts/\n|   |   |-- index.js\n|   |   |-- index.json.props\n|   |   |-- index.html.erb\n|   |-- comments/\n|   |   |-- index.js\n|   |   |-- index.json.props\n|   |   |-- index.html.erb\n</code></pre> <p>By design this results in duplicate JSON nodes across our <code>pages</code> slice:</p> <pre><code>{\n  pages: {\n    \"/posts\": {\n      data: {\n        header: {\n          email: \"foo@foo.com\"\n        }\n      }\n    },\n    \"/comments\": {\n      data: {\n        header: {\n          email: \"foo@foo.com\"\n        }\n      }\n    },\n  }\n}\n</code></pre> <p>Superglue fragments, and Redux slices are two ways for updating cross-cutting concerns.</p>"},{"location":"fragments-and-slices/#fragments","title":"Fragments","text":"<p>A fragment in Superglue is a rendered partial with a given name:</p> <pre><code>  json.body do\n    json.sideBar partial: [\"application/side_bar\", fragment: \"some_user_side_bar_type\"]\n  end\n</code></pre> <p>By indicating that a partial is a fragment, we store the name of the fragment, and the path where it was found. This metadata is then rendered at the top level of the page response.</p> <p>This has been set up for you in <code>application.json.props</code>:</p> <pre><code>json.data(search: path) do\n  yield json\nend\n\njson.fragments json.fragments!\n</code></pre> <p>The resulting JSON looks like this:</p> <pre><code>data: {\n  ...\n},\nfragments: [\n  { type: :some_user_side_bar_type, partial: 'application/side_bar', path: 'body.sidebar' },\n]\n</code></pre> <p>Info</p> <p>Fragments used in nodes that are deferred do not show up inside the metadata until the deferred nodes are loaded.</p>"},{"location":"fragments-and-slices/#automatic-updates","title":"Automatic updates","text":"<p>Fragments are automatically updated in two cases:</p> <ol> <li> <p>When a new page loads with a fragment Superglue will look at the page store and update nodes marked with the same fragment name across all pages. For example, a header that appears across multiple pages. This is similar to the idea of a Turbo-Frame.</p> </li> <li> <p>If you use a custom reducer to update the fragment, fragments of the same name across all pages will also update. This behavior is controlled by a <code>fragmentMiddleware</code>. This is included when generating a superglue app in your <code>store.js</code> file.</p> </li> </ol> <p>You can turn this behavior off by removing the middleware.</p>"},{"location":"fragments-and-slices/#slices","title":"Slices","text":"<p>Fragments are a lightweight solution to updating cross cutting concerns. With more complex needs, a Redux slice is recommended. Superglue has a few helpers that can make this process easier.</p>"},{"location":"fragments-and-slices/#initialstate","title":"InitialState","text":"<p>You can render your slice's initial state in the slices <code>key</code> of the page object, it'll be merged with the <code>initialState</code> passed to your <code>buildStore</code> function in your application.js</p>"},{"location":"fragments-and-slices/#extrareducers","title":"extraReducers","text":"<p>Use Superglue's redux actions in your slice's extraReducers to modify state in response to lifecycle events. The <code>flashSlice</code> that was generated with the installation is a good example of this.</p> <p><code>BEFORE_FETCH</code> - Action created before a before a fetch is called.</p> <pre><code>{\n  type: \"@@superglue/BEFORE_FETCH\",\n  payload: [..array args that are passed to fetch]\n}\n</code></pre> <p><code>BEFORE_VISIT</code> - Same as above, but called only for a [visit] action.</p> <pre><code>{\n  type: \"@@superglue/BEFORE_VISIT\",\n  payload: [..array args that are passed to fetch]\n}\n</code></pre> <p><code>BEFORE_REMOTE</code> - Same as above, but called only a [remote] action.</p> <pre><code>{\n  type: \"@@superglue/BEFORE_REMOTE\",\n  payload: [..array args that are passed to fetch]\n}\n</code></pre> <p><code>SAVE_RESPONSE</code> - Whenever a page response is received.</p> <pre><code>{\n  type: \"@@superglue/SAVE_RESPONSE\",\n  payload: {\n    pageKey: \"/posts\",\n    page: {...the page response},\n  },\n}\n</code></pre> <p><code>UPDATE_FRAGMENTS</code> - Whenever a fragment is received or changed.</p> <pre><code>{\n  type: \"@@superglue/UPDATE_FRAGMENTS\",\n  payload: {\n    changedFragments: {\n      nameOfYourFragment: renderedFragment,\n      ...\n    },\n  },\n}\n</code></pre>"},{"location":"fragments-and-slices/#turning-a-fragment-into-a-slice","title":"Turning a fragment into a slice","text":"<p>Whenever a fragment is received or updated <code>UPDATE_FRAGMENTS</code> is called. You can pass the state from the payload to your slice to keep it updated.</p> <p>For example: <pre><code>import { createSlice, createAction } from '@reduxjs/toolkit'\nimport { UPDATE_FRAGMENTS } from '@thoughtbot/superglue'\nexport const updateFragments = createAction(UPDATE_FRAGMENTS)\n\nexport const cartSlice = createSlice({\n  name: 'cart',\n  initialState: {},\n  extraReducers: (builder) =&gt; {\n    builder.addCase(updateFragments, (state, action) =&gt; {\n      const { changedFragments } = action.payload;\n\n      if ('cart' in changedFragments) {\n        return changedFragments['cart'];\n      } else {\n        return state;\n      }\n    })\n  }\n})\n</code></pre></p>"},{"location":"functions-passed/","title":"Page utilities","text":"<p>All page components receives the following functions.</p>"},{"location":"functions-passed/#visit-and-remote","title":"visit and remote","text":"<p>These are the methods described in advanced requests.</p>"},{"location":"functions-passed/#navigateto","title":"navigateTo","text":"<p>Superglue comes with a basic <code>Nav</code> component that manages swapping of the different page components. The component comes with a <code>navigateTo</code> method that is passed to all your page components which you can use to perform a full-page navigation using your cached state.</p> <pre><code>navigateTo('/posts', {ownProps:{something: true}})\n</code></pre> <ul> <li> See complete reference      for <code>navigateTo</code></li> </ul>"},{"location":"functions-passed/#saveandprocesspage","title":"saveAndProcessPage","text":"<p>Save and process a rendered view from PropsTemplate. This is the primitive function that visit and remote calls when it receives a page. If you are able to render a page outside the normal request response cycle, e.g, websocket, you can use this function to save the payload.</p> Arguments Type Notes pageKey <code>String</code> The key that Superglue uses to store the response page <code>String</code> A rendered PropsTemplate"},{"location":"functions-passed/#copypage","title":"copyPage","text":"<p>Copies an existing page in the store, and sets it to a different <code>pageKey</code>. Useful for optimistic updates on the next page before you navigate.</p> <pre><code>copyPage({\n  from: '/current_page',\n  to '/next_page'\n})\n</code></pre> Arguments Type Notes {from} <code>String</code> The key of the page you want to copy from. {to} <code>String</code> The key of the page you want to copy to."},{"location":"installation/","title":"Installation","text":"<p>Prerequisite</p> <p>To get started with Superglue, the only prerequisite is to be setup with a javascript bundler. We'll assume esbuild with js-bundling, but you can also use vite.</p> <p>Add the following to your Gemfile</p> <pre><code># Gemfile\ngem 'superglue'\n</code></pre> <p>Run bundle and the installation generator:</p> <pre><code>bundle\nrails superglue:install:web\n</code></pre> <p>The above will generate the following files:</p> <pre><code>.\n\u2514\u2500 app/\n   \u2514\u2500 javascript/\n      \u251c\u2500 slices/\n      \u2502  \u251c\u2500 flash.js\n      |  \u2514\u2500 pages.js\n      \u251c\u2500 actions.js\n      \u251c\u2500 application.js\n      \u251c\u2500 application_visit.js\n      \u251c\u2500 page_to_page_mapping.js\n      \u2514\u2500 store.js\n</code></pre>"},{"location":"installation/#redux-toolkit","title":"Redux toolkit","text":"<p>If you've ever encountered Redux then the files above may seem familiar to you. Superglue works as a complete and fully functional Redux toolkit application. For the most part, all the functionality you would need resides in these files and you'll make minimum edits, but they are made available if you ever need greater control over state management.</p>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>We recommend getting familiar with the following files:</p> <ul> <li><code>application_visit.js</code> - Add custom functionality to Superglue navigation, e.g, progress bars.</li> <li><code>page_to_page_mapping.js</code> - Pairs your <code>props</code> files with your page components.</li> <li><code>flash.js</code> - Seamlessly, integrates with the Rails flash.</li> </ul> <p>For more information, visit the configuration section.</p>"},{"location":"installation/#scaffold","title":"Scaffold","text":"<p>If you'd like to dive right in, you can start with a scaffold:</p> <pre><code>rails generate scaffold post body:string --force --no-template-engine --superglue\n</code></pre> <p>or proceed with a tutorial</p>"},{"location":"page-response/","title":"The <code>page</code> response","text":"<p>Superglue expects your JSON responses to contain the following attributes. If you used Superglue's generators, this would be all set for you in <code>application.json.props</code>.</p> <pre><code>{\n  data: {\n    ...\n  },\n  componentIdentifier,\n  defers,\n  assets,\n  csrfToken,\n  action,\n  path,\n  renderedAt,\n  fragments,\n  restoreStrategy,\n  slices\n}\n</code></pre>"},{"location":"page-response/#data","title":"<code>data</code>","text":"<p>Passed to your page component as its props. In a Superglue application, this would be the contents of your templates, e.g., <code>index.json.props</code>. Note that <code>csrfToken</code>,  <code>fragments</code>, and <code>pageKey</code> will be merged with your props. <code>ownProps</code> are also  merged when navigating</p>"},{"location":"page-response/#componentidentifier","title":"<code>componentIdentifier</code>","text":"<p>A <code>string</code> to instruct Superglue which component to render. The generated <code>application.json.props</code> will set this to the <code>active_template_virtual_path</code> (added by props_template), but you can customize this to fit your needs.</p> <pre><code># application.json.props\njson.componentIdentifier active_template_virtual_path\n</code></pre> <p>You can control which <code>componentIdentifier</code> will render which component in the <code>page_to_page_mapping.js</code>.</p> <ul> <li> See reference   for page_to_page_mapping.js</li> </ul>"},{"location":"page-response/#assets","title":"<code>assets</code>","text":"<p>An <code>array</code> of asset fingerprint <code>string</code>s. Used by Superglue to detect the need to refresh the browser due to new assets. You can control the refresh behavior in <code>application_visit.js</code>.</p>"},{"location":"page-response/#csrftoken","title":"<code>csrfToken</code>","text":"<p>The authenticity token that Superglue will use for non-GET request made by using <code>visit</code> or <code>remote</code> thunks. This includes forms that have the <code>data-sg-visit</code> or <code>data-sg-remote</code> attribute.</p>"},{"location":"page-response/#action-and-path","title":"<code>action</code> and <code>path</code>","text":"<p>Only included when <code>props_at</code> is part of the request parameters. <code>action</code> is always set to <code>graft</code> and <code>path</code> is the camelCase keypath to the requested node. Superglue uses these attributes to immutably graft a node from the server-side to the client-side.</p>"},{"location":"page-response/#renderedat","title":"<code>renderedAt</code>","text":"<p>An UNIX timestamp representing the time the response was rendered.</p>"},{"location":"page-response/#fragments","title":"<code>fragments</code>","text":"<p>An <code>array</code> of fragments. In <code>application.json.props</code> this is set to <code>json.fragments!</code>.</p>"},{"location":"page-response/#restorestrategy","title":"<code>restoreStrategy</code>","text":"<p>By specifying the restore strategy used (<code>fromCacheOnly</code>, <code>revisitOnly</code>, or <code>fromCacheAndRevisitInBackground</code>), you can control what superglue does when encountering the page again when pressing the back or forward browser navigation buttons.</p> <ul> <li><code>fromCacheAndRevisitInBackground</code> will transition to the cached page, then   issue a visit in the background, redirecting and replacing history if needed.   This is the option set in <code>application.json.props</code> when using the generators.</li> <li><code>revisitOnly</code> will always issue a visit request in the background before</li> <li><code>fromCacheOnly</code> will only restore the page from cache   transitioning</li> </ul>"},{"location":"page-response/#slices","title":"<code>slices</code>","text":"<p>An object merged with the <code>initialState</code> when implementing <code>buildStore</code> inside of <code>application.js</code>. You can use this as the initial state for redux slices. Take advantage of the <code>SAVE_RESPONSE</code> to continually update your slice everytime superglue recieves a new page request.</p>"},{"location":"rails-utils/","title":"Rails utils","text":""},{"location":"rails-utils/#redirect_back_with_props_at","title":"<code>redirect_back_with_props_at</code>","text":"<p>A helper to help retain the <code>props_at</code> parameter as part of the redirect <code>location</code>. This helper has the same method signature as Rails own <code>redirect_back</code>.</p> <pre><code>def create\n  redirect_back_with_props_at fallback_url: '/'\nend\n</code></pre>"},{"location":"rails-utils/#setting-the-content-location","title":"Setting the content location","text":"<p>You can override the URL Superglue uses to display on the address bar and store your response directly from the server using <code>content-location</code>. This is optional. For example:</p> <pre><code>def create\n  @post = Post.new(post_params)\n\n  if @post.save\n    redirect_to @post, notice: 'Post was successfully created.'\n  else\n    response.set_header(\"content-location\", new_post_path)\n    render :new\n  end\nend\n</code></pre>"},{"location":"redux-state-shape/","title":"The store shape","text":"<p>Superglue occupies 2 nodes in your Redux state tree:</p> <pre><code>{\n  superglue: {\n    csrfToken,\n    currentPageKey,\n    pathname,\n    search,\n    hash,\n  },\n  pages: {\n    '/dashboard': { ..page received from `/dashboard`.. },\n    '/posts?foo=123': {... page received from `/posts?foo=123` },\n  }\n}\n</code></pre>"},{"location":"redux-state-shape/#superglue","title":"<code>superglue</code>","text":"<p>The <code>superglue</code> node contains information about your application that you may find useful. You may read from this store, but do not write.</p>"},{"location":"redux-state-shape/#pages","title":"<code>pages</code>","text":"<p>The <code>pages</code> node is where rendered pages live. It's a hash where the keys are the pathname + query of your url, known throughout the documentation as <code>pageKey</code>, and the values are received JSON responses.</p> <p>The <code>pageKey</code> does not include the location hash of your URL. This is by design, Superglue ignores the location hash and falls back to browser defaults. So while you can visit <code>/posts#foo</code> and <code>/posts</code> in the browser, Superglue will store both as <code>/posts</code>.</p>"},{"location":"redux-state-shape/#architecture-motivation","title":"Architecture motivation","text":"<p>There's less guesswork. Business logic is complex and diverse across industry verticals, but the presentational aspects remain largely unchanged. There will always be a header, a footer, a menu, a body with a list of items, etc.</p> <p>Superglue shapes its store with this observation in mind so that any developer can look at a running application, easily guess the shape of the store, and make close-to-correct assumptions on how to update the store without looking at any code.</p> <p>It's extremely productive with PropsTemplate. A keypath in your url like so <code>remote(/dashboard?props_at=data.content.barChart)</code> is enough to query your content on the server-side, respond with a node, and graft it at the same location in your redux state.</p>"},{"location":"requests/","title":"Requests","text":"<p>When you need more functionality than what UJS offers, Superglue comes with two functions that wrap around fetch, <code>visit</code> and <code>remote</code>.</p>"},{"location":"requests/#visit","title":"visit","text":"<p><code>visit</code> is designed to mimic browser navigation for clicks and form submissions without the impact of a full page reload. There can be only one visit at a time and when successful <code>visit</code> will swap out the current page component for the next one.</p> <p>At glance it looks like this:</p> <pre><code>sequenceDiagram\n    autonumber\n    Browser -&gt;&gt; Superglue: Click request to `/posts/new` intercepted\n    activate Superglue\n    Superglue --&gt;&gt; Server: Re-request with format JSON `/posts/new.json`\n    activate Server\n    Server --&gt;&gt; Superglue: `/posts/new.json` response\n    Superglue --&gt;&gt; Superglue: Save response and swap page components\n    deactivate Server\n    Superglue --&gt;&gt; Browser: Update browser history, scroll position\n    deactivate Superglue</code></pre> <p>Hint</p> <p>Its possible to modify the visit payload before it saves to the store. See the beforeSave callback.</p> <ul> <li> See complete reference      for <code>visit</code></li> </ul>"},{"location":"requests/#remote","title":"remote","text":"<p>Use <code>remote</code> when you want to asynchronously update parts of a page or save a page to the store without swapping the page component or change the browser history. Unlike visit, you can fire off as many async <code>remote</code> requests as you want.</p> <p>Hint</p> <p>Its possible to modify the remote payload before it saves to the store. See the beforeSave callback.</p> <p>By default, <code>remote</code> saves or updates the response to the current page that the user is seeing. At glance it looks like this:</p> <pre><code>sequenceDiagram\n  alt target default current page\n    autonumber\n    Browser -&gt;&gt; Superglue: Click request to `/posts/new` intercepted\n    activate Superglue\n    Superglue --&gt;&gt; Server: Re-request with format JSON `/posts/new.json`\n    activate Server\n    Server --&gt;&gt; Superglue: `/posts/new.json` response\n    Superglue --&gt;&gt; Superglue: Save response or update current page\n    Superglue --&gt;&gt; Browser: User on current page sees update\n    deactivate Server\n    deactivate Superglue\n  end</code></pre> <p>If you provide a <code>pageKey</code> you can also target a different page in your store not visible to the user.</p> <pre><code>sequenceDiagram\n  alt target another page in the store\n    autonumber\n    Browser -&gt;&gt; Superglue: Click request to `/posts/new` intercepted\n    activate Superglue\n    Superglue --&gt;&gt; Server: Re-request with format JSON `/posts/new.json`\n    activate Server\n    Server --&gt;&gt; Superglue: `/posts/new.json` response\n    Superglue --&gt;&gt; Superglue: Save response or update target page\n    Note right of Browser: User does not see an update to the current page\n    deactivate Server\n    deactivate Superglue\n  end</code></pre> <ul> <li> See complete reference      for <code>remote</code></li> </ul> <p>Customizations</p> <p>You can modify the behavior of <code>visit</code> and <code>remote</code> functions globally from <code>application_visit.js</code>. If you need a global customization, e.g, progress bars, you can add them there.</p>"},{"location":"requests/#differences-from-ujs","title":"Differences from UJS","text":"<p>Superglue UJS selectively exposes options of <code>visit</code> and <code>remote</code> as data attribute and is architected for forms and links. The <code>visit</code> and <code>remote</code> thunks are functions that return promises, allowing for greater flexibility.</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#hello-world","title":"Hello World","text":"<p>Lets build a simple app to get familiar with Superglue.</p>"},{"location":"tutorial/#start-with-the-usual","title":"Start with the usual","text":"<p>Add a route and a controller to an app that followed the installation steps.</p> <p>Info</p> <p>The installation steps will include a layout <code>application.json.props</code> that's implicitly used in this tutorial.</p> <code>routes.rb</code><code>greet_controller.rb</code> <p>in <code>app/config/routes.rb</code></p> <pre><code>resource :greet, only: :show\n</code></pre> <p>in <code>app/controllers/greet_controller.rb</code></p> <pre><code>class GreetController &lt; ApplicationController\n  def show\n  end\nend\n</code></pre>"},{"location":"tutorial/#add-the-views","title":"Add the views","text":"<p>Next lets add the following views. Here we're splitting the usual <code>show.html.erb</code> into 3 parts:</p> <ul> <li><code>app/views/greet/show.json.props</code></li> <li><code>app/views/greet/show.js</code></li> <li><code>app/views/greet/show.html.erb</code></li> </ul> 1. <code>show.json.props</code>2. <code>show.js</code>3. <code>show.html.erb</code> <p>If you've used Jbuidler, this should look familiar. Here, we're using props_template, a Jbuilder inspired templating DSL built for superglue.</p> <p>Info</p> <p>Shape the page to how you would visually organize your components. Superglue encourages you to shape <code>json</code> responses to include both data AND presentation.</p> <pre><code>json.body do\n  json.greet \"Hello world\"\nend\n\njson.footer \"Made with hearts\"\n</code></pre> <p>This is the page component that will recieve the result of <code>show.json.props</code>.</p> <pre><code>import React from 'react'\n\nexport default function GreetShow({\n  body,\n  footer\n}) {\n  const {greet} = body\n\n  return (\n    &lt;h1&gt;{greet}&lt;/h1&gt;\n    &lt;span&gt;{footer}&lt;/span&gt;\n  )\n}\n</code></pre> <p>Info</p> <p>This file is usually generated by a scaffold and stays exactly the same regardless if its <code>index.html.erb</code>, <code>show.html.erb</code>, <code>edit.html.erb</code>, etc.</p> <pre><code>&lt;% initial_state = controller.render_to_string(formats: [:json], locals: local_assigns, layout: true) %&gt;\n\n&lt;script type=\"text/javascript\"&gt;\n  window.SUPERGLUE_INITIAL_PAGE_STATE=&lt;%= initial_state.html_safe %&gt;;&lt;%# erblint:disable ErbSafety %&gt;\n&lt;/script&gt;\n\n&lt;div id=\"app\"&gt;&lt;/div&gt;\n</code></pre> <p>This file renders <code>show.json.props</code>, injects it globally as the initial state to be picked up by Superglue on the browser.</p>"},{"location":"tutorial/#connect-the-dots","title":"Connect the dots","text":"<p>The json payload that gets rendered into <code>show.html.erb</code> also contains information about the template it rendered from the <code>componentIdentifier</code>.</p> <p>Info</p> <p>If you do not knowing what the <code>componentIdentifier</code> of a page is, you can go to the <code>json</code> version of the page on your browser to see what gets rendered. In our case: http://localhost:3000/greet.json</p> <p>We're going to use the <code>componentIdentifier</code> to tie <code>show.json.props</code> to <code>show.js</code> so superglue knows which component to render with which response by modifying <code>app/javascript/page_to_page_mapping.js</code>.</p> 1. Example <code>greet.json</code>2. <code>page_to_page_mapping.js</code> <p>The layout for <code>show.json.props</code> is located at <code>app/views/layouts/application.json.props</code>. It conforms to superglue's payload response, and uses the <code>active_template_virtual_path</code> as the <code>componentIdentifier</code>.</p> <pre><code>{\n  data: {\n    body: {\n      greet: \"Hello world\"\n    }\n    footer: \"Made with hearts\"\n  },\n  componentIdentifier: \"greet/show\",\n  ...\n}\n</code></pre> <pre><code>import GreetShow from '../views/greet/show'\n\nexport const pageIdentifierToPageComponent = {\n  'greet/show': GreetShow,\n};\n</code></pre>"},{"location":"tutorial/#finish","title":"Finish","text":"<p>Run a rails server and go to http://localhost:3000/greet.</p>"},{"location":"tutorial/#productivity","title":"Productivity","text":"<p>That was quite an amount of steps to get to a Hello World. For simple functionality it's not immediately obvious where Superglue fits, but for medium complexity and beyond, Superglue shines where it can be clunky for tools like Turbo, Hotwire and friends.</p> <p>Let's add some complexity to the previous sample.</p>"},{"location":"tutorial/#digging-for-content","title":"Digging for content","text":"<p>But first! A quick dive into props_template. Click on the tabs to see what happens when <code>@path</code> changes for the example below.</p> <pre><code>json.data(search: @path) do\n  json.body do\n    json.chart do\n      sleep 10\n      json.header \"Sales\"\n    end\n\n    json.user do\n      json.name \"John\"\n    end\n  end\n\n  json.footer do\n    json.year \"2003\"\n  end\nend\n\njson.componentIdentifier \"someId\"\n</code></pre> <code>data</code><code>data.body</code><code>data.body.user</code><code>data.footer</code> <p>When <code>@path = ['data']</code>. There's a 10 second sleep, and the output will be:</p> <pre><code>{\n  data: {\n    body: {\n      chart: {\n        header: \"Sales\"\n      },\n      user: {\n        name: \"John\"\n      }\n    },\n    footer: {\n      year: \"2003\"\n    }\n  },\n  componentIdentifier: \"someId\"\n}\n</code></pre> <p>When <code>@path = ['data', 'body']</code>. There's a 10 second sleep, and the output will be:</p> <pre><code>{\n  data: {\n    chart: {\n      header: \"Sales\"\n    },\n    user: {\n      name: \"John\"\n    }\n  },\n  componentIdentifier: \"someId\"\n}\n</code></pre> <p>When <code>@path = ['data', 'body', 'user']</code>, there is no wait, and the <code>json</code> will be:</p> <pre><code>{\n  data: {\n    name: \"john\"\n  },\n  componentIdentifier: \"someId\"\n}\n</code></pre> <p>When <code>@path = ['data', 'year']</code>, there is no wait, and the <code>json</code> will be:</p> <pre><code>{\n  data: {\n    year: \"2003\"\n  },\n  componentIdentifier: \"someId\"\n}\n</code></pre>"},{"location":"tutorial/#continuing-where-we-last-left-off","title":"Continuing where we last left off","text":"<p>Lets add a 5 second sleep to <code>show.json.props</code> so ever user is waiting 5 seconds for every page load.</p> <p><code>show.json.props</code></p> <pre><code>json.body do\n  sleep 5\n  json.greet \"Hello world\"\nend\n\njson.footer \"Made with hearts\"\n</code></pre> <p>How should we improve the user experience?</p>"},{"location":"tutorial/#load-the-content-later-manual-deferment","title":"Load the content later (Manual deferment)","text":"<p>What if we add a link on the page that would load the greeting async? Sounds like a good start, lets do that. We'll use <code>defer: :manual</code> to tell props_template to skip over the block.</p> <code>show.json.props</code>output<code>show.js</code> <pre><code>json.body(defer: :manual)\n  sleep 5\n  json.greet \"Hello world\"\nend\n\njson.footer \"Made with hearts\"\n</code></pre> <p>Adding <code>defer: :manual</code> will replace the contents with an empty object.</p> <pre><code>{\n  data: {\n    body: {},\n    footer: \"Made with hearts\"\n  },\n  componentIdentifier: \"greet/show\",\n  ...\n}\n</code></pre> <p>We'll also have to handle the case when there is no greeting.</p> <p>Info</p> <p>We'll improve on this approach. The <code>defer</code> option can specify a fallback.</p> <pre><code>import React from 'react'\n\nexport default function GreetShow({\n  body,\n  footer,\n  loadGreetPath\n}) {\n  const {greet} = body\n\n  return (\n    &lt;h1&gt;{greet || \"Waiting for greet\"}&lt;/h1&gt;\n    &lt;a href={loadGreetPath} data-sg-remote&gt;Load Greet&lt;/a&gt;\n    &lt;span&gt;{footer}&lt;/span&gt;\n  )\n}\n</code></pre>"},{"location":"tutorial/#add-a-link","title":"Add a link","text":"<p>Now when the user lands on the page, we're no longer waiting 5 seconds. Lets add a link that will dig for the missing content to replace \"Waiting for greet\".</p> <code>show.json.props</code><code>show.js</code> <p>Add a url for the <code>href</code> link with <code>props_at</code> param. This is used on the <code>application.json.props</code> layout that instructs PropsTemplate to dig.</p> <pre><code>json.body(defer: :manual)\n  sleep 5\n  json.greet \"Hello world\"\nend\n\njson.loadGreetPath greet_path(props_at: \"data.body\")\n\njson.footer \"Made with hearts\"\n</code></pre> <p>Superglue embraces Unobtrusive Javascript. Add a <code>data-sg-remote</code> to any link, and superglue will take care of making the fetch call.</p> <pre><code>import React from 'react'\n\nexport default function GreetShow({\n  body,\n  footer,\n  loadGreetPath\n}) {\n  const {greet} = body\n\n  return (\n    &lt;h1&gt;{greet || \"Waiting for greet\"}&lt;/h1&gt;\n    &lt;a href={loadGreetPath} data-sg-remote&gt;Greet!&lt;/a&gt;\n    &lt;span&gt;{footer}&lt;/span&gt;\n  )\n}\n</code></pre>"},{"location":"tutorial/#showjs-alternative","title":"<code>show.js</code> alternative","text":"<p>This version does the same thing. Every page component receives a <code>remote</code> and <code>visit</code> thunk.</p> <pre><code>import React from 'react'\n\nexport default function GreetShow({\n  body,\n  remote,\n  footer,\n  loadGreetPath\n}) {\n  const {greet} = body\n  const handleClick = (e) =&gt; {\n    e.preventDefault()\n    remote(loadGreetPath)\n  }\n\n  return (\n    &lt;h1&gt;{greet || \"Waiting for greet\"}&lt;/h1&gt;\n    &lt;a href={loadGreetPath} onClick={handleClick}&gt;Greet!&lt;/a&gt;\n    &lt;span&gt;{footer}&lt;/span&gt;\n  )\n}\n</code></pre>"},{"location":"tutorial/#finish_1","title":"Finish","text":"<p>And that's it. Now you have a button that will load content in async fashion, but how does it all work? Lets take a look at <code>loadGreetPath</code></p> <pre><code>/greet?props_at=data.greet\n</code></pre> <p>The shape of <code>show.json.props</code> is exactly the same as what is stored in the redux store on <code>pages[\"/greet\"]</code>. With a single keypath on <code>props_at</code> we grabbed the content at <code>data.greet</code> from <code>show.json.props</code> AND stored it on <code>data.greet</code> on <code>pages[\"/greet\"]</code>.</p> <p>Now that's productive!</p>"},{"location":"tutorial/#improvements","title":"Improvements","text":"<p>In practice, there's a far simpler solution: <code>defer: :auto</code>, which would do all of the above without a button.</p> <code>show.json.props</code><code>show.js</code> <p>The only change needed would be to use the <code>:auto</code> option with a placeholder. The response would tell Superglue to:</p> <ol> <li>Save the page (with the placeholder)</li> <li>Look for any deferred nodes</li> <li>Automatically create a remote request for the missing node</li> </ol> <pre><code>json.body(defer: [:auto, placeholder: { greet: \"Waiting for Greet\"})\n  sleep 5\n  json.greet \"Hello world\"\nend\n\njson.footer \"Made with hearts\"\n</code></pre> <p>No changes to the original <code>show.js</code> component. We don't even have to create a conditional, the initial page response will contain a placeholder.</p> <pre><code>import React from 'react'\n\nexport default function GreetShow({\n  body,\n  footer\n}) {\n  const {greet} = body\n\n  return (\n    &lt;h1&gt;{greet}&lt;/h1&gt;\n    &lt;span&gt;{footer}&lt;/span&gt;\n  )\n}\n</code></pre>"},{"location":"ujs/","title":"The return of Rails UJS","text":"<p>Unobtrusive Javascript is an easy way to added single page app like features to HTML links and form tags. Its been a staple feature since Rails 6, but will sunset with the release of Rails 8 in favor of Hotwire and friends.</p> <p>Superglue puts UJS back in the forefront and embues it with superpowers (curtesy of props_template) that makes building SPA-like functionality easy and consistent.</p> <p>Want to reload a shopping cart?</p> <pre><code>&lt;a href=\"/props_at=data.sideBar.shoppingCart\" data-sg-remote&gt;Reload the cart&lt;/a&gt;\n</code></pre> <p>Or maybe load a modal efficiently when the next page has one?</p> <pre><code>&lt;a href=\"/posts/new?props_at=data.modal\" data-sg-visit data-sg-placeholder=\"/posts\"&gt;Create Post&lt;/a&gt;\n</code></pre> <p>With Superglue, there is just one concept. No need for the complexity of Stimulus controllers, Turbo Streams, or Turbo Frames.</p>"},{"location":"ujs/#navigating-with-ujs","title":"Navigating with UJS","text":"<p>Superglue operates like a multipage application. In other to transition to the next page without reloading you'll need to use UJS attributes <code>data-sg-remote</code> or <code>data-sg-visit</code>.</p>"},{"location":"ujs/#data-sg-visit","title":"<code>data-sg-visit</code>","text":"<p>Use <code>data-sg-visit</code> when you want to navigate to the next page and update the address bar without reloading.</p> <pre><code>&lt;a href='/posts/new' data-sg-visit /&gt;\n</code></pre> <p>In the above example, when the link is clicked, Superglue will intercept the click, make a request for <code>/posts/new.json</code>, swap your page component, and pass the payload.</p> <p>Note</p> <p>You are not able to specify the HTTP method used in a UJS link. This is intentional. If you want to create a link that can support different HTML methods, create a form component that looks like a link and use props generated from form_props</p> <p>You can also use <code>data-sg-visit</code> on forms:</p> <pre><code>&lt;form action='/some_url' data-sg-visit /&gt;\n</code></pre>"},{"location":"ujs/#data-sg-placeholder","title":"<code>data-sg-placeholder</code>","text":"<p>A companion attribute for use with <code>data-sg-visit</code>. By specifiying a placeholder, superglue will take the page props at that placeholder and optimistically copies it as the page props for the next page while a request is made.</p> <p>It's for cases when you know with certainty how the next page is going to look like, but you want to selectively fetch just the content you need to make an update without loading the entirety of the next page. For example, modals, tabs, notifications, etc.</p> <pre><code>&lt;a href=\"/posts/new?props_at=data.modal\" data-sg-visit data-sg-placeholder=\"/posts\"&gt;\n  Create Post\n&lt;/a&gt;\n</code></pre>"},{"location":"ujs/#data-sg-remote","title":"<code>data-sg-remote</code>","text":"<p>Use <code>data-sg-remote</code> when you want to update parts of the current page without reloading the screen. You'd can use this with props_template's [digging] to selectively load content.</p> <pre><code>&lt;a href='/posts?page_num=2&amp;props_at=data.body.postsList' data-sg-remote/&gt;\n  Next Page\n&lt;/a&gt;\n</code></pre> <p>You can also use <code>data-sg-remote</code> on forms.</p> <pre><code>&lt;form action=\"/posts\"  method=\"GET\" data-sg-remote&gt;\n  &lt;input type=\"search\" .... /&gt;\n  ....\n&lt;/form&gt;\n</code></pre>"},{"location":"recipes/modals/","title":"Modals","text":"<p>Modals are easy. Lets imagine a scenario where we have two urls:</p> <ol> <li><code>/posts</code></li> <li><code>/posts/new</code></li> </ol> <p>When a user visits <code>/posts/new</code> from <code>/posts</code>, we want a modal to appear overlaying the existing list of posts. The overlay should work if a user chooses instead to directly visit <code>/posts/new</code>.</p>"},{"location":"recipes/modals/#the-setup","title":"The setup","text":"<p>Arriving at both urls results in a seeing list of posts. Lets set up the controller and the <code>page_to_page_mapping.js</code> the same way.</p> <code>posts_controller.rb</code><code>page_to_page_mapping.js</code> <p>Same template different action</p> <p>Notice that we're rendering the <code>index</code> for the <code>new</code> action. While the content is the same, the <code>componentIdentifier</code> is different as that has been setup to use the controller and action name.</p> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\nend\n\ndef new\n  @posts = Post.all\n  render :index\nend\n</code></pre> <p>Info</p> <p>Similarly, we tie the <code>componentIdentifier</code> to the same page component.</p> <pre><code>import PostIndex from '../views/posts/index'\n\nexport const pageIdentifierToPageComponent = {\n  'posts/index': PostIndex,\n  'posts/new': PostIndex,\n};\n</code></pre>"},{"location":"recipes/modals/#add-a-link-to-postsnew","title":"Add a link to <code>/posts/new</code>","text":"<p>Imagine a list of posts, lets add a button somewhere on the index page to direct the user to <code>/posts/new</code>. As seen previously, both <code>/posts</code> and <code>/posts/new</code> render the same thing.</p> <code>posts/index.json.props</code><code>posts/index.js</code> <pre><code># app/views/posts/index.json.props\n\n...\n\njson.newPostPath new_post_path\n</code></pre> <pre><code>export default PostIndex = ({\n  newPostPath,\n  ...rest\n}) =&gt; {\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n      &gt;\n      New Post\n    &lt;/a&gt;\n    ...\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#the-modal","title":"The modal","text":"<p>Now the link appears and we're able to navigate to <code>/posts/new</code>, but <code>/posts/new</code> is missing a modal. Not surprising as both routes are rendering the same content.</p> <p>Lets add a modal.</p> <code>posts/index.json.props</code><code>index.js</code><code>Modal.js</code> <p>Info</p> <p>For simplicity, we'll use a \"Hello World\" as the modal contents</p> <pre><code># app/views/posts/index.json\n\n...\n\njson.newPostPath new_post_path\n\n+ json.createPostModal do\n+   json.greeting \"Hello World\"\n+ end\n</code></pre> <pre><code>+ import Modal from './Modal'\n\nexport default PostIndex = ({\n  newPostPath,\n  createPostModal\n  ...rest\n}) =&gt; {\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n    &gt;\n      New Post\n    &lt;/a&gt;\n+   &lt;Modal {...createPostModal} /&gt;\n    ...\n  )\n}\n</code></pre> <p>Info</p> <p>This is a simplified modal, in practice you'll use this with <code>&lt;Dialog&gt;</code> or other modal library.</p> <pre><code>import Modal from './Modal'\n\nexport default Modal = ({\n  greeting\n}) =&gt; {\n  return (\n    &lt;div className=\"my-modal\"&gt;{greeting}&lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#too-many-modals","title":"Too many modals","text":"<p>Unfortunately, now BOTH routes have modals! Lets fix that by adding a conditional render.</p> <code>index.json.props</code><code>posts_controller.rb</code><code>Modal.js</code> <pre><code># app/views/posts/index.json.props\n\n...\n\njson.newPostPath new_post_path\n\njson.createPostModal do\n  json.greeting \"Hello World\"\n+ json.showModal @show_modal\nend\n</code></pre> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\n+ @show_modal = false\nend\n\ndef new\n  @posts = Post.all\n+ @show_modal = true\n  render :index\nend\n</code></pre> <pre><code>import Modal from './Modal'\n\nexport default Modal = ({\n  greeting,\n+  showModal\n}) =&gt; {\n  return (\n-   &lt;div className=\"my-modal\"&gt;{greeting}&lt;/div&gt;\n+   {showModal &amp;&amp; &lt;div className=\"my-modal\"&gt;{greeting}&lt;/div&gt;}\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#finish","title":"Finish!","text":"<p>Awesome! We have modals! Unfortunately, clicking <code>&lt;a href={newPostPath}&gt;New Post&lt;/a&gt;</code> will cause a new page load. We can move the page load by adding <code>data-sg-visit</code> to the link. With <code>data-sg-visit</code>, Superglue will navigate to the next page without reloading the page, just like Turbo.</p>"},{"location":"recipes/modals/#postsindexjs","title":"<code>posts/index.js</code>","text":"<pre><code>import Modal from './Modal'\n\nexport default PostIndex = ({\n  newPostPath,\n  createPostModal,\n  ...rest\n}) =&gt; {\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n+     data-sg-remote\n    &gt;\n      New Post\n    &lt;/a&gt;\n    &lt;Modal {...createPostModal} /&gt;\n    ...\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#optimization","title":"Optimization","text":"<p>With the above, a click on New Post while on <code>/posts</code> will</p> <ol> <li>Fetch <code>/posts/new</code> with <code>format=json</code></li> <li>Save the page to the store</li> <li>Swap the page components</li> <li>Change the url</li> </ol> <p>Unfortunately, step 1 is still a full page load. Commonly, we just want to load the modal without loading the entire page.</p> <p>Lets fix that!</p>"},{"location":"recipes/modals/#indexjson","title":"<code>index.json</code>","text":"<p>Recall how digging for content works. We'll add a <code>props_at</code> that digs for the modal on <code>/posts/new</code> while skipping other content on that page.</p> <pre><code># app/views/posts/index.json\n\n...\n\n- json.newPostPath new_post_path\n+ json.newPostPath new_post_path(props_at: `data.createPostModal`)\n\njson.createPostModal do\n  json.greeting \"Hello World\"\n  json.showModal @show_modal\nend\n</code></pre>"},{"location":"recipes/modals/#postsindexjs_1","title":"<code>posts/index.js</code>","text":"<p>Lastly add <code>data-sg-placeholder</code> to the link.</p> <pre><code>import Modal from './Modal'\n\nexport default PostIndex = ({\n  newPostPath,\n  createPostModal,\n  ...rest\n}) =&gt; {\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n      data-sg-visit\n+     data-sg-placeholder=\"/posts\"\n      &gt;\n      New Post\n    &lt;/a&gt;\n    &lt;Modal {...createPostModal} /&gt;\n    ...\n  )\n}\n</code></pre> <p>With the placeholder, the sequence becomes:</p> <ol> <li>Copy the state in <code>/posts</code> to <code>/posts/new</code> in the store.</li> <li>Fetch <code>/posts/new?props_at=data.createPostModal</code></li> <li>Graft the result to the store at <code>/posts/new</code></li> <li>Swap the page components</li> <li>Change the url</li> </ol> <p>Info</p> <p>Normally, <code>props_at</code> cannot be used with <code>data-sg-visit</code>, that's because the state needs to exist for Superglue to know where to graft. With <code>data-sg-placeholder</code>, we take an existing page and copy that over as a placeholder for what doesn't exist yet.</p>"},{"location":"recipes/progress-bar/","title":"Progress Bars","text":"<p>Superglue does not come with a progress bar as it can be a personalized choice on how the indicator functions and looks. Instead we have <code>application_visit.js</code> where you can add the functionality however you like.</p> <p>In this recipe, we'll add a simple progress bar that will show when <code>visit</code> and <code>remote</code> gets used. You can choose to implement it for only <code>visit</code> instead.</p> <pre><code>yarn add request-stripe\n</code></pre> <p>And make the following edits to <code>application_visit.js</code></p> <pre><code>import { visit, remote } from '@thoughtbot/superglue/action_creators'\n+ import { requestStripe } from 'request-stripe';\n\nexport function buildVisitAndRemote(ref, store) {\n  const appRemote = (...args) =&gt; {\n+   const done = requestStripe();\n    return store.dispatch(remote(...args))\n+       .finally(() =&gt; done())\n  }\n\n  const appVisit = (...args) =&gt; {\n+   const done = requestStripe();\n\n    // Do something before\n    // e.g, show loading state, you can access the current pageKey\n    // via store.getState().superglue.currentPageKey\n    let { action } = args\n\n    return store\n      .dispatch(visit(...args))\n      .then((meta) =&gt; {\n        // The assets fingerprints changed, instead of transitioning\n        // just go to the URL directly to retrieve new assets\n        if (meta.needsRefresh) {\n          window.location = meta.url\n          return\n        }\n\n        ref.current.navigateTo(meta.pageKey, {\n          action: meta.suggestedAction,\n        })\n\n        // always return meta\n        return meta\n      })\n      .finally(() =&gt; {\n        // Do something after\n        // e.g, hide loading state, you can access the changed pageKey\n        // via getState().superglue.currentPageKey\n+       done()\n      })\n      .catch((err) =&gt; {\n        const response = err.response\n\n        if (!response) {\n          console.error(err)\n          return\n        }\n\n        if (response.ok) {\n          // err gets thrown, but if the response is ok,\n          // it must be an html body that\n          // superglue can't parse, just go to the location\n          window.location = response.url\n        } else {\n          if (response.status &gt;= 400 &amp;&amp; response.status &lt; 500) {\n            window.location = '/400.html'\n            return\n          }\n\n          if (response.status &gt;= 500) {\n            window.location = '/500.html'\n            return\n          }\n        }\n      })\n  }\n\n  return { visit: appVisit, remote: appRemote }\n}\n</code></pre>"},{"location":"recipes/spa-pagination/","title":"Easy SPA Pagination","text":"<p>Pagination without reload is easy to add.</p>"},{"location":"recipes/spa-pagination/#starting-point","title":"Starting point","text":"<p>Lets pretend that we're already able to see a list of posts.</p> <code>posts_controller.rb</code><code>index.json.props</code><code>index.js</code> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\nend\n</code></pre> <pre><code># app/views/posts/index.json.props\n\njson.rightNav do\n  ...\nend\n\njson.posts do\n  json.list do\n    json.array! @posts do |post|\n      json.id post.id\n      json.body post.body\n      json.editPostPath edit_post_path(post)\n    end\n  end\nend\n</code></pre> <pre><code># app/views/posts/index.js\n\nimport React from 'react'\nimport PostList from './PostList'\nimport RightNav from './RightNav'\n\nexport default PostIndex = ({\n  posts,\n  rightNav\n}) =&gt; {\n  return (\n    &lt;&gt;\n      &lt;RightNav {...rightNav}&gt;\n      &lt;PostList items={posts}&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/spa-pagination/#add-gems","title":"Add gems","text":"<p>Lets also add Kaminari.</p> <pre><code>bundle install kaminari\n</code></pre>"},{"location":"recipes/spa-pagination/#add-pagination","title":"Add pagination","text":"<p>The changes here are almost same with the <code>.erb</code> counterpart. We're using <code>path_to_next_page</code> and <code>path_to_prev_page</code> which come with Kaminari.</p> <p>Info</p> <p>Some helpers like <code>paginate</code> output HTML instead of JSON, but we can still use more primitives methods.</p> <code>posts_controller.rb</code><code>index.json.props</code><code>index.js</code> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\n+   .page(params[:page_num])\n+   .per(10)\n+   .order(created_at: :desc)\nend\n</code></pre> <pre><code># app/views/posts/index.json.props\n\njson.rightNav do\n  ...\nend\n\njson.posts do\n  json.list do\n    json.array! @posts do |post|\n      json.id post.id\n      json.body post.body\n      json.editPostPath edit_post_path(post)\n    end\n  end\n+\n+ json.pathToNextPage path_to_next_page(@posts)\n+ json.pathToPrevPage path_to_prev_page(@posts)\nend\n</code></pre> <pre><code># app/views/posts/index.js\nimport React from 'react'\nimport PostList from './PostList'\nimport RightNav from './RightNav'\n\nexport default PostIndex = ({\n  posts,\n  rightNav\n+  pathToNextPage,\n+  pathToPrevPage\n}) =&gt; {\n  return (\n    &lt;&gt;\n      &lt;PostList items={posts}&gt;\n+     &lt;a\n+       href={pathToNextPage}\n+     &gt;\n+       Next Page\n+     &lt;/a&gt;\n+     &lt;a\n+       href={pathToPrevPage}\n+     &gt;\n+       Prev Page\n+     &lt;/a&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/spa-pagination/#smooth-navigation","title":"Smooth navigation","text":"<p>The above adds pagination, but each click on Next Page is a new page load.</p> <p>Lets navigate without a reload. In this example, we're using <code>data-sg-remote</code>, which would set the current page's state to the response without changing the URL.</p> <p><code>index.js</code></p> <pre><code># app/views/posts/index.js\nimport React from 'react'\nimport PostList from './PostList'\nimport RightNav from './RightNav'\n\nexport default PostIndex = ({\n  posts,\n  rightNav,\n  pathToNextPage,\n  pathToPrevPage\n}) =&gt; {\n  return (\n    &lt;&gt;\n      &lt;PostList items={posts}&gt;\n      &lt;a\n        href={pathToNextPage}\n+       data-sg-remote\n      &gt;\n        Next Page\n      &lt;/a&gt;\n      &lt;a\n        href={pathToPrevPage}\n+       data-sg-remote\n      &gt;\n        Prev Page\n      &lt;/a&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/spa-pagination/#optimize","title":"Optimize!","text":"<p>Lets skip <code>data.rightNav</code> when navigating and dig for <code>data.posts</code>. For the user, only the posts lists change, but the rightNav stays the same.</p> <p>Info</p> <p>In effect, this achieves the same functionality as Turbo Frames, but Superglue leans more on Unobtrusive Javascript and a simple <code>props_at</code> for better ergonomics.</p> <p><code>index.json.props</code></p> <p>Recall how digging for content works. We'll add a <code>props_at</code> that digs for the <code>json.posts</code> while skipping other content on that page.</p> <pre><code># app/views/posts/index.json.props\n\njson.rightNav do\n  ...\nend\n\njson.posts do\n  json.list do\n    json.array! @posts do |post|\n      json.id post.id\n      json.body post.body\n      json.editPostPath edit_post_path(post)\n    end\n  end\n\n- json.pathToNextPage path_to_next_page(@posts)\n+ json.pathToNextPage path_to_next_page(@posts, props_at: 'data.posts')\n- json.pathToPrevPage path_to_prev_page(@posts)\n+ json.pathToPrevPage path_to_prev_page(@posts, props_at: 'data.posts')\nend\n</code></pre>"},{"location":"recipes/ssr/","title":"Server-Side Rendering","text":"<p>Superglue does not include server-side rendering out of the box, but you can easily add it with humid.</p> <p>Follow the instructions. Then, if you're using esbuild, create a <code>app/javascript/packs/server_rendering.js</code>:</p> <pre><code>import React from 'react';\nimport { ApplicationBase } from '@thoughtbot/superglue';\nimport { pageIdentifierToPageComponent } from './page_to_page_mapping';\nimport { buildStore } from './store'\nimport { renderToString } from 'react-dom/server';\n\nrequire(\"source-map-support\").install({\n  retrieveSourceMap: filename =&gt; {\n    return {\n      url: filename,\n      map: readSourceMap(filename)\n    };\n  }\n});\n\nclass Application extends ApplicationBase {\n  mapping() {\n    return pageIdentifierToPageComponent;\n  }\n\n  visitAndRemote(navRef, store) {\n    return {visit: () =&gt; {}, remote: () =&gt; {}}\n  }\n\n  buildStore(initialState, { superglue, pages}) {\n    return buildStore(initialState, superglue, pages);\n  }\n}\n\nsetHumidRenderer((json) =&gt; {\n  const initialState = JSON.parse(json)\n  return renderToString(\n    &lt;Application initialPage={initialState}/&gt;\n  )\n})\n</code></pre> <p>Next</p> <pre><code>yarn add esbuild-plugin-polyfill-node text-encoding\n</code></pre> <p>and add a esbuild build file.</p> <pre><code>import * as esbuild from 'esbuild'\nimport { polyfillNode } from \"esbuild-plugin-polyfill-node\";\n\nawait esbuild.build({\n  entryPoints: ['app/javascript/server_rendering.js'],\n  bundle: true,\n  platform: \"browser\",\n  define: {\n    \"process.env.NODE_ENV\": '\"production\"'\n  },\n  sourcemap: true,\n  outfile: 'app/assets/builds/server_rendering.js',\n  logLevel: \"info\",\n  loader: {\n    \".js\": \"jsx\",\n    \".svg\": \"dataurl\"\n  },\n  inject: [\"./shim.js\"],\n  plugins: [\n    polyfillNode({\n      globals: false\n    }),\n  ]\n})\n</code></pre> <p>Add a <code>shim.js</code> for the above. We'll need this for the v8 environment that mini-racer runs on.</p> <pre><code>export {TextEncoder, TextDecoder} from 'text-encoding'\n</code></pre> <p>Add a line to your <code>package.json</code> like so:</p> <pre><code>   \"scripts\": {\n+    \"build:ssr\": \"node ./build-ssr.mjs\"\n</code></pre> <p>Use <code>Humid.render</code> in all your ERB templates <code>index.html.erb</code>:</p> <pre><code>- &lt;div id=\"app\"&gt;&lt;/div&gt;\n+ &lt;div id=\"app\"&gt;&lt;%= Humid.render(initial_state).html_safe %&gt;&lt;/div&gt;\n</code></pre> <p>!&gt; Do not render spacing above. If you do, React will not hydrate properly and warn <code>Hydration failed because the initial UI does not match what was rendered on the server</code></p> <p>Change your <code>application.js</code> to use <code>hydrateRoot</code>:</p> <pre><code>- import { createRoot } from 'react-dom/client';\n+ import { hydrateRoot } from 'react-dom/client';\n</code></pre> <p>and change the rest of <code>application.js</code> accordingly.</p>"},{"location":"recipes/turbo/","title":"Replicating Turbo behavior","text":"<p>With <code>data-sg-visit</code>, Superglue will always wait for a response before a navigation transition. Turbo's behavior is to transition first if possible while waiting for the response. To replicate this behavior:</p> <p>In your <code>application_visit.js</code> file:</p> <pre><code>import { urlToPageKey } from '@thoughtbot/superglue/utils/url'\n\nconst appVisit = (...args) =&gt; {\n\n  const pageKey = urlToPageKey(args[0])\n+ // attempt to navigate first\n+ this.ref.current.navigateTo(pageKey)\n\n  return store\n    .dispatch(visit(...args))\n    ....\n</code></pre> <p>This is different from restore strategy which controls what happens when the browser's <code>history</code> object pops.</p>"},{"location":"reference/","title":"Superglue","text":""},{"location":"reference/#classes","title":"Classes","text":""},{"location":"reference/#abstract-applicationbase","title":"<code>abstract</code> ApplicationBase","text":"<p>The entry point to your superglue application. You should create a class (Application) that inherit from the ApplicationBase component and override the buildStore, mapping, and visitAndRemote methods.</p> <p>This would be setup for you when installing Superglue at <code>application.js</code>.</p>"},{"location":"reference/#extends","title":"Extends","text":"<ul> <li><code>Component</code>\\&lt;<code>ApplicationProps</code>&gt;</li> </ul>"},{"location":"reference/#constructors","title":"Constructors","text":""},{"location":"reference/#new-applicationbase","title":"new ApplicationBase()","text":"<p>new ApplicationBase(<code>props</code>: <code>ApplicationProps</code>): <code>ApplicationBase</code></p> <p>The constructor of the <code>ApplicationBase</code> class.</p>"},{"location":"reference/#parameters","title":"Parameters","text":"Parameter Type Description <code>props</code> <code>ApplicationProps</code>"},{"location":"reference/#returns","title":"Returns","text":"<p><code>ApplicationBase</code></p>"},{"location":"reference/#overrides","title":"Overrides","text":"<p><code>React.Component&lt;ApplicationProps&gt;.constructor</code></p>"},{"location":"reference/#defined-in","title":"Defined in","text":"<p>lib/index.tsx:151</p>"},{"location":"reference/#methods","title":"Methods","text":""},{"location":"reference/#visitandremote","title":"visitAndRemote()","text":"<p><code>abstract</code> visitAndRemote(<code>navigatorRef</code>: <code>RefObject</code>\\&lt;<code>default</code>&gt;, <code>store</code>: <code>SuperglueStore</code>): {<code>visit</code>: <code>Visit</code>;<code>remote</code>: <code>Remote</code>; }</p> <p>Override this method to return a visit and remote function. These functions will be used by Superglue to power its UJS attributes and passed to your page components. You may customize this functionality to your liking, e.g, adding a progress bar.</p>"},{"location":"reference/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>navigatorRef</code> <code>RefObject</code>\\&lt;<code>default</code>&gt; <code>store</code> <code>SuperglueStore</code>"},{"location":"reference/#returns_1","title":"Returns","text":"<p>{<code>visit</code>: <code>Visit</code>;<code>remote</code>: <code>Remote</code>; }</p> Name Type Defined in <code>visit</code> <code>Visit</code> lib/index.tsx:215 <code>remote</code> <code>Remote</code> lib/index.tsx:215"},{"location":"reference/#defined-in_1","title":"Defined in","text":"<p>lib/index.tsx:211</p> <p></p>"},{"location":"reference/#componentdidmount","title":"componentDidMount()","text":"<p>componentDidMount(): <code>void</code></p> <p>Called immediately after a component is mounted. Setting state here will trigger re-rendering.</p>"},{"location":"reference/#returns_2","title":"Returns","text":"<p><code>void</code></p>"},{"location":"reference/#overrides_1","title":"Overrides","text":"<p><code>React.Component.componentDidMount</code></p>"},{"location":"reference/#defined-in_2","title":"Defined in","text":"<p>lib/index.tsx:217</p> <p></p>"},{"location":"reference/#componentwillunmount","title":"componentWillUnmount()","text":"<p>componentWillUnmount(): <code>void</code></p> <p>Called immediately before a component is destroyed. Perform any necessary cleanup in this method, such as cancelled network requests, or cleaning up any DOM elements created in <code>componentDidMount</code>.</p>"},{"location":"reference/#returns_3","title":"Returns","text":"<p><code>void</code></p>"},{"location":"reference/#overrides_2","title":"Overrides","text":"<p><code>React.Component.componentWillUnmount</code></p>"},{"location":"reference/#defined-in_3","title":"Defined in","text":"<p>lib/index.tsx:232</p> <p></p>"},{"location":"reference/#buildstore","title":"buildStore()","text":"<p><code>abstract</code> buildStore(<code>initialState</code>: {<code>[key: string]</code>: <code>JSONValue</code>; <code>pages</code>: <code>AllPages</code>; }, <code>reducer</code>: {<code>superglue</code>: <code>superglueReducer</code>;<code>pages</code>: <code>pageReducer</code>; }): <code>SuperglueStore</code></p> <p>Override this method and return a Redux store for Superglue to use. This would be setup and generated for you in <code>store.js</code>. We recommend using using Redux toolkit's <code>configureStore</code> to build the store.</p>"},{"location":"reference/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>initialState</code> <code>object</code> A preconfigured intial state to pass to your store. <code>initialState.pages</code> <code>AllPages</code> - <code>reducer</code> <code>object</code> A preconfigured reducer <code>reducer.superglue</code> (<code>state</code>: <code>Partial</code>\\&lt;<code>SuperglueState</code>&gt;, <code>action</code>: <code>UnknownAction</code> | <code>SuperglueReducerAction</code>) =&gt; <code>Partial</code>\\&lt;<code>SuperglueState</code>&gt; - <code>reducer.pages</code> (<code>state</code>: <code>AllPages</code>, <code>action</code>: <code>UnknownAction</code> | <code>PageReducerAction</code>) =&gt; <code>AllPages</code> -"},{"location":"reference/#returns_4","title":"Returns","text":"<p><code>SuperglueStore</code></p>"},{"location":"reference/#defined-in_4","title":"Defined in","text":"<p>lib/index.tsx:248</p> <p></p>"},{"location":"reference/#createhistory","title":"createHistory()","text":"<p>createHistory(): <code>BrowserHistory</code></p>"},{"location":"reference/#returns_5","title":"Returns","text":"<p><code>BrowserHistory</code></p>"},{"location":"reference/#defined-in_5","title":"Defined in","text":"<p>lib/index.tsx:253</p> <p></p>"},{"location":"reference/#mapping","title":"mapping()","text":"<p><code>abstract</code> mapping(): <code>Record</code>\\&lt;<code>string</code>, <code>ComponentType</code>\\&lt;{}&gt;&gt;</p> <p>Override this method and return a mapping between a componentIdentifier and a PageComponent. This will be passed to Superglue to determine which Page component to render with which payload.</p>"},{"location":"reference/#returns_6","title":"Returns","text":"<p><code>Record</code>\\&lt;<code>string</code>, <code>ComponentType</code>\\&lt;{}&gt;&gt;</p>"},{"location":"reference/#defined-in_6","title":"Defined in","text":"<p>lib/index.tsx:270</p> <p></p>"},{"location":"reference/#render","title":"render()","text":"<p>render(): <code>Element</code></p>"},{"location":"reference/#returns_7","title":"Returns","text":"<p><code>Element</code></p>"},{"location":"reference/#overrides_3","title":"Overrides","text":"<p><code>React.Component.render</code></p>"},{"location":"reference/#defined-in_7","title":"Defined in","text":"<p>lib/index.tsx:272</p>"},{"location":"reference/#variables","title":"Variables","text":""},{"location":"reference/#before_fetch","title":"BEFORE_FETCH","text":"<p><code>const</code> BEFORE_FETCH: <code>\"@@superglue/BEFORE_FETCH\"</code> = <code>'@@superglue/BEFORE_FETCH'</code></p>"},{"location":"reference/#defined-in_8","title":"Defined in","text":"<p>lib/actions.ts:1</p> <p></p>"},{"location":"reference/#before_visit","title":"BEFORE_VISIT","text":"<p><code>const</code> BEFORE_VISIT: <code>\"@@superglue/BEFORE_VISIT\"</code> = <code>'@@superglue/BEFORE_VISIT'</code></p>"},{"location":"reference/#defined-in_9","title":"Defined in","text":"<p>lib/actions.ts:2</p> <p></p>"},{"location":"reference/#before_remote","title":"BEFORE_REMOTE","text":"<p><code>const</code> BEFORE_REMOTE: <code>\"@@superglue/BEFORE_REMOTE\"</code> = <code>'@@superglue/BEFORE_REMOTE'</code></p>"},{"location":"reference/#defined-in_10","title":"Defined in","text":"<p>lib/actions.ts:3</p> <p></p>"},{"location":"reference/#save_response","title":"SAVE_RESPONSE","text":"<p><code>const</code> SAVE_RESPONSE: <code>\"@@superglue/SAVE_RESPONSE\"</code> = <code>'@@superglue/SAVE_RESPONSE'</code></p>"},{"location":"reference/#defined-in_11","title":"Defined in","text":"<p>lib/actions.ts:5</p> <p></p>"},{"location":"reference/#grafting_error","title":"GRAFTING_ERROR","text":"<p><code>const</code> GRAFTING_ERROR: <code>\"@@superglue/GRAFTING_ERROR\"</code> = <code>'@@superglue/GRAFTING_ERROR'</code></p>"},{"location":"reference/#defined-in_12","title":"Defined in","text":"<p>lib/actions.ts:9</p> <p></p>"},{"location":"reference/#grafting_success","title":"GRAFTING_SUCCESS","text":"<p><code>const</code> GRAFTING_SUCCESS: <code>\"@@superglue/GRAFTING_SUCCESS\"</code> = <code>'@@superglue/GRAFTING_SUCCESS'</code></p>"},{"location":"reference/#defined-in_13","title":"Defined in","text":"<p>lib/actions.ts:10</p> <p></p>"},{"location":"reference/#history_change","title":"HISTORY_CHANGE","text":"<p><code>const</code> HISTORY_CHANGE: <code>\"@@superglue/HISTORY_CHANGE\"</code> = <code>'@@superglue/HISTORY_CHANGE'</code></p>"},{"location":"reference/#defined-in_14","title":"Defined in","text":"<p>lib/actions.ts:12</p> <p></p>"},{"location":"reference/#remove_page","title":"REMOVE_PAGE","text":"<p><code>const</code> REMOVE_PAGE: <code>\"@@superglue/REMOVE_PAGE\"</code> = <code>'@@superglue/REMOVE_PAGE'</code></p>"},{"location":"reference/#defined-in_15","title":"Defined in","text":"<p>lib/actions.ts:14</p> <p></p>"},{"location":"reference/#copy_page","title":"COPY_PAGE","text":"<p><code>const</code> COPY_PAGE: <code>\"@@superglue/COPY_PAGE\"</code> = <code>'@@superglue/COPY_PAGE'</code></p>"},{"location":"reference/#defined-in_16","title":"Defined in","text":"<p>lib/actions.ts:15</p> <p></p>"},{"location":"reference/#update_fragments","title":"UPDATE_FRAGMENTS","text":"<p><code>const</code> UPDATE_FRAGMENTS: <code>\"@@superglue/UPDATE_FRAGMENTS\"</code> = <code>'@@superglue/UPDATE_FRAGMENTS'</code></p>"},{"location":"reference/#defined-in_17","title":"Defined in","text":"<p>lib/actions.ts:16</p>"},{"location":"reference/#functions","title":"Functions","text":""},{"location":"reference/#fragmentmiddleware","title":"fragmentMiddleware()","text":"<p>fragmentMiddleware(<code>api</code>: <code>MiddlewareAPI</code>\\&lt;<code>Dispatch</code>, <code>RootState</code>&gt;): (<code>next</code>: (<code>action</code>: <code>unknown</code>) =&gt; <code>unknown</code>) =&gt; (<code>action</code>: <code>unknown</code>) =&gt; <code>unknown</code></p> <p><code>Experimental</code></p> <p>A middleware that will update all Fragment across the AllPages slice, if a fragment on any page was mutated.</p>"},{"location":"reference/#parameters_3","title":"Parameters","text":"Parameter Type <code>api</code> <code>MiddlewareAPI</code>\\&lt;<code>Dispatch</code>, <code>RootState</code>&gt;"},{"location":"reference/#returns_8","title":"Returns","text":"<p><code>Function</code></p>"},{"location":"reference/#parameters_4","title":"Parameters","text":"Parameter Type <code>next</code> (<code>action</code>: <code>unknown</code>) =&gt; <code>unknown</code>"},{"location":"reference/#returns_9","title":"Returns","text":"<p><code>Function</code></p>"},{"location":"reference/#parameters_5","title":"Parameters","text":"Parameter Type <code>action</code> <code>unknown</code>"},{"location":"reference/#returns_10","title":"Returns","text":"<p><code>unknown</code></p>"},{"location":"reference/#defined-in_18","title":"Defined in","text":"<p>lib/middleware.ts:15</p> <p></p>"},{"location":"reference/#getin","title":"getIn()","text":"<p>getIn(<code>node</code>: <code>JSONMappable</code>, <code>path</code>: <code>string</code>): <code>JSONValue</code></p> <p>Retrieves data from a JSON object using a Keypath</p>"},{"location":"reference/#parameters_6","title":"Parameters","text":"Parameter Type Description <code>node</code> <code>JSONMappable</code> <code>path</code> <code>string</code>"},{"location":"reference/#returns_11","title":"Returns","text":"<p><code>JSONValue</code></p>"},{"location":"reference/#defined-in_19","title":"Defined in","text":"<p>lib/utils/immutability.ts:22</p> <p></p>"},{"location":"reference/#urltopagekey","title":"urlToPageKey()","text":"<p>urlToPageKey(<code>url</code>: <code>string</code>): <code>PageKey</code></p> <p>Converts a url to a PageKey.</p>"},{"location":"reference/#parameters_7","title":"Parameters","text":"Parameter Type Description <code>url</code> <code>string</code>"},{"location":"reference/#returns_12","title":"Returns","text":"<p><code>PageKey</code></p>"},{"location":"reference/#defined-in_20","title":"Defined in","text":"<p>lib/utils/url.ts:57</p>"},{"location":"reference/components.Nav/","title":"Nav","text":""},{"location":"reference/components.Nav/#classes","title":"Classes","text":""},{"location":"reference/components.Nav/#default","title":"default","text":"<p>A Nav component for browsers. It handles changine the browser history, deciding which page component to render based on a passed mapping, and passes a <code>navigateTo</code> to all page components.</p>"},{"location":"reference/components.Nav/#extends","title":"Extends","text":"<ul> <li><code>Component</code>\\&lt;<code>Props</code>, <code>State</code>&gt;</li> </ul>"},{"location":"reference/components.Nav/#methods","title":"Methods","text":""},{"location":"reference/components.Nav/#navigateto","title":"navigateTo()","text":"<p>navigateTo(<code>path</code>: <code>string</code>, <code>options</code>: {<code>action</code>: <code>SuggestedAction</code>;<code>ownProps</code>: <code>Record</code>\\&lt;<code>string</code>, <code>unknown</code>&gt;; }): <code>boolean</code></p> <p>Passed to every page component. Manually navigate using pages that exists in the store and restores scroll position. This is what Visit in your <code>application_visit.js</code> ultimately calls.</p> <p>If there is an existing page in your store <code>navigateTo</code> will restore the props, render the correct component, and return <code>true</code>. Otherwise, it will return <code>false</code>. This is useful if you want to restore an existing page before making a call to <code>visit</code> or <code>remote</code>.</p>"},{"location":"reference/components.Nav/#parameters","title":"Parameters","text":"Parameter Type Description <code>path</code> <code>string</code> <code>options</code> <code>object</code> when <code>none</code>, immediately returns <code>false</code> <code>options.action</code> <code>SuggestedAction</code> - <code>options.ownProps</code> <code>Record</code>\\&lt;<code>string</code>, <code>unknown</code>&gt; -"},{"location":"reference/components.Nav/#returns","title":"Returns","text":"<p><code>boolean</code></p> <p><code>true</code> if the navigation was a success, <code>false</code> if the page was not found in the store.</p>"},{"location":"reference/components.Nav/#defined-in","title":"Defined in","text":"<p>lib/components/Nav.tsx:85</p>"},{"location":"reference/types/","title":"Types","text":""},{"location":"reference/types/#references","title":"References","text":""},{"location":"reference/types/#visit","title":"Visit","text":"<p>Re-exports Visit</p> <p></p>"},{"location":"reference/types/#visitprops","title":"VisitProps","text":"<p>Re-exports VisitProps</p> <p></p>"},{"location":"reference/types/#remote","title":"Remote","text":"<p>Re-exports Remote</p> <p></p>"},{"location":"reference/types/#remoteprops","title":"RemoteProps","text":"<p>Re-exports RemoteProps</p> <p></p>"},{"location":"reference/types/#beforesave","title":"BeforeSave","text":"<p>Re-exports BeforeSave</p>"},{"location":"reference/types/#interfaces","title":"Interfaces","text":""},{"location":"reference/types/#saveresponseaction","title":"SaveResponseAction","text":""},{"location":"reference/types/#extends","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/SAVE_RESPONSE\"</code> <code>Action.type</code> lib/types/actions.ts:6 <code>payload</code> {<code>pageKey</code>: <code>string</code>;<code>page</code>: <code>VisitResponse</code>; } - lib/types/actions.ts:7 <code>payload.pageKey</code> <code>string</code> - lib/types/actions.ts:8 <code>payload.page</code> <code>VisitResponse</code> - lib/types/actions.ts:9"},{"location":"reference/types/#handlegraftaction","title":"HandleGraftAction","text":""},{"location":"reference/types/#extends_1","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_1","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/HANDLE_GRAFT\"</code> <code>Action.type</code> lib/types/actions.ts:14 <code>payload</code> {<code>pageKey</code>: <code>string</code>;<code>page</code>: <code>GraftResponse</code>; } - lib/types/actions.ts:15 <code>payload.pageKey</code> <code>string</code> - lib/types/actions.ts:16 <code>payload.page</code> <code>GraftResponse</code> - lib/types/actions.ts:17"},{"location":"reference/types/#copyaction","title":"CopyAction","text":""},{"location":"reference/types/#extends_2","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_2","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/COPY_PAGE\"</code> <code>Action.type</code> lib/types/actions.ts:22 <code>payload</code> {<code>from</code>: <code>string</code>;<code>to</code>: <code>string</code>; } - lib/types/actions.ts:23 <code>payload.from</code> <code>string</code> - lib/types/actions.ts:24 <code>payload.to</code> <code>string</code> - lib/types/actions.ts:25"},{"location":"reference/types/#removepageaction","title":"RemovePageAction","text":""},{"location":"reference/types/#extends_3","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_3","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/REMOVE_PAGE\"</code> <code>Action.type</code> lib/types/actions.ts:30 <code>payload</code> {<code>pageKey</code>: <code>string</code>; } - lib/types/actions.ts:31 <code>payload.pageKey</code> <code>string</code> - lib/types/actions.ts:32"},{"location":"reference/types/#updatefragmentsaction","title":"UpdateFragmentsAction","text":""},{"location":"reference/types/#extends_4","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_4","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/UPDATE_FRAGMENTS\"</code> <code>Action.type</code> lib/types/actions.ts:37 <code>payload</code> {<code>changedFragments</code>: <code>Record</code>\\&lt;<code>string</code>, <code>unknown</code>&gt;; } - lib/types/actions.ts:38 <code>payload.changedFragments</code> <code>Record</code>\\&lt;<code>string</code>, <code>unknown</code>&gt; - lib/types/actions.ts:39"},{"location":"reference/types/#setcsrftoken","title":"SetCSRFToken","text":""},{"location":"reference/types/#extends_5","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_5","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/SET_CSRF_TOKEN\"</code> <code>Action.type</code> lib/types/actions.ts:44 <code>payload</code> {<code>csrfToken</code>: <code>string</code>; } - lib/types/actions.ts:45 <code>payload.csrfToken</code> <code>string</code> - lib/types/actions.ts:46"},{"location":"reference/types/#historychange","title":"HistoryChange","text":""},{"location":"reference/types/#extends_6","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_6","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/HISTORY_CHANGE\"</code> <code>Action.type</code> lib/types/actions.ts:51 <code>payload</code> {<code>pathname</code>: <code>string</code>;<code>search</code>: <code>string</code>;<code>hash</code>: <code>string</code>; } - lib/types/actions.ts:52 <code>payload.pathname</code> <code>string</code> - lib/types/actions.ts:53 <code>payload.search</code> <code>string</code> - lib/types/actions.ts:54 <code>payload.hash</code> <code>string</code> - lib/types/actions.ts:55"},{"location":"reference/types/#beforevisit","title":"BeforeVisit","text":""},{"location":"reference/types/#extends_7","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_7","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/BEFORE_VISIT\"</code> <code>Action.type</code> lib/types/actions.ts:65 <code>payload</code> {<code>fetchArgs</code>: [<code>string</code>, <code>BasicRequestInit</code>];<code>currentPageKey</code>: <code>string</code>; } - lib/types/actions.ts:66 <code>payload.fetchArgs</code> [<code>string</code>, <code>BasicRequestInit</code>] - lib/types/actions.ts:67 <code>payload.currentPageKey</code> <code>string</code> - lib/types/actions.ts:68"},{"location":"reference/types/#beforeremote","title":"BeforeRemote","text":""},{"location":"reference/types/#extends_8","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_8","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/BEFORE_REMOTE\"</code> <code>Action.type</code> lib/types/actions.ts:73 <code>payload</code> {<code>fetchArgs</code>: [<code>string</code>, <code>BasicRequestInit</code>];<code>currentPageKey</code>: <code>string</code>; } - lib/types/actions.ts:74 <code>payload.fetchArgs</code> [<code>string</code>, <code>BasicRequestInit</code>] - lib/types/actions.ts:75 <code>payload.currentPageKey</code> <code>string</code> - lib/types/actions.ts:76"},{"location":"reference/types/#beforefetch","title":"BeforeFetch","text":""},{"location":"reference/types/#extends_9","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_9","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/BEFORE_FETCH\"</code> <code>Action.type</code> lib/types/actions.ts:81 <code>payload</code> {<code>fetchArgs</code>: [<code>string</code>, <code>BasicRequestInit</code>]; } - lib/types/actions.ts:82 <code>payload.fetchArgs</code> [<code>string</code>, <code>BasicRequestInit</code>] - lib/types/actions.ts:83"},{"location":"reference/types/#handleerror","title":"HandleError","text":""},{"location":"reference/types/#extends_10","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_10","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>\"@@superglue/ERROR\"</code> <code>Action.type</code> lib/types/actions.ts:88 <code>payload</code> {<code>message</code>: <code>string</code>; } - lib/types/actions.ts:89 <code>payload.message</code> <code>string</code> - lib/types/actions.ts:90"},{"location":"reference/types/#graftingsuccessaction","title":"GraftingSuccessAction","text":""},{"location":"reference/types/#extends_11","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_11","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>string</code> <code>Action.type</code> lib/types/actions.ts:97 <code>payload</code> {<code>pageKey</code>: <code>string</code>;<code>keyPath</code>: <code>string</code>; } - lib/types/actions.ts:98 <code>payload.pageKey</code> <code>string</code> - lib/types/actions.ts:99 <code>payload.keyPath</code> <code>string</code> - lib/types/actions.ts:100"},{"location":"reference/types/#graftingerroraction","title":"GraftingErrorAction","text":""},{"location":"reference/types/#extends_12","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types/#properties_12","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>string</code> <code>Action.type</code> lib/types/actions.ts:105 <code>payload</code> {<code>pageKey</code>: <code>string</code>;<code>url</code>: <code>string</code>;<code>err</code>: <code>unknown</code>;<code>keyPath</code>: <code>string</code>; } - lib/types/actions.ts:106 <code>payload.pageKey</code> <code>string</code> - lib/types/actions.ts:107 <code>payload.url</code> <code>string</code> - lib/types/actions.ts:108 <code>payload.err</code> <code>unknown</code> - lib/types/actions.ts:109 <code>payload.keyPath</code> <code>string</code> - lib/types/actions.ts:110"},{"location":"reference/types/#parsedresponse","title":"ParsedResponse","text":""},{"location":"reference/types/#properties_13","title":"Properties","text":"Property Type Defined in <code>rsp</code> <code>Response</code> lib/types/index.ts:106 <code>json</code> <code>PageResponse</code> lib/types/index.ts:107"},{"location":"reference/types/#defer","title":"Defer","text":"<p>Defer is a node in the page response thats been intentionally filled with empty or placeholder data for the purposes of fetching it later.</p> <p>You would typically use it with props_template for parts of a page that you know would be slower to load.</p>"},{"location":"reference/types/#properties_14","title":"Properties","text":"Property Type Description Defined in <code>url</code> <code>string</code> A url with props_at keypath in the query parameter to indicate how to dig for the data, and where to place the data. lib/types/index.ts:132 <code>type</code> <code>\"auto\"</code> | <code>\"manual\"</code> When set to <code>auto</code> Superglue will automatically make the request using the <code>url</code>. When set to <code>manual</code>, Superglue does nothing, and you would need to manually use <code>remote</code> with the <code>url</code> to fetch the missing data. lib/types/index.ts:133 <code>path</code> <code>string</code> A keypath indicates how to dig for the data and where to place the data. lib/types/index.ts:134 <code>successAction</code> <code>string</code> a user defined action for Superglue to dispatch when auto deferement is successful lib/types/index.ts:135 <code>failAction</code> <code>string</code> a user defined action for Superglue to dispatch when auto deferement failed lib/types/index.ts:136"},{"location":"reference/types/#graftresponse","title":"GraftResponse","text":"<p>The GraftResponse is a protocol, a shape that is responsible for partial updates using props_template's digging functionality in Superglue. Its meant to be implemented by the server and if you are using superglue_rails, the generators would have generated a props_template layout and view that would shape the graft responses for you.</p>"},{"location":"reference/types/#properties_15","title":"Properties","text":"Property Type Description Defined in <code>data</code> <code>JSONMappable</code> - lib/types/index.ts:146 <code>componentIdentifier</code> <code>string</code> - lib/types/index.ts:147 <code>assets</code> <code>string</code>[] - lib/types/index.ts:148 <code>csrfToken?</code> <code>string</code> - lib/types/index.ts:149 <code>fragments</code> <code>Fragment</code>[] - lib/types/index.ts:150 <code>defers</code> <code>Defer</code>[] - lib/types/index.ts:151 <code>slices</code> <code>JSONObject</code> - lib/types/index.ts:152 <code>renderedAt</code> <code>number</code> - lib/types/index.ts:154 <code>restoreStrategy</code> <code>RestoreStrategy</code> - lib/types/index.ts:155 <code>action</code> <code>\"graft\"</code> - lib/types/index.ts:178 <code>path</code> <code>string</code> Used by superglue to replace the data at that location. lib/types/index.ts:179"},{"location":"reference/types/#fragment","title":"Fragment","text":"<p>A Fragment identifies a cross cutting concern, like a shared header or footer.</p>"},{"location":"reference/types/#properties_16","title":"Properties","text":"Property Type Description Defined in <code>type</code> <code>string</code> A user supplied string identifying a fragment. This is usually created using props_template lib/types/index.ts:197 <code>path</code> <code>string</code> A Keypath specifying the location of the fragment lib/types/index.ts:198"},{"location":"reference/types/#supergluestate","title":"SuperglueState","text":"<p>A read only state that contains meta information about the current page.</p>"},{"location":"reference/types/#properties_17","title":"Properties","text":"Property Type Description Defined in <code>currentPageKey</code> <code>string</code> The PageKey of the current page. This can be pass to Remote. lib/types/index.ts:213 <code>pathname</code> <code>string</code> The pathname of the current url. lib/types/index.ts:215 <code>search</code> <code>string</code> The query string of the current url. lib/types/index.ts:217 <code>hash</code> <code>string</code> The hash of the current url. lib/types/index.ts:219 <code>csrfToken</code> <code>string</code> The Rails csrfToken that you can use for forms. lib/types/index.ts:221 <code>assets</code> <code>string</code>[] The tracked asset digests. lib/types/index.ts:223"},{"location":"reference/types/#rootstate","title":"RootState","text":"<p>The root state for a Superglue application. It occupies 2 keys in your app.</p>"},{"location":"reference/types/#properties_18","title":"Properties","text":"Property Type Description Defined in <code>superglue</code> <code>SuperglueState</code> Caontain readonly metadata about the current page lib/types/index.ts:232 <code>pages</code> <code>AllPages</code> Every PageResponse that superglue recieves is stored here. lib/types/index.ts:234"},{"location":"reference/types/#pageownprops","title":"PageOwnProps","text":"<p>Helpful props passed to the page component.</p>"},{"location":"reference/types/#properties_19","title":"Properties","text":"Property Type Description Defined in <code>pageKey</code> <code>string</code> the pagekey of the current page lib/types/index.ts:242 <code>navigateTo</code> (<code>path</code>: <code>string</code>, <code>options</code>: {<code>action</code>: <code>SuggestedAction</code>;<code>ownProps</code>: <code>Record</code>\\&lt;<code>string</code>, <code>unknown</code>&gt;; }) =&gt; <code>boolean</code> - lib/types/index.ts:243 <code>visit</code> <code>Visit</code> - lib/types/index.ts:244 <code>remote</code> <code>Remote</code> - lib/types/index.ts:245"},{"location":"reference/types/#meta","title":"Meta","text":"<p>Meta is passed to the Promise when visit or remote resolves and contains additional information for navigation.</p>"},{"location":"reference/types/#properties_20","title":"Properties","text":"Property Type Description Defined in <code>pageKey</code> <code>string</code> The URL of the response converted to a pageKey. Superglue uses this to persist the VisitResponse to store, when that happens. lib/types/index.ts:269 <code>page</code> <code>VisitResponse</code> The VisitResponse of the page lib/types/index.ts:271 <code>redirected</code> <code>boolean</code> Indicates if response was redirected lib/types/index.ts:273 <code>rsp</code> <code>Response</code> The original response object lib/types/index.ts:275 <code>fetchArgs</code> <code>FetchArgs</code> The original args passed to fetch. lib/types/index.ts:277 <code>componentIdentifier</code> <code>string</code> The ComponentIdentifier extracted from the response. lib/types/index.ts:279 <code>needsRefresh</code> <code>boolean</code> <code>true</code> when assets locally are detected to be out of date lib/types/index.ts:281 <code>suggestedAction?</code> <code>SuggestedAction</code> The SuggestedAction. This can be used for navigation. lib/types/index.ts:283"},{"location":"reference/types/#handlers","title":"Handlers","text":""},{"location":"reference/types/#properties_21","title":"Properties","text":"Property Type Defined in <code>onClick</code> (<code>event</code>: <code>MouseEvent</code>) =&gt; <code>void</code> lib/types/index.ts:327 <code>onSubmit</code> (<code>event</code>: <code>Event</code>) =&gt; <code>void</code> lib/types/index.ts:328"},{"location":"reference/types/#historystate","title":"HistoryState","text":"<p>The state that is saved to history.state. Superglue stores information about the current page so that it can restore the page state when navigating back</p>"},{"location":"reference/types/#properties_22","title":"Properties","text":"Property Type Description Defined in <code>superglue</code> <code>true</code> Is always <code>true</code> so superglue can differentiate pages that have superglue enabled or not lib/types/index.ts:348 <code>pageKey</code> <code>string</code> The page key in SuperglueState to restore from lib/types/index.ts:350 <code>posX</code> <code>number</code> The scroll position X of the page lib/types/index.ts:352 <code>posY</code> <code>number</code> The scroll position Y of the page lib/types/index.ts:354"},{"location":"reference/types/#basicrequestinit","title":"BasicRequestInit","text":"<p>A variation of RequestInit except the headers must be a regular object</p>"},{"location":"reference/types/#extends_13","title":"Extends","text":"<ul> <li><code>RequestInit</code></li> </ul>"},{"location":"reference/types/#properties_23","title":"Properties","text":"Property Type Description Overrides Defined in <code>headers?</code> {} A Headers object, an object literal, or an array of two-item arrays to set request's headers. <code>RequestInit.headers</code> lib/types/index.ts:380"},{"location":"reference/types/#type-aliases","title":"Type Aliases","text":""},{"location":"reference/types/#fetchargs","title":"FetchArgs","text":"<p>FetchArgs: [<code>string</code>, <code>BasicRequestInit</code>]</p> <p>Tuple of Fetch arguments that Superglue passes to Fetch.</p>"},{"location":"reference/types/#defined-in","title":"Defined in","text":"<p>lib/types/actions.ts:62</p> <p></p>"},{"location":"reference/types/#lifecycleaction","title":"LifecycleAction","text":"<p>LifecycleAction: <code>BeforeFetch</code> | <code>HandleError</code> | <code>BeforeVisit</code> | <code>BeforeRemote</code></p>"},{"location":"reference/types/#defined-in_1","title":"Defined in","text":"<p>lib/types/actions.ts:114</p> <p></p>"},{"location":"reference/types/#pagereduceraction","title":"PageReducerAction","text":"<p>PageReducerAction: <code>SaveResponseAction</code> | <code>HandleGraftAction</code> | <code>GraftingSuccessAction</code> | <code>GraftingErrorAction</code> | <code>CopyAction</code> | <code>RemovePageAction</code> | <code>UpdateFragmentsAction</code></p>"},{"location":"reference/types/#defined-in_2","title":"Defined in","text":"<p>lib/types/actions.ts:120</p> <p></p>"},{"location":"reference/types/#supergluereduceraction","title":"SuperglueReducerAction","text":"<p>SuperglueReducerAction: <code>SaveResponseAction</code> | <code>SetCSRFToken</code> | <code>HistoryChange</code></p>"},{"location":"reference/types/#defined-in_3","title":"Defined in","text":"<p>lib/types/actions.ts:129</p> <p></p>"},{"location":"reference/types/#allaction","title":"AllAction","text":"<p>AllAction: <code>PageReducerAction</code> | <code>GraftingSuccessAction</code> | <code>GraftingErrorAction</code> | <code>SuperglueReducerAction</code> | <code>LifecycleAction</code></p>"},{"location":"reference/types/#defined-in_4","title":"Defined in","text":"<p>lib/types/actions.ts:134</p> <p></p>"},{"location":"reference/types/#pagekey","title":"PageKey","text":"<p>PageKey: <code>string</code></p> <p>A PageKey is a combination of a parsed URL's pathname + query string. No hash.</p> <p>*</p>"},{"location":"reference/types/#example","title":"Example","text":"<pre><code>/posts?foobar=123\n</code></pre>"},{"location":"reference/types/#defined-in_5","title":"Defined in","text":"<p>lib/types/index.ts:19</p> <p></p>"},{"location":"reference/types/#restorestrategy","title":"RestoreStrategy","text":"<p>RestoreStrategy: <code>\"fromCacheOnly\"</code> | <code>\"revisitOnly\"</code> | <code>\"fromCacheAndRevisitInBackground\"</code></p> <p>Defines the behavior when navigating to a page that is already stored on the client. For example, when navigating back.</p> <p>When the page already exists in the store: - <code>fromCacheOnly</code> - Use the cached page that exists on the store, only. - <code>revisitOnly</code> - Ignore the cache and make a request for the latest page. - <code>fromCacheAndRevisitInBackground</code> - Use the cache version of the page so    superglue can optimistically navigate to it, then make an additional request    for the latest version.</p>"},{"location":"reference/types/#defined-in_6","title":"Defined in","text":"<p>lib/types/index.ts:32</p> <p></p>"},{"location":"reference/types/#suggestedaction","title":"SuggestedAction","text":"<p>SuggestedAction: <code>\"push\"</code> | <code>\"replace\"</code> | <code>\"none\"</code></p> <p>A SuggestedAction is used to tell Superglue to history.push, history.replace or do nothing.</p>"},{"location":"reference/types/#defined-in_7","title":"Defined in","text":"<p>lib/types/index.ts:41</p> <p></p>"},{"location":"reference/types/#navigationaction","title":"NavigationAction","text":"<p>NavigationAction: <code>SuggestedAction</code></p>"},{"location":"reference/types/#defined-in_8","title":"Defined in","text":"<p>lib/types/index.ts:42</p> <p></p>"},{"location":"reference/types/#componentidentifier","title":"ComponentIdentifier","text":"<p>ComponentIdentifier: <code>string</code></p> <p>An identifier that Superglue will uses to determine which page component to render with your page response.</p>"},{"location":"reference/types/#defined-in_9","title":"Defined in","text":"<p>lib/types/index.ts:48</p> <p></p>"},{"location":"reference/types/#keypath","title":"Keypath","text":"<p>Keypath: <code>string</code></p> <p>A keypath is a string representing the location of a piece of data. Superglue uses the keypath to dig for or update data.</p>"},{"location":"reference/types/#examples","title":"Examples","text":"<p>Object access <pre><code>data.header.avatar\n</code></pre></p> <p>Array access <pre><code>data.body.posts.0.title\n</code></pre></p> <p>Array with lookahead <pre><code>data.body.posts.post_id=foobar.title\n</code></pre></p>"},{"location":"reference/types/#defined-in_10","title":"Defined in","text":"<p>lib/types/index.ts:72</p> <p></p>"},{"location":"reference/types/#jsonprimitive","title":"JSONPrimitive","text":"<p>JSONPrimitive: <code>string</code> | <code>number</code> | <code>boolean</code> | <code>null</code> | <code>undefined</code></p> <p>A JSON Primitive value</p>"},{"location":"reference/types/#defined-in_11","title":"Defined in","text":"<p>lib/types/index.ts:79</p> <p></p>"},{"location":"reference/types/#jsonobject","title":"JSONObject","text":"<p>JSONObject: {}</p> <p>A JSON Object</p>"},{"location":"reference/types/#index-signature","title":"Index Signature","text":"<p>[<code>key</code>: <code>string</code>]: <code>JSONValue</code></p>"},{"location":"reference/types/#defined-in_12","title":"Defined in","text":"<p>lib/types/index.ts:84</p> <p></p>"},{"location":"reference/types/#jsonmappable","title":"JSONMappable","text":"<p>JSONMappable: <code>JSONValue</code>[] | <code>JSONObject</code></p> <p>A JSON Object or an array of values</p>"},{"location":"reference/types/#defined-in_13","title":"Defined in","text":"<p>lib/types/index.ts:91</p> <p></p>"},{"location":"reference/types/#jsonkeyable","title":"JSONKeyable","text":"<p>JSONKeyable: <code>JSONObject</code>[] | <code>JSONObject</code></p> <p>A array of JSON key value objects or a JSON Object</p>"},{"location":"reference/types/#defined-in_14","title":"Defined in","text":"<p>lib/types/index.ts:96</p> <p></p>"},{"location":"reference/types/#jsonvalue","title":"JSONValue","text":"<p>JSONValue: <code>JSONPrimitive</code> | <code>JSONMappable</code></p> <p>A primitive or a mappable object</p>"},{"location":"reference/types/#defined-in_15","title":"Defined in","text":"<p>lib/types/index.ts:101</p> <p></p>"},{"location":"reference/types/#visitresponse","title":"VisitResponse","text":"<p>VisitResponse: {<code>data</code>: <code>JSONMappable</code>;<code>componentIdentifier</code>: <code>ComponentIdentifier</code>;<code>assets</code>: <code>string</code>[];<code>csrfToken</code>: <code>string</code>;<code>fragments</code>: <code>Fragment</code>[];<code>defers</code>: <code>Defer</code>[];<code>slices</code>: <code>JSONObject</code>;<code>renderedAt</code>: <code>number</code>;<code>restoreStrategy</code>: <code>RestoreStrategy</code>; }</p> <p>The VisitResponse is a protocol, a shape that is responsible for full page visits in Superglue. Its meant to be implemented by the server and if you are using superglue_rails, the generators would have generated a props_template layout and view that would shape the visit responses for you.</p>"},{"location":"reference/types/#type-declaration","title":"Type declaration","text":"Name Type Defined in <code>data</code> <code>JSONMappable</code> lib/types/index.ts:146 <code>componentIdentifier</code> <code>ComponentIdentifier</code> lib/types/index.ts:147 <code>assets</code> <code>string</code>[] lib/types/index.ts:148 <code>csrfToken</code>? <code>string</code> lib/types/index.ts:149 <code>fragments</code> <code>Fragment</code>[] lib/types/index.ts:150 <code>defers</code> <code>Defer</code>[] lib/types/index.ts:151 <code>slices</code> <code>JSONObject</code> lib/types/index.ts:152 <code>renderedAt</code> <code>number</code> lib/types/index.ts:154 <code>restoreStrategy</code> <code>RestoreStrategy</code> lib/types/index.ts:155"},{"location":"reference/types/#defined-in_16","title":"Defined in","text":"<p>lib/types/index.ts:145</p> <p></p>"},{"location":"reference/types/#page","title":"Page","text":"<p>Page: <code>VisitResponse</code> &amp; {<code>savedAt</code>: <code>number</code>;<code>pageKey</code>: <code>PageKey</code>; }</p> <p>A Page is a VisitResponse that's been saved to the store</p>"},{"location":"reference/types/#type-declaration_1","title":"Type declaration","text":"Name Type Defined in <code>savedAt</code> <code>number</code> lib/types/index.ts:162 <code>pageKey</code> <code>PageKey</code> lib/types/index.ts:163"},{"location":"reference/types/#defined-in_17","title":"Defined in","text":"<p>lib/types/index.ts:161</p> <p></p>"},{"location":"reference/types/#pageresponse","title":"PageResponse","text":"<p>PageResponse: <code>GraftResponse</code> | <code>VisitResponse</code></p> <p>A PageResponse can be either a GraftResponse or a VisitResponse. Its meant to be implemented by the server and if you are using superglue_rails, the generators will handle both cases.</p>"},{"location":"reference/types/#defined-in_18","title":"Defined in","text":"<p>lib/types/index.ts:187</p> <p></p>"},{"location":"reference/types/#allpages","title":"AllPages","text":"<p>AllPages: <code>Record</code>\\&lt;<code>PageKey</code>, <code>Page</code>&gt;</p> <p>The store where all page responses are stored indexed by PageKey. You are encouraged to mutate the Pages in this store.</p>"},{"location":"reference/types/#defined-in_19","title":"Defined in","text":"<p>lib/types/index.ts:205</p> <p></p>"},{"location":"reference/types/#content","title":"Content","text":"<p>Content: <code>PageOwnProps</code> &amp; {<code>[key: string]</code>: <code>unknown</code>; <code>pageKey</code>: <code>PageKey</code>;<code>fragments</code>: <code>Fragment</code>[];<code>csrfToken</code>: <code>string</code>; }</p> <p>Your Page's content in the data node in VisitResponse merged with additional helpers</p>"},{"location":"reference/types/#type-declaration_2","title":"Type declaration","text":"Name Type Defined in <code>pageKey</code> <code>PageKey</code> lib/types/index.ts:253 <code>fragments</code> <code>Fragment</code>[] lib/types/index.ts:254 <code>csrfToken</code>? <code>string</code> lib/types/index.ts:255"},{"location":"reference/types/#defined-in_20","title":"Defined in","text":"<p>lib/types/index.ts:252</p> <p></p>"},{"location":"reference/types/#visitcreator","title":"VisitCreator()","text":"<p>VisitCreator: (<code>input</code>: <code>string</code> | <code>PageKey</code>, <code>options</code>: <code>VisitProps</code>) =&gt; <code>MetaThunk</code></p> <p>VisitCreator is a Redux action creator that returns a thunk. Use this to build the Visit function. Typically its already generated in <code>application_visit.js</code></p>"},{"location":"reference/types/#parameters","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> | <code>PageKey</code> <code>options</code> <code>VisitProps</code>"},{"location":"reference/types/#returns","title":"Returns","text":"<p><code>MetaThunk</code></p>"},{"location":"reference/types/#defined-in_21","title":"Defined in","text":"<p>lib/types/index.ts:292</p> <p></p>"},{"location":"reference/types/#remotecreator","title":"RemoteCreator()","text":"<p>RemoteCreator: (<code>input</code>: <code>string</code> | <code>PageKey</code>, <code>options</code>: <code>RemoteProps</code>) =&gt; <code>MetaThunk</code></p> <p>RemoteCreator is a Redux action creator that returns a thunk. Use this to build the Remote function. Typically its already generated in <code>application_visit.js</code></p>"},{"location":"reference/types/#parameters_1","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> | <code>PageKey</code> <code>options</code> <code>RemoteProps</code>"},{"location":"reference/types/#returns_1","title":"Returns","text":"<p><code>MetaThunk</code></p>"},{"location":"reference/types/#defined-in_22","title":"Defined in","text":"<p>lib/types/index.ts:301</p> <p></p>"},{"location":"reference/types/#dispatch","title":"Dispatch","text":"<p>Dispatch: <code>ThunkDispatch</code>\\&lt;<code>RootState</code>, <code>undefined</code>, <code>AllAction</code>&gt;</p>"},{"location":"reference/types/#defined-in_23","title":"Defined in","text":"<p>lib/types/index.ts:306</p> <p></p>"},{"location":"reference/types/#supergluestore","title":"SuperglueStore","text":"<p>SuperglueStore: <code>EnhancedStore</code>\\&lt;<code>RootState</code>, <code>AllAction</code> | <code>UnknownAction</code>, <code>Tuple</code>\\&lt;[<code>StoreEnhancer</code>\\&lt;{<code>dispatch</code>: <code>Dispatch</code>; }&gt;, <code>StoreEnhancer</code>]&gt;&gt;</p> <p>A Store created with Redux Toolkit's <code>configureStore</code> setup with reducers from Superglue. If you are using superglue_rails this would have been generated for you in <code>store.js</code> and setup correctly in application.js</p>"},{"location":"reference/types/#defined-in_24","title":"Defined in","text":"<p>lib/types/index.ts:313</p> <p></p>"},{"location":"reference/types/#ujshandlers","title":"UJSHandlers()","text":"<p>UJSHandlers: (<code>{   ujsAttributePrefix,   visit,   remote, }</code>: {<code>ujsAttributePrefix</code>: <code>string</code>;<code>visit</code>: <code>Visit</code>;<code>remote</code>: <code>Remote</code>; }) =&gt; <code>Handlers</code></p>"},{"location":"reference/types/#parameters_2","title":"Parameters","text":"Parameter Type <code>{ ujsAttributePrefix, visit, remote, }</code> <code>object</code> <code>{ ujsAttributePrefix, visit, remote, }.ujsAttributePrefix</code> <code>string</code> <code>{ ujsAttributePrefix, visit, remote, }.visit</code> <code>Visit</code> <code>{ ujsAttributePrefix, visit, remote, }.remote</code> <code>Remote</code>"},{"location":"reference/types/#returns_2","title":"Returns","text":"<p><code>Handlers</code></p>"},{"location":"reference/types/#defined-in_25","title":"Defined in","text":"<p>lib/types/index.ts:331</p> <p></p>"},{"location":"reference/types/#saveandprocesspagethunk","title":"SaveAndProcessPageThunk","text":"<p>SaveAndProcessPageThunk: <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>void</code>&gt;, <code>RootState</code>, <code>undefined</code>, <code>AllAction</code>&gt;</p>"},{"location":"reference/types/#defined-in_26","title":"Defined in","text":"<p>lib/types/index.ts:357</p> <p></p>"},{"location":"reference/types/#metathunk","title":"MetaThunk","text":"<p>MetaThunk: <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>Meta</code>&gt;, <code>RootState</code>, <code>undefined</code>, <code>AllAction</code>&gt;</p>"},{"location":"reference/types/#defined-in_27","title":"Defined in","text":"<p>lib/types/index.ts:364</p> <p></p>"},{"location":"reference/types/#defermentthunk","title":"DefermentThunk","text":"<p>DefermentThunk: <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>void</code>[]&gt;, <code>RootState</code>, <code>undefined</code>, <code>AllAction</code>&gt;</p>"},{"location":"reference/types/#defined-in_28","title":"Defined in","text":"<p>lib/types/index.ts:371</p>"},{"location":"reference/types.requests/","title":"Requests","text":""},{"location":"reference/types.requests/#interfaces","title":"Interfaces","text":""},{"location":"reference/types.requests/#visit","title":"Visit()","text":"<p>Visit(<code>input</code>: <code>string</code>, <code>options</code>: <code>VisitProps</code>): <code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p>Use visit to make single page transitions from one page. The function is a wrapper around fetch and made to mimic a link click or a form submision. When used, a <code>json</code> request will be made for the next page, then Superglue saves the response, swap the page component, and change the browser history.</p> <p>Note</p> <p>There can be only one <code>visit</code> at a time. If another <code>visit</code> is called from elsewhere, the previous visit would be aborted.</p> <p>You must provide the implentation and pass it back to Superglue in <code>application.js</code>. Superglue will then pass it to your page components and use it for UJS navigation. This is usually generated for you in <code>application_visit.js</code> where you can customize its behavior globally.</p>"},{"location":"reference/types.requests/#parameters","title":"Parameters","text":"Parameter Type Description <code>input</code> <code>string</code> The first argument to Fetch <code>options</code> <code>VisitProps</code>"},{"location":"reference/types.requests/#returns","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>Meta</code>&gt;</p>"},{"location":"reference/types.requests/#defined-in","title":"Defined in","text":"<p>lib/types/requests.ts:22</p> <p></p>"},{"location":"reference/types.requests/#visitprops","title":"VisitProps","text":"<p>Options for Visit</p>"},{"location":"reference/types.requests/#extends","title":"Extends","text":"<ul> <li><code>BaseProps</code></li> </ul>"},{"location":"reference/types.requests/#properties","title":"Properties","text":"Property Type Description Inherited from Defined in <code>placeholderKey?</code> <code>string</code> When present, Superglue will use the page state located at that pageKey and optimistally navigates to it as the next page's state while the requests resolves. - lib/types/requests.ts:36 <code>revisit?</code> <code>boolean</code> When <code>true</code> and the request method is a GET, changes the <code>suggestionAction</code> of the Meta object to <code>none</code> so that Superglue does nothing to window.history. When the GET response was redirected, changes <code>suggestedAction</code> to <code>replace</code> - lib/types/requests.ts:43 <code>method?</code> <code>string</code> The HTTP method <code>BaseProps.method</code> lib/types/requests.ts:67 <code>body?</code> <code>BodyInit</code> The HTTP body <code>BaseProps.body</code> lib/types/requests.ts:69 <code>headers?</code> {} The HTTP headers <code>BaseProps.headers</code> lib/types/requests.ts:71 <code>beforeSave?</code> <code>BeforeSave</code> - <code>BaseProps.beforeSave</code> lib/types/requests.ts:74"},{"location":"reference/types.requests/#remote","title":"Remote()","text":"<p>Remote(<code>input</code>: <code>string</code>, <code>options</code>: <code>RemoteProps</code>): <code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p>Remote is is wrapper around fetch. Its used to make a request and mutate the store. Remote does not navigate, and it does not change the browser history. There can be multiple Remote requests running concurrently.</p> <p>This function is to be built, customized, and returned to superglue by the developer. This is usually generated as <code>application_visit.js</code> where you can make minimum edits to affect its global usage.</p>"},{"location":"reference/types.requests/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>input</code> <code>string</code> The first argument to Fetch <code>options</code> <code>RemoteProps</code> The fetch RequestInit with additional options"},{"location":"reference/types.requests/#returns_1","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>Meta</code>&gt;</p>"},{"location":"reference/types.requests/#defined-in_1","title":"Defined in","text":"<p>lib/types/requests.ts:59</p> <p></p>"},{"location":"reference/types.requests/#remoteprops","title":"RemoteProps","text":"<p>Options for Visit</p>"},{"location":"reference/types.requests/#extends_1","title":"Extends","text":"<ul> <li><code>BaseProps</code></li> </ul>"},{"location":"reference/types.requests/#properties_1","title":"Properties","text":"Property Type Description Inherited from Defined in <code>method?</code> <code>string</code> The HTTP method <code>BaseProps.method</code> lib/types/requests.ts:67 <code>body?</code> <code>BodyInit</code> The HTTP body <code>BaseProps.body</code> lib/types/requests.ts:69 <code>headers?</code> {} The HTTP headers <code>BaseProps.headers</code> lib/types/requests.ts:71 <code>beforeSave?</code> <code>BeforeSave</code> - <code>BaseProps.beforeSave</code> lib/types/requests.ts:74 <code>pageKey?</code> <code>string</code> Specifies where to store the remote payload, if not provided Remote will use the <code>currentPageKey</code> at SuperglueState - lib/types/requests.ts:85"},{"location":"reference/types.requests/#beforesave","title":"BeforeSave()","text":"<p>BeforeSave(<code>prevPage</code>: <code>VisitResponse</code>, <code>receivedPage</code>: <code>VisitResponse</code>): <code>VisitResponse</code></p> <p>A callback that will be fire in between recieving a payload and saving a payload. Use this callback to modify the payload before it gets saved. Its useful for appending, prepending, shuffeling, etc. recieved data to existing data.</p> <pre><code>const beforeSave = (prevPage, nextPage) =&gt; {\n  nextPage.data.messages = [\n    prevPage.data.messages,\n    ... nextPage.data.messages\n  ]\n\n  return nextPage\n}\n\nremote(\"/posts\", {beforeSave})\n</code></pre>"},{"location":"reference/types.requests/#parameters_2","title":"Parameters","text":"Parameter Type <code>prevPage</code> <code>VisitResponse</code> <code>receivedPage</code> <code>VisitResponse</code>"},{"location":"reference/types.requests/#returns_2","title":"Returns","text":"<p><code>VisitResponse</code></p>"},{"location":"reference/types.requests/#defined-in_2","title":"Defined in","text":"<p>lib/types/requests.ts:108</p>"}]}