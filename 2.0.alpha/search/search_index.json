{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Superglue is The Rails Way of building React applications. Refreshingly familiar. No APIs. No client-side routing. Batteries included.</p> <ul> <li> <p>Super Turbo Streams</p> <p>Turbo Streams ported for Superglue and React. Use <code>broadcast_append_to</code> and more to easily update your UI.</p> </li> <li> <p>Unobtrusive Javascript (UJS)</p> <p>Bringing back a classic to make developing SPA features easy and familiar</p> </li> <li> <p>Fragments</p> <p>Giving Rails partials identity and super powers on the frontend.</p> </li> <li> <p>Deferment</p> <p>Easily defer any part of your page. Great for modals, tabs, and more!</p> </li> <li> <p><code>props_template</code></p> <p>A very fast JSON builder inspired by Jbuilder to shape backend state. The secret sauce that give UJS superpowers.</p> </li> <li> <p><code>form_props</code></p> <p>A <code>form_with</code> FormBuilder that lets you use Rails forms with React.</p> </li> <li> <p><code>candy_wrapper</code></p> <p>Lightweight wrapper components around popular React UI libraries made to work with FormProps.</p> </li> <li> <p><code>humid</code></p> <p>Server Side Rendering using MiniRacer and V8 isolates.</p> </li> </ul>"},{"location":"#who-is-it-for","title":"Who is it for?","text":"<p>Superglue is built from the ground up for Rails developers who want to use the  concepts they already know to: turbo streams, controllers, server-side routing, views, form helpers, and more \u2014 to create seamless, interactive React applications.</p> <p>It's for large teams seeking a way out of JavaScript complexity without losing the investment in React components.</p> <p>Its for nimble teams wanting to move fast with the speed of Rails development  and React's vast ecosystem of prebuilt UI libraries.</p>"},{"location":"#refreshingly-familiar","title":"Refreshingly familiar","text":"<p>Here's how basic functionality looks like:</p> <code>routes</code><code>controller</code><code>views</code> <pre><code>resource :posts\n</code></pre> <p>in <code>app/config/routes.rb</code></p> <pre><code>class PostsController &lt; ApplicationController\n  def show\n    @post = Post.find(params[:id])\n  end\n\n  def update\n    @post = Post.find(params[:id])\n    @post.body = \"Updated\" #no save\n\n    redirect_back fallback_location: root_path\n  end\nend\n</code></pre> <pre><code># views/posts/show.json.props\njson.spotlight do\n  json.body @post.body\nend\n\njson.updateBodyForm do\n  form_props(model: @post) do |f|\n    f.submit\n  end\nend\n</code></pre> <pre><code>// views/posts/show.jsx\nimport React from 'react';\nimport { useContent } from '@thoughtbot/superglue'\nimport Spotlight from '@components/Spotlight'\nimport {Form, SubmitButton} from '@components/forms/vanilla'\n\nexport default function PostsShow() {\n  const {updateBodyForm, spotlight} = useContent()\n  const {form, extras, inputs} = updateBodyForm\n\n  return (\n    &lt;&gt;\n      &lt;Spotlight {...spotlight} /&gt;\n      &lt;Form {...form} extras={extras}&gt;\n        &lt;SubmitButton {...inputs.submit} /&gt;\n      &lt;/Form&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"#respecting-rails-favorites","title":"Respecting Rails favorites","text":"<p>Beyond the basics, Rails is already effective at building world class apps. Instead of ignoring the toolset, Superglue adapts it for React.</p> <p>Navigate like Turbo:</p> <pre><code>&lt;a href=\"/posts\" data-sg-visit&gt;Next page&lt;/a&gt;\n</code></pre> <p>Bring back the power of Unobtrusive JavaScript with surgical updates:</p> <pre><code>&lt;a href=\"/posts/1?props_at=data.postContent\" data-sg-remote&gt; Reload post &lt;/a&gt;\n</code></pre> <p>Build forms The Rails Way with <code>form_props</code>, a fork of <code>form_with</code> with the same API.</p> <pre><code>  form_props(model: @post) do |f|\n    f.submit\n  end\n</code></pre> <p>Respond with Super Turbo Streams</p> <pre><code>class PostsController &lt; ApplicationController\n  def update\n    @post = Post.find(params[:id])\n    @post.body = \"Updated\" #no save\n\n    respond_to do |format|\n      format.html { redirect_back fallback_location: root_path}\n      format.json { render layout: \"stream\" }\n    end\n  end\nend\n</code></pre> <pre><code># posts/update.json.props\nbroadcast_save_props(model: @post) # Updates all connected clients instantly\n</code></pre> <p>Give rendered partials identity with Fragments, and optimistically update them client side.</p> <pre><code>json.cart(partial: [\"cart\", fragment: \"userCart\"]) do\nend\n</code></pre> <pre><code>const set = useSetFragment()\n\nset('userCart', (cartDraft) =&gt; {\n  cartDraft.lineItems[0].qty += 1\n})\n</code></pre>"},{"location":"candy-wrapper/","title":"candy_wrapper","text":"<p><code>candy_wrapper</code>s are lightweight wrapper components around popular UI libraries made to work with form_props. Easily use the power of Rails forms with any supported React UI library.</p>"},{"location":"candy-wrapper/#caution","title":"Caution","text":"<p>This project is in its early phases of development. Its interface, behavior, and name are likely to change drastically before a major version release.</p>"},{"location":"candy-wrapper/#component-status","title":"Component status","text":"<p>Each component is meant to be copied from this repo to your own project and customized to your liking. There are no CLI tools to help. Just copy and paste from GitHub.</p> <code>form_props</code> helper Component [Vanilla] [Mantine] ? <code>f.text_field</code> Checkbox <code>f.collection_check_boxes</code> CollectionCheckboxes <code>f.collection_radio_buttons</code> CollectionRadioButtons <code>f.color_field</code> ColorField <code>f.date_field</code> DateField <code>f.datetime_local_field</code> DateTimeLocalField <code>f.email_field</code> EmailField <code>f.month_field</code> MonthField <code>f.number_field</code> NumberField <code>f.password_field</code> PasswordField <code>f.range_field</code> RangeField <code>f.search_field</code> SearchField <code>f.select</code> (<code>multiple: true</code> supported) Select <code>f.tel_field</code> TelField <code>f.file_field</code> FileField <code>f.text_field</code> TextField <code>f.time_field</code> TimeField <code>f.url_field</code> UrlField <code>f.text_area</code> TextArea <code>f.grouped_collection_select</code> Select <code>f.weekday_select</code> Select <code>f.time_zone_select</code> Select <code>f.submit</code> SubmitButton"},{"location":"candy-wrapper/#installation","title":"Installation","text":"<p>There's nothing to install, but if you need types:</p> <pre><code>npm install -D candy_wrapper\n</code></pre> <p>Then go to the wrapper directory in this repo and copy the wrappers for the UI library of your choice into your project.</p>"},{"location":"candy-wrapper/#usage","title":"Usage","text":"<p>Once you've copied the components to your project. Use form_props to build your form:</p> <pre><code>json.newPostForm do\n  form_props(@post) do |f|\n    f.text_field :title\n    f.submit\n  end\nend\n</code></pre> <p>This would create a payload that looks something this:</p> <pre><code>{\n  someForm: {\n    props: {\n      id: \"create-post\",\n      action: \"/posts/123\",\n      acceptCharset: \"UTF-8\",\n      method: \"post\"\n    },\n    extras: {\n      method: {\n        name: \"_method\",\n        type: \"hidden\",\n        defaultValue: \"patch\",\n        autoComplete: \"off\"\n      },\n      utf8: {\n        name: \"utf8\",\n        type: \"hidden\",\n        defaultValue: \"\\u0026#x2713;\",\n        autoComplete: \"off\"\n      }\n      csrf: {\n        name: \"utf8\",\n        type: \"authenticity_token\",\n        defaultValue: \"SomeTOken!23$\",\n        autoComplete: \"off\"\n      }\n    },\n    inputs: {\n      title: {name: \"post[title]\", id: \"post_title\", type: \"text\", defaultValue: \"hello\"},\n      submit: {type: \"submit\", value: \"Update a Post\"}\n    }\n  }\n}\n</code></pre> <p>Take the payload and pass it to the wrapper:</p> <pre><code>import {Form, TextField, SubmitButton} from './copied_components_for_mantine'\n\nconst {form, extras, inputs} = newPostForm\n\n&lt;Form {...form} extras={extras}&gt;\n  &lt;TextField {...inputs.title} label=\"Post title\" /&gt;\n  &lt;SubmitButton {...inputs.submit} /&gt;\n&lt;/Form&gt;\n</code></pre>"},{"location":"candy-wrapper/#server-errors","title":"Server errors","text":"<p>Each wrapper comes with inline support for server errors.</p> <pre><code>import {Form, TextField} from './copied_components'\n\nconst validationErrors = {\n  full_title: \"Invalid length\"\n}\n\nconst {form, extras, inputs} = newPostForm\n\n&lt;Form {...form} extras={extras} validationErrors={validationErrors}&gt;\n  &lt;TextField {...inputs.title} label=\"Post title\" errorKey=\"full_title\" /&gt;\n  &lt;SubmitButton {...inputs.submit} /&gt;\n&lt;/Form&gt;\n</code></pre>"},{"location":"candy-wrapper/#vanilla","title":"Vanilla","text":"<p>Vanilla wrappers wrap around basic React HTML tags. If you want to build wrappers of your own, you can start here and use other UI wrappers as reference.</p>"},{"location":"candy-wrapper/#mantine","title":"Mantine","text":"<p>To use the Mantine wrappers, add the following libraries to your libraries before copying</p> <pre><code>yarn add dayjs\nyarn add @mantine/core\nyarn add @mantine/dates\n</code></pre>"},{"location":"candy-wrapper/#contributors","title":"Contributors","text":"<p>Thank you, contributors!</p>"},{"location":"client-updates/","title":"Client-Side updates","text":"<p>Superglue applications are primarily server-driven, but there are times when you need to update state on the client side without making a server request. This is where <code>useSetFragment</code> comes in.</p>"},{"location":"client-updates/#when-to-use-client-side-updates","title":"When to Use Client Side Updates","text":"<p>Common scenarios include:</p> <ul> <li>Optimistic updates - Update UI immediately, sync with server later</li> <li>Form state management - Handle user input before submission</li> <li>UI interactions - Toggle states, expand/collapse sections</li> </ul>"},{"location":"client-updates/#usesetfragment-hook","title":"useSetFragment Hook","text":"<p>The <code>useSetFragment</code> hook returns a setter function that lets you update any fragment by its ID:</p> <pre><code>import React from 'react'\nimport { useContent, useSetFragment } from '@thoughtbot/superglue'\n\nfunction ShoppingCart() {\n  const content = useContent()\n  const set = useSetFragment()\n\n  const addItem = (product) =&gt; {\n    set('userCart', (cartDraft) =&gt; {\n      cartDraft.items.push({\n        id: product.id,\n        name: product.name,\n        price: product.price,\n        quantity: 1\n      })\n      cartDraft.totalCost += product.price\n      cartDraft.itemCount += 1\n      })\n    }\n\n  const cart = content.cart\n\n  return (\n    &lt;div&gt;\n      &lt;h2&gt;Cart ({cart.itemCount} items)&lt;/h2&gt;\n      {cart.items.map(item =&gt; (\n        &lt;CartItem key={item.id} item={item} /&gt;\n      ))}\n      &lt;p&gt;Total: ${cart.totalCost}&lt;/p&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"client-updates/#fragment-references","title":"Fragment References","text":"<p>The set function's first parameter can be either a string ID or a fragment reference object:</p> <pre><code>const set = useSetFragment()\n\n// Using string ID\nset('userCart', (cartDraft) =&gt; {\ncartDraft.totalCost += 10\n})\n\n// Using fragment reference object\nconst cartRef = { __id: 'userCart' }\nset(cartRef, (cartDraft) =&gt; {\n  cartDraft.totalCost += 10\n})\n\n// Both approaches update the same fragment\n</code></pre> <p>This flexibility is especially useful when working with fragment references passed between components:</p> <pre><code>import React from 'react'\nimport { useSetFragment } from '@thoughtbot/superglue'\n\nfunction PostCard({ postRef }) {\n  const set = useSetFragment()\n\n  const markAsRead = () =&gt; {\n    // postRef is { __id: 'post_123' }\n    set(postRef, (postDraft) =&gt; {\n        postDraft.read = true\n    })\n  }\n\n  return &lt;button onClick={markAsRead}&gt;Mark as Read&lt;/button&gt;\n}\n</code></pre>"},{"location":"client-updates/#immutable-updates-with-immer","title":"Immutable updates with Immer","text":"<p>The <code>set</code> function takes a fragment identifier and an updater function that receives an Immer draft:</p> <pre><code>const set = useSetFragment()\n\nset('userCart', (cartDraft) =&gt; {\n  cartDraft.items.push(newItem)        // Direct mutation (safe)\n  cartDraft.totalCost += newItem.price // Direct assignment (safe)\n})\n</code></pre> <p>Behind the scenes, Superglue takes the updated draft and uses that for the fragment's next state.</p>"},{"location":"client-updates/#nested-fragment-updates","title":"Nested Fragment Updates","text":"<p>Fragments are composable and can contain references to other fragments. If you need to update a nested fragment, you can update them using nested <code>set</code> calls.</p> <pre><code>import React from 'react'\nimport { useContent, useSetFragment} from '@thoughtbot/superglue'\n\nfunction PostList() {\n  const content = useContent()\n  const set = useSetFragment()\n\n  const updateFirstPost = (content) =&gt; {\n    // content.posts is a fragment reference like {__id: 'postList'}\n    set(content.posts, (draftList) =&gt; {\n      // draftList[0] is a fragment reference like { __id: 'post_123' }\n      set(draftList[0], (firstPostDraft) =&gt; {\n        firstPostDraft.title = \"Updated Title\"\n        firstPostDraft.featured = true\n      })\n    })\n  }\n\n  const posts = content.posts()\n\n  return (\n    &lt;div&gt;\n      {posts.map((postRef, index) =&gt; (\n        &lt;PostCard key={index} postRef={postRef} /&gt;\n      ))}\n      &lt;button onClick={updateFirstPost}&gt;\n        Feature First Post\n      &lt;/button&gt;\n      &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"client-updates/#optimistic-updates-with-server-sync","title":"Optimistic Updates with Server Sync","text":"<p>For optimistic updates, combine client-side updates with server requests:</p> <pre><code>import React, { useContext } from 'react'\nimport { useContent, useSetFragment, NavigationContext } from '@thoughtbot/superglue'\n\nfunction LikeButton({ postId }) {\n  const content = useContent()\n  const set = useSetFragment()\n  const { remote } = useContext(NavigationContext)\n\n  const toggleLike = async () =&gt; {\n    // Optimistic update\n    set(`post_${postId}`, (postDraft) =&gt; {\n      postDraft.liked = !postDraft.liked\n      postDraft.likeCount += postDraft.liked ? 1 : -1\n    })\n\n    try {\n      // Sync with server\n      await remote(`/posts/${postId}/toggle_like`, { method: 'POST' })\n    } catch (error) {\n      // Revert on error\n      set(`post_${postId}`, (postDraft) =&gt; {\n        postDraft.liked = !postDraft.liked\n        postDraft.likeCount += postDraft.liked ? 1 : -1\n      })\n    }\n  }\n\n  const post = content.post\n\n  return (\n    &lt;button onClick={toggleLike}&gt;\n      {post.liked ? '\u2764\ufe0f' : '\ud83e\udd0d'} {post.likeCount}\n    &lt;/button&gt;\n  )\n}\n</code></pre>"},{"location":"client-updates/#advanced-redux-scenarios","title":"Advanced Redux Scenarios","text":"<p>The combination of <code>useSetFragment</code>, Fragments, and useSetContent, would be able to handle most of your state management needs. For even more advanced use cases, we have conveniences for you if you decide to use Redux as your state management solution.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>You've installed Superglue and now you're ready to configure your app.</p>"},{"location":"configuration/#application_visitjs","title":"<code>application_visit.js</code>","text":"<p>Modify the <code>application_visit.js</code> file to intercept and enhance Superglue's core navigation functions. It contains a single exported factory that builds the remote and visit functions that will be used by Superglue, your application, and the UJS attributes data-sg-visit and data-sg-remote.</p> <p>The pattern looks like this:</p> <pre><code>export const buildVisitAndRemote = (ref, store) =&gt; {\n  // Your custom logic here\n  return { visit: appVisit, remote: appRemote }\n}\n</code></pre> <p>To get you started, the generator creates an application_visit.js file with your first custom UJS attribute: data-sg-replace, which allows a link click or form submission to replace history instead of the usual push.</p> <pre><code>  const navigationAction = !!dataset?.sgReplace\n    ? \"replace\"\n    : meta.navigationAction\n</code></pre> <p>This is where you'll add progress bars, error handling, custom UJS attributes, analytics tracking, or any navigation behavior your app needs. Since every navigation goes through these functions, you have complete control over the developer experience.</p>"},{"location":"configuration/#page_to_page_mappingjs","title":"<code>page_to_page_mapping.js</code>","text":"<p>Info</p> <p>Stop by the tutorial to learn how to work with this file.</p> <p>Vite Users This step can be entirely optional if you're using Vite. See the recipe for more information.</p> <p>This file exports a mapping between a <code>componentIdentifier</code> to an imported page component. This gets used in your <code>application.js</code> so that superglue knows which component to render with which identifier.</p> <p>For example:</p> <pre><code>const pageIdentifierToPageComponent = {\n  'posts/edit': PostsEdit,\n  'posts/new': PostsNew,\n  'posts/show': PostsShow,\n  'posts/index': PostsIndex,\n}\n</code></pre>"},{"location":"configuration/#applicationjs","title":"<code>application.js</code>","text":"<p>This is the entry point of your application and uses Superglue's [Application] component. There's nothing to do here, but if you need finer control of how redux is setup, you can build your own Application using the source as inspiration.</p> <ul> <li> See complete reference      for <code>Application</code></li> </ul>"},{"location":"configuration/#flashjs","title":"<code>flash.js</code>","text":"<p>The installation generator will add a <code>flash.js</code> slice to <code>app/javascript/slices</code> and will work with the Rails <code>flash</code>. You can customize it to pass any temporary props that would last as along as <code>flash.now</code> or <code>flash</code>. The file is an example of a custom slice.</p> <ul> <li> Read more       about custom slices and <code>flash.js</code>.</li> </ul>"},{"location":"deferments/","title":"Deferments","text":"<p>Sometimes you may want to load parts of your page later, like a slow sidebar, a graph that takes extra time to load, or tab content that shouldn't appear immediately. These scenarios are perfect use cases for Deferments.</p> <p>Deferments are a low effort way to load content later, both automatically and manually. Better yet, most of the work takes place in Rails land in your views.</p>"},{"location":"deferments/#defer-auto","title":"<code>defer: :auto</code>","text":"<p>This option make it easy to defer content in a single setting.</p> views/posts/index.json.propsviews/layouts/application.json.props <pre><code>  json.metrics(defer: [:auto, placeholder: {totalVisitors: 0}]) do\n    sleep 10 # expensive operation\n    json.totalVisitors 30\n  end\n</code></pre> <pre><code>  json.data do\n    yield\n  end\n</code></pre> <p>And that's it! </p>"},{"location":"deferments/#behind-the-scenes","title":"Behind the scenes","text":"<p>When a user lands on a page Superglue will receive</p> <pre><code>{\n  data: {\n    metrics: {\n      totalVisitors: 0\n    }\n  },\n  defers:[\n    {url: '/dashboard?props_at=data.metrics', type: \"auto\"}\n  ],\n  ...other\n}\n</code></pre> <p>Your page components will receive <code>{metrics: {totalVisitors: 0}}</code> and render. Superglue will then make a remote request:</p> <pre><code>remote(\"/dashboard?props_at=data.metrics\")\n</code></pre> <p>10 seconds later the response succeeds with <code>{total_visitors: 30}</code>. Superglue then immutably grafts that payload into the <code>/dashboard</code> page at the path <code>data.metrics</code>. The page state would look like the following:</p> <pre><code>{\n  data: {\n    metrics: {\n      totalVisitors: 30\n    }\n  },\n  defers:[...others],\n  ...other\n}\n</code></pre> <p>Your page component finally recieves the new props and rerenders. For more control, you may provide a <code>success_action</code> or <code>fail_action</code>, and Superglue will dispatch these actions when the promise resolves successfully or fails.</p> <pre><code>json.metrics(defer: [:auto, placeholder: {totalVisitors: 0}, success_action: \"SUCCESS\", fail_action: \"FAIL\"]) do\n  sleep 10 # expensive operation\n  json.totalVisitors 30\nend\n</code></pre>"},{"location":"deferments/#defer-manual","title":"<code>defer: :manual</code>","text":"<p>When you want control over when deferred content loads, e.g., tabbed content, use <code>defer: :manual</code> to stop the content from loading</p> <pre><code>json.metrics(defer: [:manual, placeholder: {totalVisitors: 0}]) do\n  sleep 10 # expensive operation\n  json.totalVisitors 30\nend\n</code></pre> <p>and manually use <code>remote</code></p> <pre><code>remote(\"/dashboard?props_at=data.metrics\")\n</code></pre>"},{"location":"demo/","title":"Demo Application","text":"<p>We have a non-trivial demo application built using Superglue and the original Rails and StimulusJS version built by Sean Doyle The intent is to help you compare and contrast both approaches and showcase how enjoyable and Rails-like Superglue/React/Redux can be.</p> <p></p> <p>We recommend going over the meticulously verbose commit history on Sean's version and comparing that with the Superglue version.</p>"},{"location":"digging/","title":"Digging","text":"<p>Beyond full page navigation, Superglue can make selective updates to parts of the page without a full load through digging. You may recognize digging from earlier docs:</p> <pre><code>/some_current_page?props_at=data.rightDrawer.dailySpecials\n</code></pre> <p>By simply adding a <code>props_at</code> parameter to your requests, you can selectively fetch parts of the page without incurring the cost of loading unneeded content. This is great for functionality like modals, tabs, etc.</p>"},{"location":"digging/#the-props_at-param","title":"The <code>props_at</code> param","text":"<p>The <code>props_at</code> param is a keypath to the content in your PropsTemplate. As a simplified example, imagine this page with no layouts:</p> <pre><code>path = param_to_dig_path(params[:props_at])\njson.data(dig: path) do\n  json.header do\n    json.search do\n      # Results is a leaf node\n      json.results Post.search(params[:some_search_str])\n    end\n  end\n\n  json.content do\n    json.barChart do\n       ...bar chart data\n    end\n\n    ...\n  end\n\n  ...\nend\n</code></pre> <p>To fetch the <code>json.search</code> node, we would need to walk to <code>data</code> then <code>header</code> then <code>search</code>. Translating that to a url with a <code>props_at</code> param:</p> <pre><code>/dashboard?props_at=data.header.search&amp;some_search_str=haircuts\n</code></pre> <p>Digging is normally combined with using data-sg-remote or remote to update content in async fashion.</p> <p>Info</p> <p><code>props_at</code> can be used with <code>data-sg-visit</code></p>"},{"location":"digging/#collections","title":"Collections","text":"<p>There are two ways to query collections. Looking at the following example:</p> <pre><code>path = param_to_dig_path(params[:props_at])\njson.data(dig: path) do\n  json.posts do\n    json.array! @posts do |post|\n      json.details do\n        json.title post.title\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"digging/#index-based-selection","title":"Index-based selection","text":"<p>You may use an index-based key to fetch an item in a list like so:</p> <pre><code>remote('/dashboard?props_at=data.posts.0.details')\n</code></pre> <p>To enable this functionality, you are required to implement <code>member_at(index)</code> on the passed collection.</p> <p>?&gt; PropsTemplate includes a <code>Array</code> extension which delegates to <code>at</code>. If you've used the Superglue generators, it will be included in an initializer.</p> <p>While traversing by index works fine, it can lead the wrong post being updated if your Redux state has changed by the time the request comes back.</p>"},{"location":"digging/#attribute-based-selection","title":"Attribute-based selection","text":"<p>Attribute-based keys for collections look like this:</p> <pre><code>remote('/dashboard?props_at=data.posts.some_id=1.details')\n</code></pre> <p>Notice that we're now referencing the collection member by <code>some_id=1</code> instead of index. This will fetch the node from the backend and graft it correctly in Redux.</p> <p>To enable this, you are required to implement <code>member_by(attribute, value)</code> on the passed collection AND use the option <code>:key</code> in <code>json.array!</code>. For example:</p> <pre><code>path = param_to_dig_path(params[:props_at])\njson.data(dig: params[:props_at]) do\n  json.posts do\n    json.array! @posts, key: :some_id do |post|\n      json.details do\n        json.title post.title\n      end\n\n      # The following will be auto appended by the key: option\n      # json.some_id post.some_id\n    end\n  end\nend\n</code></pre>"},{"location":"digging/#partials","title":"Partials","text":"<p>You can even query into partials.</p> <pre><code>remote('/dashboard?props_at=data.posts.some_id=1.details')\n</code></pre> <pre><code>json.data(dig: params[:props_at]) do\n  json.posts(partial: 'list_of_posts')do\n  end\nend\n</code></pre> <pre><code># list_of_posts.json.props\njson.array! @posts , key: :some_id do |post|\n  json.details do\n    json.title post.title\n  end\n\n  # The following will be auto appended by the key: option\n  # json.some_id post.some_id\nend\n</code></pre> <p>Info</p> <p>When querying, Superglue will disable caching and deferment until the target node is reached.</p> <p>With digging, many modern SPA functionality can be achieved by just a keypath and a few lines of code.</p>"},{"location":"form-props/","title":"form_props","text":"<p>form_props is a Rails form builder that outputs HTML props instead of tags. Now you can enjoy the power and convenience of Rails helpers in React!</p> <p>By separating attributes from tags, form_props can offer greater flexibility than normal Rails form builders; allowing designers to stay longer in HTML land and more easily customize their form structure without needing to know Rails.</p>"},{"location":"form-props/#caution","title":"Caution","text":"<p>This project is in its early phases of development. Its interface, behavior, and name are likely to change drastically before a major version release.</p>"},{"location":"form-props/#installation","title":"Installation","text":"<p>Add to your <code>Gemfile</code></p> <pre><code>gem \"form_props\"\n</code></pre> <p>and <code>bundle install</code></p>"},{"location":"form-props/#usage","title":"Usage","text":"<p><code>form_props</code> is designed to be used in a PropsTemplate template (it can work with jbuilder). For example in your <code>new.json.props</code>:</p> <pre><code>json.some_form do\n  form_props(model: @post) do |f|\n    f.text_field :title\n    f.submit\n  end\nend\n</code></pre> <p>would output</p> <pre><code>{\n  someForm: {\n    props: {\n      id: \"create-post\",\n      action: \"/posts/123\",\n      acceptCharset: \"UTF-8\",\n      method: \"post\"\n    },\n    extras: {\n      method: {\n        name: \"_method\",\n        type: \"hidden\",\n        defaultValue: \"patch\",\n        autoComplete: \"off\"\n      },\n      utf8: {\n        name: \"utf8\",\n        type: \"hidden\",\n        defaultValue: \"\\u0026#x2713;\",\n        autoComplete: \"off\"\n      }\n      csrf: {\n        name: \"utf8\",\n        type: \"authenticity_token\",\n        defaultValue: \"SomeTOken!23$\",\n        autoComplete: \"off\"\n      }\n    },\n    inputs: {\n      title: {name: \"post[title]\", id: \"post_title\", type: \"text\", defaultValue: \"hello\"},\n      submit: {type: \"submit\", value: \"Update a Post\"}\n    }\n  }\n}\n</code></pre> <p>You can then proceed to use this output in React like so:</p> <pre><code>import React from 'react'\n\nexport default ({props, inputs, extras}) =&gt; {\n  &lt;form {...props}&gt;\n    {Object.values(extras).map((hiddenProps) =&gt; (&lt;input {...hiddenProps} key={hiddenProps.name}/&gt;))}\n\n    &lt;input {...inputs.title} /&gt;\n    &lt;label for={inputs.title.id}&gt;Your Name&lt;/label&gt;\n    &lt;button {...inputs.submit}&gt;{inputs.submit.text}&lt;/button&gt;\n  &lt;/form&gt;\n}\n</code></pre>"},{"location":"form-props/#key-format","title":"Key format","text":"<p>By default, props_template automatically <code>camelize(:lower)</code> on all keys. All documentation here reflects that default. You can change that behavior if you wish.</p>"},{"location":"form-props/#flexibility","title":"Flexibility","text":"<p>form_props is only concerned about attributes, the designer can focus on tag structure and stay longer in HTML land. For example, you can decide to nest an input inside a label.</p> <pre><code>&lt;label for={inputs.name.id}&gt;\n  Your Name\n  &lt;input {...inputs.name} type=\"text\"/&gt;\n&lt;/label&gt;\n</code></pre> <p>or not</p> <pre><code>&lt;label for={inputs.name.id}&gt;Your Name&lt;/label&gt;\n&lt;input {...inputs.name} /&gt;\n</code></pre>"},{"location":"form-props/#custom-components","title":"Custom Components","text":"<p>With <code>form_props</code> you can combine the comprehensiveness of Rails forms with your preferred React components:</p> <p>For example:</p> <pre><code>json.some_form do\n  form_props(model: @post) do |f|\n    f.time_zone_select(:time_zone)\n    ...\n  end\nend\n</code></pre> <p>Then use it the props your own components or a external component like <code>react-select</code>:</p> <pre><code>import React from 'react'\nimport Select from 'react-select';\n\nexport default (({props, inputs, extras})) =&gt; {\n  return (\n    &lt;form {...props}&gt;\n      &lt;Select\n        {...inputs.timeZone}\n        isMulti={inputs.timeZone.multiple}\n      /&gt;\n    &lt;/form&gt;\n  )\n}\n</code></pre>"},{"location":"form-props/#error-handling","title":"Error handling","text":"<p>form_props doesn't handle form errors, but you can easily add this functionality:</p> <pre><code>json.someForm do\n  form_props(model: @post) do |f|\n    f.text_field :title\n  end\n\n  json.errors @post.errors.to_hash(true)\nend\n</code></pre> <p>then merge it later</p> <pre><code>&lt;MyTextComponent {...someForm.inputs.title, error: ...someForm.errors.title}&gt;\n</code></pre>"},{"location":"form-props/#form_props_1","title":"form_props","text":"<p><code>form_props</code> shares most of same arguments as form_with. The differences are</p> <ol> <li><code>remote</code> and <code>local</code> options are removed.</li> <li>You can change the name of the value keys generated by the form helpers from <code>defaultValue</code> to <code>value</code>, by using <code>controlled: true</code>. For example:</li> </ol> <pre><code>json.some_form do\n  form_props(model: @post, controlled: true) do |f|\n    f.text_field :title\n  end\nend\n</code></pre> <p>By default, the <code>controlled</code> option is <code>false</code>.</p>"},{"location":"form-props/#_1","title":"Overview","text":"<p><code>props</code> Attributes that you can splat directly into your <code>&lt;form&gt;</code> element.</p> <p><code>extras</code> contain hidden input attributes that are created by form_props indirectly, for example, the <code>csrf</code> token. Its best to wrap this in a custom component that does the following. An Extra component is available</p> <pre><code>Object.values(extras).map((hiddenProps) =&gt; (&lt;input {...hiddenProps} type=\"hidden\"/&gt;))}\n</code></pre>"},{"location":"form-props/#form-helpers","title":"Form Helpers","text":"<p><code>form_props</code> provides its own version of the following Rails form helpers:</p> <pre><code>check_box                 file_field                submit\ncollection_check_boxes    grouped_collection_select tel_field\ncollection_helpers        hidden_field              text_area\ncollection_radio_buttons  month_field               text_field\ncollection_select         number_field              time_field\ncolor_field               password_field            time_zone_select\ndate_field                radio_button              url_field\ndatetime_field            range_field               week_field\ndatetime_local_field      search_field              weekday_select\nemail_field               select\n</code></pre> <p><code>form_props</code> is a fork of <code>form_with</code>, and the accompanying form builder inherits from <code>ActionView::Helpers::FormBuilder</code>.</p> <p>Many of the helpers accept the same arguments and you can continue to rely on [Rails Guides for form helpers] for guidance, but as the goal of <code>form_props</code> is to focus on attributes instead of tags there are a few general differences across all helpers that would be beneficial to know:</p> <ol> <li>The form helper <code>f.label</code> does not exist. Helpers like the below that <code>yield</code> for label structure</li> </ol> <pre><code>f.collection_radio_buttons(:active, [true, false], :to_s, :to_s) do |b|\n  b.label { b.radio_button + b.text }\nend\n</code></pre> <p>no longer takes in blocks to do so.</p> <ol> <li><code>defaultValue</code>s are not escaped. Instead, we lean on PropsTemplate to escape JSON and HTML entities.</li> <li><code>defaultValue</code> will not appear as a key if no <code>value</code> was set.</li> <li><code>data-disable-with</code> is removed on submit buttons.</li> <li><code>data-remote</code> is removed from form props.</li> <li>For helpers that selectively render hidden inputs, we pass the attribute to</li> <li><code>f.select</code> helpers do not render <code>selected</code> on <code>options</code>, instead they follow React caveats and render on the input's <code>value</code>. For example:</li> </ol> <pre><code>{\n  \"type\": \"select\",\n  \"name\": \"continent[countries]\",\n  \"id\": \"continent_countries\",\n  \"multiple\": true,\n  \"defaultValue\": [\"Africa\", \"Europe\"],\n  \"options\": [\n    {\"value\": \"Africa\", \"label\": \"Africa\"},\n    {\"value\": \"Europe\", \"label\": \"Europe\"},\n    {\"value\": \"America\", \"label\": \"America\", \"disabled\": true}\n  ]\n}\n</code></pre>"},{"location":"form-props/#unsupported-helpers","title":"Unsupported helpers","text":"<p><code>form_props</code> does not support:</p> <p><code>label</code>. We encourage you to use the tag directly in combination with other helpers. For example:</p> <pre><code>&lt;label for={inputs.name.id} /&gt;\n</code></pre> <p><code>rich_text_area</code>. We encourage you to use the <code>f.text_area</code> helper in combination with Trix wrapped in React, or TinyMCE's react component.</p> <p><code>button</code>. We encourage you to use the tag directly.</p> <p><code>date_select</code>, <code>time_select</code>, <code>datetime_select</code>. We encourage you to use other alternatives like <code>react-date-picker</code> in combination with other supported date field helpers.</p>"},{"location":"form-props/#text-helpers","title":"Text helpers","text":"<p>text_field, email_field, tel_field, file_field, url_field, hidden_field, and the slight variations password_field, search_field, color_field has the same arguments as their Rails counterpart.</p> <p>When used like so</p> <pre><code>form_props(model: @post) do |f|\n  f.text_field(:title)\nend\n</code></pre> <p><code>inputs.title</code> would output</p> <pre><code>{\n  \"type\": \"text\",\n  \"defaultValue\": \"Hello World\",\n  \"name\": \"post[title]\",\n  \"id\": \"post_title\"\n}\n</code></pre>"},{"location":"form-props/#date-helpers","title":"Date helpers","text":"<p>date_field, datetime_field, datetime_local_field, month_field, week_field has the same arguments as their Rails counterparts.</p> <p>When used like so</p> <pre><code>form_props(model: @post) do |f|\n  f.datetime_field(:created_at)\nend\n</code></pre> <p><code>inputs.created_at</code> would output</p> <pre><code>{\n  \"type\": \"datetime-local\",\n  \"defaultValue\": \"2004-06-15T01:02:03\",\n  \"name\": \"post[created_at]\",\n  \"id\": \"post_created_at\"\n}\n</code></pre>"},{"location":"form-props/#number-helpers","title":"Number helpers","text":"<p>number_field, range_field has the same arguments as their Rails counterparts.</p> <p>When used like so</p> <pre><code>@post.favs = 2\n\nform_props(model: @post) do |f|\n  f.range_field(:favs, in: 1...10)\nend\n</code></pre> <p><code>inputs.favs</code> would output</p> <pre><code>{\n  \"type\": \"range\",\n  \"defaultValue\": \"2\",\n  \"name\": \"post[favs]\",\n  \"min\": 1,\n  \"max\": 9,\n  \"id\": \"post_favs\"\n}\n</code></pre>"},{"location":"form-props/#checkbox-helper","title":"Checkbox helper","text":"<p>check_box has the same arguments as its Rails counterpart.</p> <p>The original Rails <code>check_box</code> helper renders an unchecked value in a hidden input. While <code>form_props</code> doesn't generate the tags, the <code>unchecked_value</code>, and <code>include_hidden</code> can be passed to a React component to replicate that behavior. This repository has an example CheckBox component used in its test that you can refer to.</p> <p>When used like so:</p> <pre><code>@post.admin = \"on\"\n\nform_props(model: @post) do |f|\n  f.check_box(:admin, {}, \"on\", \"off\")\nend\n</code></pre> <p><code>inputs.admin</code> would output</p> <pre><code>{\n  \"type\": \"checkbox\",\n  \"defaultValue\": \"on\",\n  \"uncheckedValue\": \"off\",\n  \"name\": \"post[admin]\",\n  \"id\": \"post_admin\",\n  \"includeHidden\": true\n}\n</code></pre>"},{"location":"form-props/#radio-helper","title":"Radio helper","text":"<p>radio_button has the same arguments as its Rails counterpart.</p> <p>When used like so:</p> <pre><code>@post.admin = false\n\nform_props(model: @post) do |f|\n  f.radio_button(:admin, true)\n  f.radio_button(:admin, false)\nend\n</code></pre> <p>The keys on <code>inputs</code> are a combination of the name and value. So <code>inputs.adminTrue</code> would output:</p> <pre><code>{\n  \"type\": \"radio\",\n  \"defaultValue\": \"true\",\n  \"name\": \"post[admin]\",\n  \"id\": \"post_admin_true\"\n}\n</code></pre> <p>and <code>inputs.adminFalse</code> would output</p> <pre><code>{\n  \"type\": \"radio\",\n  \"defaultValue\": \"false\",\n  \"name\": \"post[admin]\",\n  \"id\": \"post_admin_false\",\n  \"checked\": true\n}\n</code></pre>"},{"location":"form-props/#select-helpers","title":"Select helpers","text":"<p>select, weekday_select, [time_zone_select] mostly have the same arguments as their Rails counterparts. The key difference is that choices for select cannot be a string:</p> <pre><code># BAD!!!\n\nform_props(model: @post) do |f|\n  f.select(:category, \"&lt;option&gt;&lt;option/&gt;\", multiple: false)\nend\n\n# Good\n\nform_props(model: @post) do |f|\n  f.select(:category, [], multiple: false)\nend\n</code></pre> <p>When used like so</p> <pre><code>@post.category = \"lifestyle\"\n\nform_props(model: @post) do |f|\n  f.select(:category, [\"lifestyle\", \"programming\", \"spiritual\"], {selected: \"\", disabled: \"\", prompt: \"Choose one\"}, {required: true})\nend\n</code></pre> <p><code>inputs.category</code> would output</p> <pre><code>{\n  \"type\": \"select\",\n  \"required\": true,\n  \"name\": \"post[category]\",\n  \"id\": \"post_category\",\n  \"defaultValue\":\"lifestyle\",\n  \"options\": [\n    {\"disabled\": true, \"value\": \"\", \"label\": \"Choose one\"},\n    {\"value\": \"lifestyle\", \"label\": \"lifestyle\"},\n    {\"value\": \"programming\", \"label\": \"programming\"},\n    {\"value\": \"spiritual\", \"label\": \"spiritual\"}\n  ]\n}\n</code></pre> <p>Of note: 1. Notice that we follow react caveats and put <code>selected</code> values on <code>defaultValue</code>. This rule does not apply to the <code>disabled</code> attribute on option. 2. When <code>multiple: true</code>, <code>defaultValue</code> is an array of values. 3. The key, <code>defaultValue</code> is only set if the value is in options. For example:</p> <pre><code>form_props(model: @post) do |f|\n  f.select(:category, [])\nend\n</code></pre> <p>would output in <code>inputs.category</code>:</p> <pre><code>{\n  \"type\": \"select\",\n  \"name\": \"post[category]\",\n  \"id\": \"post_category\",\n  \"options\": []\n}\n</code></pre> <p>As the <code>select</code> helper renders nested options and <code>includeHidden</code>, a custom component is required to correctly render the tag structure. A reference Select component implementation is availble that is used in our tests.</p> <p>The <code>select</code> helper can also output a grouped collection.</p> <pre><code>@post = Post.new\ncountries_by_continent = [\n  [\"&lt;Africa&gt;\", [[\"&lt;South Africa&gt;\", \"&lt;sa&gt;\"], [\"Somalia\", \"so\"]]],\n  [\"Europe\", [[\"Denmark\", \"dk\"], [\"Ireland\", \"ie\"]]]\n]\n\nform_props(model: @post) do |f|\n  f.select(:category, countries_by_continent)\nend\n</code></pre> <p><code>inputs.category</code> would output:</p> <pre><code>{\n  \"type\": \"select\",\n  \"name\": \"post[category]\",\n  \"id\": \"post_category\",\n  \"options\": [\n    {\n      \"label\": \"&lt;Africa&gt;\", \"options\": [\n        {\"value\": \"&lt;sa&gt;\", \"label\": \"&lt;South Africa&gt;\"},\n        {\"value\": \"so\", \"label\": \"Somalia\"}\n      ]\n    },\n    {\n      \"label\": \"Europe\", \"options\": [\n        {\"value\": \"dk\", \"label\": \"Denmark\"},\n        {\"value\": \"ie\", \"label\": \"Ireland\"}\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"form-props/#group-collection-select","title":"Group collection select","text":"<p>group_collection_select has the same arguments as its Rails counterpart.</p> <p>Like <code>select</code>, you'll need to combine this with a custom <code>Select</code> component. An example Select component is available.</p> <p>When used like so:</p> <pre><code>@post = Post.new\n@post.country = \"dk\"\nlabel_proc = proc { |c| c.id }\n\ncontinents = [\n  Continent.new(\"&lt;Africa&gt;\", [Country.new(\"&lt;sa&gt;\", \"&lt;South Africa&gt;\"), Country.new(\"so\", \"Somalia\")]),\n  Continent.new(\"Europe\", [Country.new(\"dk\", \"Denmark\"), Country.new(\"ie\", \"Ireland\")])\n]\n\nform_props(model: @post) do |f|\n  f.grouped_collection_select(\n    :country, continents, \"countries\", label_proc, \"country_id\", \"country_name\"\n  )\nend\n</code></pre> <p><code>inputs.country</code> would output</p> <pre><code>{\n  \"name\": \"post[country]\",\n  \"id\": \"post_country\",\n  \"type\": \"select\",\n  \"defaultValue\": \"dk\",\n  \"options\": [\n    {\n      \"label\":\"&lt;Africa&gt;\",\n      \"options\": [\n        {\"value\": \"&lt;sa&gt;\", \"label\": \"&lt;South Africa&gt;\"},\n        {\"value\": \"so\", \"label\": \"Somalia\"}\n      ]\n    }, {\n      \"label\": \"Europe\",\n      \"options\": [\n        {\"value\": \"dk\", \"label\": \"Denmark\"},\n        {\"value\":\"ie\", \"label\": \"Ireland\"}\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"form-props/#collection-select","title":"Collection select","text":"<p>collection_select, collection_radio_buttons, and collection_check_boxes have the same arguments as their Rails counterparts, but their output differs slightly.</p> <p>collection_select follows the same output as <code>f.select</code>. When used like so:</p> <pre><code>dummy_posts = [\n  Post.new(1, \"&lt;Abe&gt; went home\", \"&lt;Abe&gt;\", \"To a little house\", \"shh!\"),\n  Post.new(2, \"Babe went home\", \"Babe\", \"To a little house\", \"shh!\"),\n  Post.new(3, \"Cabe went home\", \"Cabe\", \"To a little house\", \"shh!\")\n]\n\n\nform_props(model: @post) do |f|\n  f.collection_select(:author_name, dummy_posts, \"author_name\", \"author_name\")\nend\n</code></pre> <p><code>inputs.authorName</code> would output:</p> <pre><code>{\n  \"type\": \"select\",\n  \"name\": \"post[author_name]\",\n  \"id\": \"post_author_name\",\n  \"defaultValue\": \"Babe\",\n  \"options\": [\n    {\"value\": \"&lt;Abe&gt;\", \"label\": \"&lt;Abe&gt;\"},\n    {\"value\": \"Babe\", \"label\": \"Babe\"},\n    {\"value\": \"Cabe\", \"label\": \"Cabe\"}\n  ]\n}\n</code></pre> <p>collection_radio_buttons and collection_check_boxes usage is the same with their rails counterpart, and when used, would render:</p> <pre><code>{\n  \"collection\": [\n    {\"name\":\"user[other_category_ids][]\",\"type\": \"checkbox\", \"defaultValue\": \"1\", \"uncheckedValue\":\"\",\"id\":\"user_category_ids_1\",\"label\": \"Category 1\"},\n    {\"name\":\"user[other_category_ids][]\",\"type\": \"checkbox\", \"defaultValue\": \"2\", \"uncheckedValue\":\"\",\"id\":\"user_category_ids_2\",\"label\": \"Category 2\"}\n  ],\n  \"name\": \"user[other_category_ids][]\",\n  \"includeHidden\": true\n}\n</code></pre> <p>Like select, you would need a custom component to render. An example implementation for CollectionCheckBoxes and CollectionRadioButtons are available.</p>"},{"location":"form-props/#jbuilder","title":"jbuilder","text":"<p>form_props can work with jbuilder, but needs an extra call in the beginning of your template to <code>FormProps.set</code> to inject <code>json</code>. For example.</p> <pre><code>FormProps.set(json, self)\n\njson.data do\n  json.hello \"world\"\n\n  json.form do\n    form_props(model: User.new, url: \"/\") do |f|\n      f.text_field(:email)\n      f.submit\n    end\n  end\nend\n</code></pre>"},{"location":"form-props/#special-thanks","title":"Special Thanks","text":"<p>Thanks to bootstrap_form documentation for inspiration.</p>"},{"location":"forms/","title":"Forms","text":"<p>Rails form helpers are by far one of the most valuable tools in a developer's arsenal. Working with React doesn't mean we have to abandon this tooling. </p>"},{"location":"forms/#from-form_with-to-form_props","title":"From <code>form_with</code> to <code>form_props</code>","text":"<p>Superglue comes with <code>form_props</code>, a fork of <code>form_with</code> made for <code>props_template</code> and <code>jbuilder</code> to output props instead of HTML. </p> <p>Before:</p> <pre><code>&lt;h1&gt;&lt;%= @post.title %&gt;&lt;/h1&gt;\n&lt;%= form_with model: @post do |f| %&gt;\n  &lt;%= f.text_field :title %&gt;\n  &lt;%= f.text_area :body %&gt;\n  &lt;%= f.submit %&gt;\n&lt;% end %&gt;\n</code></pre> <p>After:</p> <pre><code>json.title @post.title\n\njson.postForm do\n  form_props model: @post do |f|\n    f.text_field :title\n    f.text_area :body\n    f.submit\n  end\nend\n</code></pre> <p>and splat it into your React components</p> <pre><code>import {Form, TextField, SubmitButton} from './maintine_wrappers'\n\nconst {form, extras, inputs} = newPostForm\n\n&lt;Form {...form} extras={extras}&gt;\n  &lt;TextField {...inputs.title} label=\"Post title\" /&gt;\n  &lt;TextField {...inputs.body} label=\"Post body\" /&gt;\n  &lt;SubmitButton {...inputs.submit} /&gt;\n&lt;/Form&gt;\n</code></pre>"},{"location":"forms/#react-ui-kits","title":"React UI kits","text":"<p><code>form_props</code> outputs props. This means it can work with ANY React UI kit as long as we're able to shape the props to the component's interface. This can be accomplished using custom wrapper components, or use ours.</p> <p><code>candy_wrapper</code> is set of copyable prebuilt wrappers around popular React UI libraries. Just copy and go:</p> <pre><code>import {Form, TextField, SubmitButton} from './copied_components_for_mantine'\n\nconst {form, extras, inputs} = newPostForm\n\n&lt;Form {...form} extras={extras}&gt;\n  &lt;TextField {...inputs.title} label=\"Post title\" /&gt;\n  &lt;SubmitButton {...inputs.submit} /&gt;\n&lt;/Form&gt;\n</code></pre> <p>Component tests are included for you to copy as well.</p>"},{"location":"forms/#form-errors","title":"Form Errors","text":"<p>Form errors can be implemented in a variety of ways. To start off, you'll find support for inline errors in all of <code>candy_wrapper</code> components</p> <pre><code>const validationErrors = {\n  post_title: \"can't be blank\"\n}\n\n&lt;Form {...form} extras={extras} validationErrors={validationErrors}&gt;\n  &lt;TextField {...inputs.title} label=\"Post title\" errorKey=\"post_title\"/&gt;\n  &lt;SubmitButton {...inputs.submit} /&gt;\n&lt;/Form&gt;\n</code></pre> <p>However, <code>form_props</code> does not handle form errors out-of-the-box. Instead, the recommended way to handle errors is through Rail's <code>flash</code>. For example:</p> <pre><code>class PostsController &lt; ApplicationController\n  def create\n    @post = Post.new(post_params)\n\n    if @post.save\n      redirect_to :index\n    else\n+      flash.now[:postFormErrors] = @post.errors.as_json\n      render :new\n    end\n  end\nend\n</code></pre> <pre><code>const validationErrors = useSelector((state) =&gt; state.flash[:postFormErrors])\n\n&lt;Form {...form} extras={extras} validationErrors={validationErrors}&gt;\n  &lt;TextField {...inputs.title} label=\"Post title\" errorKey=\"post_title\"/&gt;\n  &lt;SubmitButton {...inputs.submit} /&gt;\n&lt;/Form&gt;\n</code></pre>"},{"location":"fragments/","title":"Fragments","text":"<p>Rails partials are powerful</p> <p>They're not just about DRY'ing your views - they're also about semantic identification. When you extract a <code>_header.html.erb</code>, you're declaring \"this thing is a header\" with its own identity and boundary. It's valuable information that is often lost when rendered with a view.</p> <p>Enter fragments:</p> <p>A fragment is a rendered partial with referential identity on the client side. Its a powerful feature that lets you update client state using an id.</p> <p>For example:</p> <pre><code>json.title \"Hello\"\n\njson.cart(partial: [\"user/cart\", fragment: \"userCart\"]) do\nend\n</code></pre> <pre><code>const content = useContent()\nconst set = useSetFragment()\n\nset(\"userCart\", (cartDraft) =&gt; {\n  cartDraft.totalCost = 100\n})\n\n&lt;Cart {...content.cart}/&gt;\n&lt;CartSummaryHeader {...content.cart}/&gt;\n</code></pre> <p>Turbo Streams</p> <p>Because fragments are just Rails partial, it enables a familiar and powerful feature of Superglue: Super Turbo Streams.</p>"},{"location":"fragments/#denormalization","title":"Denormalization","text":"<p>A page response that uses fragments first returns a normalized state. A response from the previous example would look like:</p> <pre><code>  {\n    \"data\": {\n      \"title\": \"Hello\",\n      \"cart\": {\n        \"items\": [\n          { \"id\": 1, \"name\": \"Widget\", \"price\": 19.99, \"quantity\": 2 },\n          { \"id\": 2, \"name\": \"Gadget\", \"price\": 29.99, \"quantity\": 1 }\n        ],\n        \"availableCoupons\": [\n          {\"title\": \"free shipping\", \"code\": \"abc123\"}\n        ]\n        \"totalCost\": 69.97,\n        \"itemCount\": 3\n      }\n    },\n    \"fragments\": [\n      { \"type\": \"userCart\", \"path\": [\"cart\"] }\n    ]\n  }\n</code></pre> <p>On the client side, Superglue will denormalize when saving to the Redux state:</p> <pre><code>  {\n    pages: {\n      \"/current-page\": {\n        data: {\n          \"title\": \"Hello\",\n          \"cart\": { \"__id\": \"userCart\" }  // Fragment reference\n        }\n      }\n    },\n    fragments: {\n      \"userCart\": {\n        \"items\": [\n          { \"id\": 1, \"name\": \"Widget\", \"price\": 19.99, \"quantity\": 2 },\n          { \"id\": 2, \"name\": \"Gadget\", \"price\": 29.99, \"quantity\": 1 }\n        ],\n        \"availableCoupons\": [\n          {title: \"free shipping\", code: \"abc123\"}\n        ]\n        \"totalCost\": 69.97,\n        \"itemCount\": 3\n      }\n    }\n  }\n</code></pre> <p>Like partials, fragments are also composible:</p> <pre><code>  {\n    pages: {\n      \"/current-page\": {\n        data: {\n          \"title\": \"Hello\",\n          \"cart\": { \"__id\": \"userCart\" }  // Fragment reference\n        }\n      }\n    },\n    fragments: {\n      \"userCart\": {\n        \"items\": [\n          { \"id\": 1, \"name\": \"Widget\", \"price\": 19.99, \"quantity\": 2 },\n          { \"id\": 2, \"name\": \"Gadget\", \"price\": 29.99, \"quantity\": 1 }\n        ],\n        \"availableCoupons\": {__id: \"userCoupons\"} // Fragment reference\n        \"totalCost\": 69.97,\n        \"itemCount\": 3\n      },\n      \"userCoupons\": [\n        {title: \"free shipping\", code: \"abc123\"}\n      ]\n    }\n  }\n</code></pre>"},{"location":"fragments/#normalization","title":"Normalization","text":"<p>When reading content, Superglue's <code>useContent</code> hook will return a proxy that lazily normalizes the data.</p> <pre><code>const content = useContent()\n\n&lt;h1&gt;{content.title}&lt;/h1&gt;\n\n&lt;p&gt;Num of items in cart&lt;/p&gt;\n&lt;p&gt;{content.cart.items.length}&lt;/p&gt;\n</code></pre> <p>Info</p> <p>Behind the scenes, the <code>useContent</code> hook will track every fragment accessed through the proxy. If any of those fragments gets updated, the React component will rerender. This can be selectively tuned for performance.</p>"},{"location":"fragments/#mutations","title":"Mutations","text":"<p>Important</p> <p>Proxies created by <code>useContent</code> can't be mutated directly. This is by design, use <code>useSetFragment</code> for mutations.</p> <p>Having an identity makes optimistic updates easy. Superglue offers a <code>useSetFragment</code> hook that helps with mutations. Here's a more complex example.</p> <pre><code>const set = useSetFragment()\n\nset('userCart', (cartDraft) =&gt; {\n  // carDraft.availableCoupons is a fragment ref in the shape of {__id: 'availableCoupons'}\n  // you can use the fragment ref instead of a string\n  set(cartDraft.availableCoupons, (couponsDraft) =&gt; {\n    couponsDraft[0].title = \"super free shipping\"\n  })\n})\n</code></pre> <p>In the example, you recieve an immer draft of the fragment and you can mutate it however you want.</p>"},{"location":"humid/","title":"Humid","text":"<p>Humid is a lightweight wrapper around mini_racer used to generate Server Side Rendered (SSR) pages from your js-bundling builds. While it was built for React, it can work with any JS function that returns a HTML string.</p>"},{"location":"humid/#caution","title":"Caution","text":"<p>This project is in its early phases of development. Its interface, behavior, and name are likely to change drastically before a major version release.</p>"},{"location":"humid/#installation","title":"Installation","text":"<p>Add Humid to your Gemfile.</p> <pre><code>gem 'humid'\n</code></pre> <p>For source-map support, also add</p> <pre><code>yarn add source-map-support\n</code></pre>"},{"location":"humid/#configuration","title":"Configuration","text":"<p>Add an initializer to configure</p> <pre><code>Humid.configure do |config|\n  # Path to your build file located in `app/assets/builds/`. You should use a\n  # separate build apart from your `application.js`.\n  #\n  # Required\n  config.application_path = Rails.root.join('app', 'assets', 'builds', 'server_rendering.js')\n\n  # Path to your source map file\n  #\n  # Optional\n  config.source_map_path = Rails.root.join('app', 'assets', 'builds', 'server_rendering.js.map')\n\n  # Raise errors if JS rendering failed. If false, the error will be\n  # logged out to Rails log and Humid.render will return an empty string\n  #\n  # Defaults to true.\n  config.raise_render_errors = Rails.env.development? || Rails.env.test?\n\n  # The logger instance.\n  # `console.log` and friends (`warn`, `error`) are delegated to\n  # the respective logger levels on the ruby side.\n  #\n  # Defaults to `Logger.new(STDOUT)`\n  config.logger = Rails.logger\n\n  # Options passed to mini_racer.\n  #\n  # Defaults to empty `{}`.\n  config.context_options = {\n    timeout: 1000,\n    ensure_gc_after_idle: 2000\n  }\nend\n\n# Capybara defines its own puma config which is set up to run a single puma process\n# with a thread pool. This ensures that a context gets created on that process.\nif Rails.env.test?\n  # Use single_threaded mode for Spring and other forked envs.\n  MiniRacer::Platform.set_flags! :single_threaded\n  Humid.create_context\nend\n</code></pre> <p>Then add to your <code>config/puma.rb</code></p> <pre><code>workers ENV.fetch(\"WEB_CONCURRENCY\") { 1 }\n\non_worker_boot do\n  Humid.create_context\nend\n\non_worker_shutdown do\n  Humid.dispose\nend\n</code></pre> <p>If you'd like support for source map support, you will need to 1. Add the following to your entry file, e.g, <code>server_rendering.js</code>. 2. set <code>config.source_map_path</code>.</p> <p><pre><code>require(\"source-map-support\").install({\n  retrieveSourceMap: filename =&gt; {\n    return {\n      url: filename,\n      map: readSourceMap(filename)\n    };\n  }\n});\n</code></pre> A sample webpack.config is available for reference.</p>"},{"location":"humid/#the-mini_racer-environment","title":"The mini_racer environment.","text":""},{"location":"humid/#functions-not-available","title":"Functions not available","text":"<p>The following functions are not available in the mini_racer environment</p> <ul> <li><code>setTimeout</code></li> <li><code>clearTimeout</code></li> <li><code>setInterval</code></li> <li><code>clearInterval</code></li> <li><code>setImmediate</code></li> <li><code>clearImmediate</code></li> </ul>"},{"location":"humid/#consolelog","title":"<code>console.log</code>","text":"<p><code>console.log</code> and friends (<code>info</code>, <code>error</code>, <code>warn</code>) are delegated to the respective methods on the configured logger.</p>"},{"location":"humid/#usage","title":"Usage","text":"<p>In your entry file, e.g, <code>server_rendering.js</code>, pass your HTML render function to <code>setHumidRenderer</code>. There is no need to require the function.</p> <pre><code>// Set a factory function that will create a new instance of our app\n// for each request.\nsetHumidRenderer((json) =&gt; {\n  const initialState = JSON.parse(json)\n\n  return ReactDOMServer.renderToString(\n    &lt;Application initialPage={initialState}/&gt;\n  )\n})\n</code></pre> <p>And finally call <code>render</code> from ERB.</p> <pre><code>&lt;%= Humid.render(initial_state).html_safe %&gt;\n</code></pre> <p>Instrumentation is included:</p> <pre><code>Completed 200 OK in 14ms (Views: 0.2ms | Humid SSR: 11.0ms | ActiveRecord: 2.7ms)\n</code></pre>"},{"location":"humid/#puma","title":"Puma","text":"<p><code>mini_racer</code> is thread safe, but not fork safe. To use with web servers that employ forking, use <code>Humid.create_context</code> only on forked processes. On production, There should be no context created on the master process.</p> <pre><code># Puma\non_worker_boot do\n  Humid.create_context\nend\n\non_worker_shutdown do\n  Humid.dispose\nend\n</code></pre>"},{"location":"humid/#server-side-libraries-that-detect-nodejs-envs","title":"Server-side libraries that detect node.js envs.","text":"<p>You may need webpacker to create aliases for server friendly libraries that can not detect the <code>mini_racer</code> environment. For example, in <code>webpack.config.js</code>.</p> <pre><code>...\n  resolve: {\n    alias: {\n      'html-dom-parser': path.resolve(__dirname, '../../node_modules/html-dom-parser/lib/html-to-dom-server')\n    }\n  }\n...\n</code></pre>"},{"location":"humid/#writing-universal-code","title":"Writing universal code","text":"<p>Vue has a resource on how to write universal code. Below are a few highlights that are important to keep in mind.</p>"},{"location":"humid/#state","title":"State","text":"<p>Humid uses a single context across multiple request. To avoid state pollution, we provide a factory function to <code>setHumidRenderer</code> that builds a new app instance on every call.</p> <p>This provides better isolation, but as it is still a shared context, polluting <code>global</code> is still possible. Be careful of modifying <code>global</code> in your code.</p>"},{"location":"humid/#missing-browser-apis","title":"Missing browser APIs","text":"<p>Polyfills and some libraries that depend on browser APIs will fail in the <code>mini_racer</code> environment because of missing browser APIs. Account for this by moving the <code>require</code> to <code>useEffect</code> in your component.</p> <pre><code>  useEffect(() =&gt; {\n    const svgPanZoom = require('svg-pan-zoom')\n    //...\n  }, [])\n</code></pre>"},{"location":"humid/#contributing","title":"Contributing","text":"<p>Please see CONTRIBUTING.md.</p>"},{"location":"humid/#license","title":"License","text":"<p>Humid is Copyright \u00a9 2021-2024 Johny Ho. It is free software, and may be redistributed under the terms specified in the LICENSE file.</p>"},{"location":"humid/#about-thoughtbot","title":"About thoughtbot","text":"<p>This repo is maintained and funded by thoughtbot, inc. The names and logos for thoughtbot are trademarks of thoughtbot, inc.</p> <p>We love open source software! See our other projects. We are available for hire.</p>"},{"location":"installation/","title":"Installation","text":"<p>Prerequisites</p> <p>To get started with Superglue, you'll need</p> <ul> <li>A javascript bundler. We'll assume esbuild with js-bundling, but you can also use vite.</li> <li><code>yarn</code></li> </ul> <p>Add the following to your Gemfile</p> <pre><code># Gemfile\ngem \"superglue\", \"2.0.0.alpha.8\"\n</code></pre> <p>Run bundle and the installation generator:</p> <pre><code>bundle\nrails g superglue:install\n</code></pre> <p>If you prefer typescript</p> <pre><code>rails g superglue:install --typescript\n</code></pre> <p>The above will generate the following files:</p> <pre><code>.\n\u2514\u2500 app/\n   \u2514\u2500 javascript/\n      \u251c\u2500 slices/\n      \u2502  \u251c\u2500 flash.js\n      |  \u2514\u2500 pages.js\n      \u251c\u2500 actions.js\n      \u251c\u2500 application.js\n      \u251c\u2500 application_visit.js\n      \u251c\u2500 page_to_page_mapping.js\n      \u2514\u2500 store.js\n</code></pre>"},{"location":"installation/#redux-toolkit","title":"Redux Toolkit","text":"<p>If you've ever encountered Redux then the files above may seem familiar to you. Superglue works as a complete and fully functional Redux Toolkit application. For the most part, all the functionality you would need resides in these files and you'll make minimum edits, but they are made available if you ever need greater control over state management.</p>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>We recommend getting familiar with the following files:</p> <ul> <li><code>application_visit.js</code> - Add custom functionality to Superglue navigation, e.g, progress bars.</li> <li><code>page_to_page_mapping.js</code> - Pairs your <code>props</code> files with your page components.</li> <li><code>flash.js</code> - Seamlessly, integrates with the Rails flash.</li> </ul> <p>For more information, visit the configuration section.</p>"},{"location":"installation/#scaffold","title":"Scaffold","text":"<p>If you'd like to dive right in, you can start with a scaffold:</p> <pre><code>rails g superglue:scaffold post body:string\n</code></pre> <p>If you prefer typescript</p> <pre><code>rails g superglue:scaffold post body:string --typescript\n</code></pre> <p>or proceed with a tutorial</p>"},{"location":"navigation-context/","title":"NavigationContext","text":"<p>In addition to <code>visit</code> and <code>remote</code>, the <code>NavigationContext</code> provides a few other methods and properties that are best decribed in the context of <code>navigateTo</code>.</p> <pre><code>import { NavigationContext } from '@thoughtbot/superglue'\n\nconst {\n  navigateTo,\n  visit,\n  remote,\n  pageKey,\n  search\n} = useContext(NavigationContext)\n</code></pre> <ul> <li> See complete reference      for <code>NavigationContext</code></li> </ul>"},{"location":"navigation-context/#navigateto","title":"<code>navigateTo</code>","text":"<p>Fundamentally, <code>visit</code> is responsible for <code>fetch</code>ing a page, saving it, and lastly use <code>navigateTo</code> to load the page, update the url, and swap the page component. The NavigationContext exposes <code>navigateTo</code> for you to use use independently. For example:</p> <pre><code>navigateTo('/posts')\n</code></pre> <p>Note</p> <p>The page must exist in the store, or <code>navigateTo</code> will throw a error. Use copyPage to prepopulate before navigating.</p> <p><code>navigateTo</code> is especially useful for optimistic navigation like local facted search and works best when combined with <code>search</code> and <code>pageKey</code> from the same NavigationContext, and the copyPage action.</p> <p>In this example, we'll assume we're on pageKey \"/posts\":</p> <pre><code>import { copyPage, NavigationContext } from '@thoughtbot/superglue'\nimport { myAppDispatch } from '@myJavascript/store'\n\n// In your component somewhere\nconst {\n  navigateTo,\n  pageKey,\n  search\n} = useContext(NavigationContext)\n\nconst nextPageKey = pageKey + \"?active=true\"\ndispatch(copyPage({from: pageKey, to: nextPageKey}))\n\n// On a click handler\nnavigateTo(nextPageKey, { action: 'push'})\n\n// later after navigation.\nconsole.log(search) // would return {active: \"true\"}\n</code></pre> <p>With the above, we're able to make use of the URL search param as a source of state. And by using <code>navigateTo</code>, we're able to filter local results while updating the URL.</p> <ul> <li> See complete reference      for <code>navigateTo</code></li> </ul>"},{"location":"page-response/","title":"The <code>PageResponse</code>","text":"<p>Superglue JSON responses come in 4 varieties. </p> <ul> <li><code>SaveResponse</code> The main response type used to persist the page state</li> <li><code>GraftResponse</code> Used by digging to update an existing page</li> <li><code>StreamResponse</code> Used for streaming responses</li> <li><code>StreamMessage</code> The message format used for Super Turbo Streams</li> </ul> <p>[superglue_rails] and its generators would build these responses for you. The following is for reference:</p>"},{"location":"page-response/#the-saveresponse","title":"The <code>SaveResponse</code>","text":"<p>Superglue expects your JSON responses to contain the following attributes. If you used Superglue's generators, this would be all set for you in <code>application.json.props</code>.</p> <pre><code>{\n  data: {\n    ...\n  },\n  componentIdentifier,\n  defers,\n  assets,\n  csrfToken,\n  action,\n  path,\n  renderedAt,\n  fragments,\n  restoreStrategy,\n  slices\n}\n</code></pre>"},{"location":"page-response/#data","title":"<code>data</code>","text":"<p>Your page's content. What you create with <code>index.json.props</code>, <code>show.json.props</code>, etc.</p>"},{"location":"page-response/#componentidentifier","title":"<code>componentIdentifier</code>","text":"<p>A <code>string</code> to instruct Superglue which component to render. The generated <code>application.json.props</code> will set this to the <code>active_template_virtual_path</code> (added by props_template), but you can customize this to fit your needs.</p> <pre><code># application.json.props\njson.componentIdentifier active_template_virtual_path\n</code></pre> <p>You can control which <code>componentIdentifier</code> will render which component in the <code>page_to_page_mapping.js</code>.</p> <ul> <li> See reference   for page_to_page_mapping.js</li> </ul>"},{"location":"page-response/#defers","title":"<code>defers</code>","text":"<p>The parts of your page that have been marked for deferment.</p>"},{"location":"page-response/#assets","title":"<code>assets</code>","text":"<p>An <code>array</code> of asset fingerprint <code>string</code>s. Used by Superglue to detect the need to refresh the browser due to new assets. You can control the refresh behavior in <code>application_visit.js</code>:</p> <pre><code>/**\n  * The assets fingerprints changed, instead of transitioning\n  * just go to the URL directly to retrieve new assets\n  */\nif (meta.needsRefresh) {\n  window.location.href = meta.pageKey\n  return meta\n}\n</code></pre>"},{"location":"page-response/#csrftoken","title":"<code>csrfToken</code>","text":"<p>The authenticity token that Superglue will use for non-GET request made by using <code>visit</code> or <code>remote</code> thunks. This includes forms that have the <code>data-sg-visit</code> or <code>data-sg-remote</code> attribute. </p> <p>Tip</p> <p>Form's build with form_props will also have their own CSRF_TOKEN generated</p>"},{"location":"page-response/#action","title":"<code>action</code>","text":"<p>Set to <code>savePage</code> for <code>SaveResponse</code></p>"},{"location":"page-response/#renderedat","title":"<code>renderedAt</code>","text":"<p>An UNIX timestamp representing the time the response was rendered.</p>"},{"location":"page-response/#fragments","title":"<code>fragments</code>","text":"<p>An <code>array</code> of paths identifying the location of all fragments in <code>data</code>. In <code>application.json.props</code> this is set to <code>json.fragments!</code>.</p>"},{"location":"page-response/#restorestrategy","title":"<code>restoreStrategy</code>","text":"<p>By specifying the restore strategy used (<code>fromCacheOnly</code>, <code>revisitOnly</code>, or <code>fromCacheAndRevisitInBackground</code>), you can control what superglue does when encountering the page again when pressing the back or forward browser navigation buttons.</p> <ul> <li><code>fromCacheAndRevisitInBackground</code> will transition to the cached page, then   issue a visit in the background, redirecting and replacing history if needed.   This is the option set in <code>application.json.props</code> when using the generators.</li> <li><code>revisitOnly</code> will always issue a visit request in the background before</li> <li><code>fromCacheOnly</code> will only restore the page from cache   transitioning</li> </ul>"},{"location":"page-response/#slices","title":"<code>slices</code>","text":"<p>An object merged with the <code>initialState</code> when implementing <code>buildStore</code> inside of <code>application.js</code>. You can use this as the initial state for redux slices. Take advantage of the <code>SAVE_RESPONSE</code> to continually update your slice every time superglue receives a new page request.</p>"},{"location":"page-response/#graftresponse","title":"<code>GraftResponse</code>","text":"<p>A response for when digging is used, i.e, <code>props_at</code> is part of the request parameter. The response is made of the following attributes:</p> <p>componentIdentifier, assets, csrfToken, fragments, defers, slices, renderedAt</p>"},{"location":"page-response/#data_1","title":"<code>data</code>","text":"<p>The found content node from digging</p>"},{"location":"page-response/#path","title":"<code>path</code>","text":"<p><code>path</code> is a keypath to the requested node. It would typically look like this: <code>data.metrics.pageVisits</code>. Superglue uses this path to immutably graft a node from the response to the client-side store. </p> <p>If a <code>fragment</code> is encountered while digging, we reset the path to an empty array and populate the <code>fragmentContext</code> before continuing.</p>"},{"location":"page-response/#fragmentcontext","title":"<code>fragmentContext</code>","text":"<p>Ultimately, the last id of the fragment that we encountered while digging for content. This is because fragments are denormalized.</p>"},{"location":"page-response/#action_1","title":"<code>action</code>","text":"<p><code>action</code> would be set to <code>graft</code> for <code>GraftResponse</code></p>"},{"location":"page-response/#streamresponse","title":"<code>StreamResponse</code>","text":"<p>Use for Super Turbo Stream responses to update fragments. The response is made of the following attributes:</p> <p>Note</p> <p>Deferments are disabled for StreamResponse and StreamMessage</p> <p>assets, csrfToken, fragments, slices, renderedAt</p>"},{"location":"page-response/#data_2","title":"<code>data</code>","text":"<p>An array of StreamMessages to be processed one at a time.</p>"},{"location":"page-response/#action_2","title":"<code>action</code>","text":"<p><code>action</code> would be set to <code>handleStreamResponse</code> for <code>StreamResponse</code></p>"},{"location":"page-response/#streammessage","title":"<code>StreamMessage</code>","text":"<p>The format used for Super Turbo Streams.</p>"},{"location":"page-response/#data_3","title":"<code>data</code>","text":"<p>The content rendered by a partial.</p>"},{"location":"page-response/#fragmentids","title":"<code>fragmentIds</code>","text":"<p>A list of <code>fragmentIds</code> that the <code>data</code> targets.</p>"},{"location":"page-response/#handler","title":"<code>handler</code>","text":"<p>One of <code>append</code>, <code>prepend</code>, or <code>save</code></p>"},{"location":"page-response/#options","title":"<code>options</code>","text":"<p>Additional options passed to the handler function</p>"},{"location":"performance/","title":"Performance","text":"<p>Superglue handles performance on two fronts:</p>"},{"location":"performance/#frontend","title":"Frontend","text":"<p>On the frontend, Superglue has <code>useContent</code> which uses fragment-based dependency tracking for reactivity. Components only re-render when the current page or specific fragments they consume actually change, not when any part of the global state updates.</p> <p>For example:</p> <pre><code>  {\n    pages: {\n      \"/current-page\": {\n        data: {\n          \"title\": \"Hello\",\n          \"cart\": { \"__id\": \"userCart\" }  // Fragment reference\n        }\n      }\n    },\n    fragments: {\n      \"userCart\": {\n        \"items\": [\n          { \"id\": 1, \"name\": \"Widget\", \"price\": 19.99, \"quantity\": 2 },\n          { \"id\": 2, \"name\": \"Gadget\", \"price\": 29.99, \"quantity\": 1 }\n        ],\n        \"totalCost\": 69.97,\n        \"itemCount\": 3\n      }\n    }\n  }\n</code></pre> <pre><code>const content = useContent()\n\n&lt;h1&gt;{content.title}&lt;/h1&gt;\n\n&lt;p&gt;Num of items in cart&lt;/p&gt;\n&lt;p&gt;{content.cart.items.length}&lt;/p&gt;\n</code></pre> <p>By accessing <code>content.cart</code>, <code>useContent</code> will track that fragment's change and update the component where the hook is used when appropriate.</p>"},{"location":"performance/#preventing-over-rendering-with-fragment-refs","title":"Preventing over-rendering with fragment refs","text":"<p>Sometimes we don't want to the dependency to be tracked. This is especially true if we're just passing data off to another component.</p> <pre><code>const content = useContent()\n\n&lt;h1&gt;{content.title}&lt;/h1&gt;\n&lt;SlidingCart cart={content.cart} /&gt;\n</code></pre> <p>The above would cause the parent and child components to rerender if <code>userCart</code> was updated. What we want here is for the <code>SlidingCart</code> component to update without the parent component updating. We can use Superglue's <code>unproxy</code>:</p> <pre><code>import {unproxy} from '@thoughtbot/superglue'\n\nconst content = useContent()\nconst rawContent = unproxy(content)\n\n&lt;h1&gt;{content.title}&lt;/h1&gt;\n&lt;SlidingCart cartRef={rawContent.cart} /&gt;\n</code></pre> <p>and use <code>useContent</code> in the child component to set up its own dependency tracking:</p> <pre><code>const SlidingCart = (cartRef) =&gt; {\n  const cart = useContent(cartRef)\n}\n</code></pre> <p>Now if the <code>userCart</code> fragment updates, only the <code>SlidingCart</code> component will update.</p>"},{"location":"performance/#stable-references-with-unproxy","title":"Stable references with <code>unproxy</code>","text":"<p>When you need stable references for React.memo, referential equality, or dependency arrays, use <code>unproxy</code> to get the raw value behind the proxy:</p> <pre><code>import { unproxy } from '@thoughtbot/superglue'\n\nconst content = useContent()\nconst rawCart = unproxy(content.cart)\n\nconst memoizedValue = useMemo(() =&gt; {\n  // An expensive calculation\n}, [rawCart]);\n</code></pre> <p>Its also useful in <code>useEffect</code> dependencies</p> <pre><code>useEffect(() =&gt; {\n  // side effect\n}, [rawCart]) \n</code></pre>"},{"location":"performance/#backend","title":"Backend","text":"<p>On the backend, <code>props</code> are shaped with props_template. Its one of the fastest json builders in the rubyverse and has been used in production to speed up API rendering times. </p>"},{"location":"props-template/","title":"PropsTemplate","text":"<p>PropsTemplate is a direct-to-Oj, JBuilder-like DSL for building JSON. It has support for Russian-Doll caching, layouts, and can be queried by giving the root a key path.</p> <p></p> <p>It's fast.</p> <p>PropsTemplate bypasses the steps of hash building and serializing that other libraries perform by using Oj's <code>StringWriter</code> in <code>rails</code> mode.</p> <p></p> <p>Caching is fast too.</p> <p>While other libraries spend time unmarshaling, merging hashes, and serializing to JSON; PropsTemplate simply takes the cached string and uses Oj's push_json.</p>"},{"location":"props-template/#example","title":"Example:","text":"<p>PropsTemplate is very similar to JBuilder, and selectively retains some conveniences and magic.</p> <pre><code>json.flash flash.to_h\n\njson.menu do\n  json.currentUser do\n    json.email current_user.email\n    json.avatar current_user.avatar\n    json.inbox current_user.messages.count\n  end\nend\n\njson.dashboard(defer: :auto) do\n  sleep 5\n  json.complexPostMetric 500\nend\n\njson.posts do\n  page_num = params[:page_num]\n  paged_posts = @posts.page(page_num).per(20)\n\n  json.list do\n    json.array! paged_posts, key: :id do |post|\n      json.id post.id\n      json.description post.description\n      json.commentsCount post.comments.count\n      json.editPath edit_post_path(post)\n    end\n  end\n\n  json.paginationPath posts_path\n  json.current pagedPosts.current_page\n  json.total @posts.count\nend\n\njson.footer partial: 'shared/footer' do\nend\n</code></pre>"},{"location":"props-template/#installation","title":"Installation","text":"<pre><code>gem 'props_template'\n</code></pre> <p>and run <code>bundle</code>.</p> <p>Optionally add the core ext to an initializer if you want to dig into your templates.</p> <pre><code>require 'props_template/core_ext'\n</code></pre> <p>And create a file in your <code>app/views</code> folder like so:</p> <pre><code># app/views/posts/index.json.props\n\njson.greetings \"hello world\"\n</code></pre> <p>You can also add a layout.</p>"},{"location":"props-template/#api","title":"API","text":""},{"location":"props-template/#jsonset-or-jsonyour-key-here","title":"json.set! or json.\\&lt;your key here&gt;","text":"<p>Defines the attribute or structure. All keys are not formatted by default. See Change Key Format to change this behavior.</p> <pre><code>json.set! :authorDetails, {...options} do\n  json.set! :firstName, 'David'\nend\n\n# or\n\njson.authorDetails, {...options} do\n  json.firstName 'David'\nend\n\n\n# =&gt; {\"authorDetails\": { \"firstName\": \"David\" }}\n</code></pre> <p>The inline form defines key and value</p> Parameter Notes key A json object key value A value <pre><code>json.set! :firstName, 'David'\n\n# or\n\njson.firstName 'David'\n\n# =&gt; { \"firstName\": \"David\" }\n</code></pre> <p>The block form defines key and structure</p> Parameter Notes key A json object key options Additional options block Additional <code>json.set!</code>s or <code>json.array!</code>s <pre><code>json.set! :details do\n  #\u00a0...\nend\n\nor\n\njson.details do\n  #\u00a0...\nend\n</code></pre> <p>The difference between the block form and inline form is   1. The block form is an internal node. Functionality such as Partials,   Deferment and other options are only available on the   block form.   2. The inline form is considered a leaf node, and you can only dig   for internal nodes.</p>"},{"location":"props-template/#jsonextract","title":"json.extract!","text":"<p>Extracts attributes from object or hash in 1 line</p> <pre><code># without extract!\njson.id user.id\njson.email user.email\njson.firstName user.first_name\n\n# with extract!\njson.extract! user, :id, :email, :first_name\n\n# =&gt; {\"id\" =&gt; 1, \"email\" =&gt; \"email@gmail.com\", \"first_name\" =&gt; \"user\"}\n\n# with extract! with key transformation\njson.extract! user, :id, [:first_name, :firstName], [:last_name, :lastName]\n\n# =&gt; {\"id\" =&gt; 1, \"firstName\" =&gt; \"user\", \"lastName\" =&gt; \"last\"}\n</code></pre> <p>The inline form defines object and attributes</p> Parameter Notes object An object attributes A list of attributes"},{"location":"props-template/#jsonarray","title":"json.array!","text":"<p>Generates an array of json objects.</p> <pre><code>collection = [ {name: 'john'}, {name: 'jim'} ]\n\njson.details do\n  json.array! collection, {...options} do |person|\n    json.firstName person[:name]\n  end\nend\n\n# =&gt; {\"details\": [{\"firstName\": 'john'}, {\"firstName\": 'jim'} ]}\n</code></pre> Parameter Notes collection A collection that optionally responds to <code>member_at</code> and <code>member_by</code> options Additional options <p>To support digging, any list passed to <code>array!</code> MUST implement <code>member_at(index)</code> and <code>member_by(attr, value)</code>.</p> <p>For example, if you were using a delegate:</p> <pre><code>class ObjectCollection &lt; SimpleDelegator\n  def member_at(index)\n    at(index)\n  end\n\n  def member_by(attr, val)\n    find do |ele|\n      ele[attr] == val\n    end\n  end\nend\n</code></pre> <p>Then in your template:</p> <pre><code>data = ObjectCollection.new([\n  {id: 1, name: 'foo'},\n  {id: 2, name: 'bar'}\n])\n\njson.array! data do\n  #\u00a0...\nend\n</code></pre> <p>Similarly for ActiveRecord:</p> <pre><code>class ApplicationRecord &lt; ActiveRecord::Base\n  def self.member_at(index)\n    offset(index).limit(1).first\n  end\n\n  def self.member_by(attr, value)\n    find_by(Hash[attr, val])\n  end\nend\n</code></pre> <p>Then in your template:</p> <pre><code>json.array! Post.all do\n  #\u00a0...\nend\n</code></pre>"},{"location":"props-template/#array-core-extension","title":"Array core extension","text":"<p>For convenience, PropsTemplate includes a core_ext that adds these methods to <code>Array</code>. For example:</p> <pre><code>require 'props_template/core_ext'\ndata = [\n  {id: 1, name: 'foo'},\n  {id: 2, name: 'bar'}\n]\n\njson.posts\n  json.array! data do\n    # ...\n  end\nend\n</code></pre> <p>PropsTemplate does not know what the elements are in your collection. The example above will be fine for digging by index, but will raise a <code>NotImplementedError</code> if you query by attribute. You may still need to implement <code>member_by</code>.</p>"},{"location":"props-template/#jsondeferred","title":"json.deferred!","text":"<p>Returns all deferred nodes used by the deferment option.</p> <p>Note This is a SuperglueJS specific functionality and is used in <code>application.json.props</code> when first running <code>rails superglue:install:web</code></p> <pre><code>json.deferred json.deferred!\n\n# =&gt; [{url: '/some_url?props_at=outer.inner', path: 'outer.inner', type: 'auto'}]\n</code></pre> <p>This method provides metadata about deferred nodes to the frontend (SuperglueJS) to fetch missing data in a second round trip.</p>"},{"location":"props-template/#jsonfragments","title":"json.fragments!","text":"<p>Returns all fragment nodes used by the partial fragments option.</p> <p><code>ruby json.fragments json.fragments!</code></p> <p>Note This is a SuperglueJS specific functionality and is used in <code>application.json.props</code> when first running <code>rails superglue:install:web</code></p>"},{"location":"props-template/#options","title":"Options","text":"<p>Options Functionality such as Partials, Deferments, and Caching can only be set on a block. It is normal to see empty blocks.</p> <pre><code>json.post(partial: 'blog_post') do\nend\n</code></pre>"},{"location":"props-template/#partials","title":"Partials","text":"<p>Partials are supported. The following will render the file <code>views/posts/_blog_posts.json.props</code>, and set a local variable <code>post</code> assigned with @post, which you can use inside the partial.</p> <pre><code>json.one_post partial: [\"posts/blog_post\", locals: {post: @post}] do\nend\n</code></pre> <p>Usage with arrays:</p> <pre><code># The `as:` option is supported when using `array!`\n# Without `as:` option you can use blog_post variable (name is based on partial's name) inside partial\n\njson.posts do\n  json.array! @posts, partial: [\"posts/blog_post\", locals: {foo: 'bar'}, as: 'post'] do\n  end\nend\n</code></pre> <p>Rendering partials without a key is also supported using <code>json.partial!</code>, but use sparingly! <code>json.partial!</code> is not optimized for collection rendering and may cause performance problems. It's best used for things like a shared header or footer.</p> <p>Do:</p> <pre><code>json.partial! partial: \"header\", locals: {user: @user} do\nend\n</code></pre> <p>or</p> <pre><code>json.posts do\n  json.array! @posts, partial: [\"posts/blog_post\", locals: {post: @post}] do\n  end\nend\n</code></pre> <p>Do NOT:</p> <pre><code>@post.each do |post|\n  json.partial! partial: \"post\", locals: {post: @post} do\n  end\nend\n</code></pre>"},{"location":"props-template/#partial-fragments","title":"Partial Fragments","text":"<p>Note This is a SuperglueJS specific functionality.</p> <p>A fragment identifies a partial output across multiple pages. It can be used to update cross cutting concerns like a header bar.</p> <pre><code># index.json.props\njson.header partial: [\"profile\", fragment: \"header\"] do\nend\n\n# _profile.json.props\njson.profile do\n  json.address do\n    json.state \"New York City\"\n  end\nend\n</code></pre> <p>When using fragments with Arrays, the argument MUST be a lamda:</p> <pre><code>require 'props_template/core_ext'\n\njson.array! ['foo', 'bar'], partial: [\"footer\", fragment: -&gt;(x){ x == 'foo'}] do\nend\n</code></pre>"},{"location":"props-template/#caching","title":"Caching","text":"<p>Caching is supported on internal nodes only. This limitation is what makes it possible to for props_template to forgo marshalling/unmarshalling and simply use push_json.</p> <p>Usage:</p> <pre><code>json.author(cache: \"some_cache_key\") do\n  json.firstName \"tommy\"\nend\n\n# or\n\njson.profile(cache: \"cachekey\", partial: [\"profile\", locals: {foo: 1}]) do\nend\n\n# or nest it\n\njson.author(cache: \"some_cache_key\") do\n  json.address(cache: \"some_other_cache_key\") do\n    json.zip 11214\n  end\nend\n</code></pre> <p>When used with arrays, PropsTemplate will use <code>Rails.cache.read_multi</code>.</p> <pre><code>require 'props_template/core_ext'\n\nopts = { cache: -&gt;(i){ ['a', i] } }\n\njson.array! [4,5], opts do |x|\n  json.top \"hello\" + x.to_s\nend\n\n# or on arrays with partials\n\nopts = { cache: (-&gt;(d){ ['a', d.id] }), partial: [\"blog_post\", as: :blog_post] }\n\njson.array! @options, opts do\nend\n</code></pre>"},{"location":"props-template/#deferment","title":"Deferment","text":"<p>You can defer rendering of expensive nodes in your content tree using the <code>defer: :manual</code> option. Behind the scenes PropsTemplates will no-op the block entirely and replace the value with a placeholder. A common use case would be tabbed content that does not load until you click the tab.</p> <p>When your client receives the payload, you may issue a second request to the same endpoint to fetch any missing nodes. See digging</p> <p>There is also a <code>defer: :auto</code> option that you can use with SuperglueJS. SuperglueJS will use the metadata from <code>json.deferred!</code> to issue a <code>remote</code> dispatch to fetch the missing node and immutably graft it at the appropriate keypath in your Redux store.</p> <p>Usage:</p> <pre><code>json.dashboard(defer: :manual) do\n  sleep 10\n  json.someFancyMetric 42\nend\n\n\n# or you can explicitly pass a placeholder\n\njson.dashboard(defer: [:manual, placeholder: {}]) do\n  sleep 10\n  json.someFancyMetric 42\nend\n</code></pre> <p>A auto option is available:</p> <p>Note This is a SuperglueJS specific functionality.</p> <pre><code>json.dashboard(defer: :auto) do\n  sleep 10\n  json.someFancyMetric 42\nend\n</code></pre> <p>Finally in your <code>application.json.props</code>:</p> <pre><code>json.defers json.deferred!\n</code></pre>"},{"location":"props-template/#working-with-arrays","title":"Working with arrays","text":"<p>The default behavior for deferments is to use the index of the collection to identify an element.</p> <p>Note If you are using this library with SuperglueJS, the <code>:auto</code> option will generate <code>?props_at=a.b.c.0.title</code> for <code>json.deferred!</code>.</p> <p>If you wish to use an attribute to identify the element. You must:</p> <ol> <li> <p>Use the <code>:key</code> option on <code>json.array!</code>. This key refers to an attribute on your collection item, and is used for <code>defer: :auto</code> to generate a keypath for SuperglueJS. If you are NOT using SuperglueJS, you do not need to do this.</p> </li> <li> <p>Implement <code>member_at</code>, on the collection. This will be called by PropsTemplate to when digging</p> </li> </ol> <p>For example:</p> <pre><code>require 'props_template/core_ext'\ndata = [\n  {id: 1, name: 'foo'},\n  {id: 2, name: 'bar'}\n]\n\njson.posts\n  json.array! data, key: :some_id do |item|\n    # By using :key, props_template will append `json.some_id item.some_id`\n    # automatically\n\n    json.contact(defer: :auto) do\n      json.address '123 example drive'\n    end\n  end\nend\n</code></pre> <p>If you are using SuperglueJS, it will automatically kick off <code>remote(?props_at=posts.some_id=1.contact)</code> and <code>remote(?props_at=posts.some_id=2.contact)</code>.</p>"},{"location":"props-template/#digging","title":"Digging","text":"<p>PropsTemplate has the ability to walk the tree you build, skipping execution of untargeted nodes. This feature is useful for selectively updating your frontend state.</p> <pre><code>traversal_path = ['data', 'details', 'personal']\n\njson.data(dig: traversal_path) do\n  json.details do\n    json.employment do\n      # ...more stuff\n    end\n\n    json.personal do\n      json.name 'james'\n      json.zipCode 91210\n    end\n  end\nend\n\njson.footer do\n  # ...\nend\n</code></pre> <p>PropsTemplate will walk depth first, walking only when it finds a matching key, then executes the associated block, and repeats until the node is found. The above will output:</p> <pre><code>{\n  \"data\": {\n    \"name\": 'james',\n    \"zipCode\": 91210\n  },\n  \"footer\": {\n    ...\n  }\n}\n</code></pre> <p>Digging only works with blocks, and will NOT work with Scalars (\"leaf\" values). For example:</p> <pre><code>traversal_path = ['data', 'details', 'personal', 'name'] # &lt;- not found\n\njson.data(dig: traversal_path) do\n  json.details do\n    json.personal do\n      json.name 'james'\n    end\n  end\nend\n</code></pre>"},{"location":"props-template/#nodes-that-do-not-exist","title":"Nodes that do not exist","text":"<p>Nodes that are not found will remove the branch where digging was enabled on.</p> <pre><code>traversal_path = ['data', 'details', 'does_not_exist']\n\njson.data(dig: traversal_path) do\n  json.details do\n    json.personal do\n      json.name 'james'\n    end\n  end\nend\n\njson.footer do\n  # ...\nend\n</code></pre> <p>The above will render:</p> <pre><code>{\n  \"footer\": {\n    ...\n  }\n}\n</code></pre>"},{"location":"props-template/#layouts","title":"Layouts","text":"<p>A single layout is supported. To use, create an <code>application.json.props</code> in <code>app/views/layouts</code>. Here's an example:</p> <pre><code>json.data do\n  # template runs here.\n  yield json\nend\n\njson.header do\n  json.greeting \"Hello\"\nend\n\njson.footer do\n  json.greeting \"Hello\"\nend\n\njson.flash flash.to_h\n</code></pre> <p>NOTE PropsTemplate inverts the usual Rails rendering flow. PropsTemplate will render Layout first, then the template when <code>yield json</code> is used.</p>"},{"location":"props-template/#layouts-in-api-only-rails-apps","title":"Layouts in API-only Rails apps","text":"<p>If your controllers inherit from <code>ActionController::API</code> (typical in API-only Rails apps), the layout feature won\u2019t work out of the box, because <code>ActionController::API</code> does not include layout support.</p> <p>To enable layout rendering, you can include <code>ActionView::Layouts</code> manually, then use <code>layout \"your_own_layout\"</code> as usual:</p> <pre><code>module Api\n  class BaseController &lt; ActionController::API\n    include ActionView::Layouts\n\n    layout \"api\"\n  end\nend\n</code></pre> <p>Without this, Rails will silently skip the layout, which can be tricky to notice.</p>"},{"location":"props-template/#change-key-format","title":"Change key format","text":"<p>By default, keys are not formatted. This is intentional. By being explicit with your keys, it makes your views quicker and more easily diggable when working in JavaScript land.</p> <p>If you must change this behavior, override it in an initializer and cache the value:</p> <pre><code># default behavior\nProps::BaseWithExtensions.class_eval do\n  # json.firstValue \"first\"\n  # json.second_value \"second\"\n  #\n  # -&gt; { \"firstValue\" =&gt; \"first\", \"second_value\" =&gt; \"second\" }\n  def key_format(key)\n    key.to_s\n  end\nend\n\n# camelCased behavior\nProps::BaseWithExtensions.class_eval do\n  # json.firstValue \"first\"\n  # json.second_value \"second\"\n  #\n  # -&gt; { \"firstValue\" =&gt; \"first\", \"secondValue\" =&gt; \"second\" }\n  def key_format(key)\n    @key_cache ||= {}\n    @key_cache[key] ||= key.to_s.camelize(:lower)\n    @key_cache[key]\n  end\n\n  def result!\n    result = super\n    @key_cache = {}\n    result\n  end\nend\n\n# snake_cased behavior\nProps::BaseWithExtensions.class_eval do\n  # json.firstValue \"first\"\n  # json.second_value \"second\"\n  #\n  # -&gt; { \"first_value\" =&gt; \"first\", \"second_value\" =&gt; \"second\" }\n  def key_format(key)\n    @key_cache ||= {}\n    @key_cache[key] ||= key.to_s.underscore\n    @key_cache[key]\n  end\n\n  def result!\n    result = super\n    @key_cache = {}\n    result\n  end\nend\n</code></pre>"},{"location":"props-template/#escape-mode","title":"Escape mode","text":"<p>PropsTemplate runs OJ with <code>mode: :rails</code>, which escapes HTML and XML characters such as <code>&amp;</code> and <code>&lt;</code>.</p>"},{"location":"props-template/#contributing","title":"Contributing","text":"<p>See the CONTRIBUTING document. Thank you, contributors!</p>"},{"location":"props-template/#special-thanks","title":"Special Thanks","text":"<p>Thanks to turbostreamer, oj, and jbuilder for the inspiration.</p>"},{"location":"rails-utils/","title":"Rails utils","text":""},{"location":"rails-utils/#rendering-defaults","title":"Rendering defaults","text":"<p>Superglue typically requires 3 templates.</p> <pre><code>app/views/\n  posts/\n    index.html.erb # duplicated\n    index.jsx\n    index.json.props\n  users/\n    index.html.erb # duplicated\n    index.jsx\n    index.json.props\n</code></pre> <p>Use <code>use_jsx_rendering_defaults</code> and <code>superglue_template</code> for cleaner directories.</p> <pre><code>class PostsController &lt; ApplicationController\n  before_action :use_jsx_rendering_defaults\n  superglue_template \"application/superglue\" #defaults to application/superglue\nend\n</code></pre> <p>Warning</p> <p>The <code>file</code>, <code>partial</code>, <code>body</code>, <code>plain</code>, <code>html</code>, <code>inline</code> will not work with <code>render</code> when using <code>before_action :use_jsx_rendering_defaults</code> callback. Make use of <code>:only</code> and <code>:except</code> to narrow down its usage.</p> <p>Which will allow you to deduplicate the files:</p> <pre><code>app/views\n  application/\n    superglue.html.erb\n  posts/\n    index.jsx\n    index.json.props\n  users/\n    index.jsx\n    index.json.props\n</code></pre> <p>and omit <code>props</code> files for cases when there is no content.</p> <pre><code>app/views\n  application/\n    superglue.html.erb\n  about/\n    index.jsx\n</code></pre>"},{"location":"rails-utils/#redirect_back_with_props_at","title":"<code>redirect_back_with_props_at</code>","text":"<p>A helper to help retain the <code>props_at</code> parameter as part of the redirect <code>location</code>. This helper has the same method signature as Rails own <code>redirect_back</code>.</p> <pre><code>def create\n  redirect_back_with_props_at fallback_url: '/'\nend\n</code></pre>"},{"location":"rails-utils/#setting-the-content-location","title":"Setting the content location","text":"<p>You can override the URL Superglue uses to display on the address bar and store your response directly from the server using <code>content-location</code>. This is optional. For example:</p> <pre><code>def create\n  @post = Post.new(post_params)\n\n  if @post.save\n    redirect_to @post, notice: 'Post was successfully created.'\n  else\n    response.set_header(\"content-location\", new_post_path)\n    render :new\n  end\nend\n</code></pre>"},{"location":"redux-state-shape/","title":"The store shape","text":"<p>Superglue occupies 3 nodes in a redux state tree:</p> <pre><code>{\n  superglue: {\n    csrfToken,\n    currentPageKey,\n    pathname,\n    search,\n    hash,\n  },\n  pages: {\n    '/dashboard': { ..page received from `/dashboard`.. },\n    '/posts?foo=123': {... page received from `/posts?foo=123` },\n  },\n  fragments: {}\n}\n</code></pre>"},{"location":"redux-state-shape/#superglue","title":"<code>superglue</code>","text":"<p>The <code>superglue</code> node contains information about your application that you may find useful. You may read from this store, but do not write.</p>"},{"location":"redux-state-shape/#pages","title":"<code>pages</code>","text":"<p>The <code>pages</code> node is where rendered pages live. It's a hash where the keys are the pathname + query of your url, known throughout the documentation as <code>pageKey</code>, and the values are received JSON responses.</p> <p>The <code>pageKey</code> does not include the location hash of your URL. This is by design, Superglue ignores the location hash and falls back to browser defaults. So while you can visit <code>/posts#foo</code> and <code>/posts</code> in the browser, Superglue will store both as <code>/posts</code>.</p>"},{"location":"redux-state-shape/#fragments","title":"<code>fragments</code>","text":"<p>Fragments are rendered Rails partials with an identity. They're created when a response is recieved. Superglue takes the payload and denormalizes it into fragments and fragment refs.</p> <pre><code>  { \n    ...,\n    pages: {\n      \"/messages\": {\n        data: {\n          title: \"Chat Room\",\n          messages: { __id: \"chat_messages\" },  // Fragment reference\n          user: { __id: \"current_user\" }\n        }\n      }\n    },\n    fragments: {\n      \"chat_messages\": [\n        { id: 1, content: \"Hello\", author: \"John\" },\n        { id: 2, content: \"Hi there\", author: \"Jane\" }\n      ],\n      \"current_user\": {\n        name: \"John Doe\",\n        avatar: \"/avatars/john.jpg\"\n      }\n    }\n  }\n</code></pre>"},{"location":"redux/","title":"Redux","text":"<p>If you have a usecase that requires complex updates to frontend state, you can bring your own state management, or use redux-toolkit slices. Superglue includes a few useful redux actions that you can use with redux slices if you decide to create custom slices.</p>"},{"location":"redux/#flashjs","title":"<code>flash.js</code>","text":"<p>Your first custom slice will be a <code>flash</code> slice. Superglue's installation generator adds this to your project to integrate with Rail's flash.</p> <p>To start off, the slice is shaped exactly like the Rails flash.</p> <pre><code>{\n  alert: \"Something went wrong\",\n  success: \"You've logged in!\"\n}\n</code></pre> <p>and works with the BEFORE_VISIT and RECEIVE_RESPONSE actions to </p> <ul> <li>Clear the flash before each visit or <code>data-sg-visit</code> visit.</li> <li>Merge any new flashes recieved from any page response.</li> </ul> <p>You are encouraged to modify <code>flash.js</code></p> <p>While the above is a key string pair, in practice, the <code>flash.js</code> is  customized for any temporary props that would last as long as  <code>flash.now</code> or <code>flash</code>. Its useful for form errors, notifications, toasts, etc.</p> <p>For example, if you prefer a different shape, modify how the slice is received in your layout, <code>application.json.props</code></p> <pre><code>json.slices do\n  myFlash = flash.to_h.map { |key, value| {type: key.to_s, value: value} }\n  json.flash myFlash\nend\n</code></pre> <p>The <code>slices</code> key in <code>application.json.props</code> is a boundary for you to render state. Its commonly used to set the intial state of your slice, and update the slice when receiving a new page.</p>"},{"location":"redux/#usage","title":"Usage","text":"<p>The flash can be accessed using a selector</p> <pre><code>import { useSelector } from 'react-redux'\n\nconst flash = useSelector((state) =&gt; state.flash)\nconsole.log(flash.success)\n</code></pre> <p>then use the flash as you would normally in a controller</p> <pre><code>def create\n  flash[:success] = \"Post was saved!\"\nend\n</code></pre>"},{"location":"redux/#initialstate","title":"initialState","text":"<p>You can render your slice's initial state in the slices <code>key</code> of the page response. This has been configured for you in the <code>application.json.props</code> layout.  It'll be merged with the <code>initialState</code> passed to your <code>buildStore</code> function in your application.js</p>"},{"location":"redux/#updating-your-slice-state","title":"Updating your slice state","text":"<p>If you receive new state for your slice from a subsequent page response, you can use <code>RECEIVE_RESPONSE</code> to update your slice. Its the same mechanism your <code>flash.js</code> slice uses to update the internal state whenever a page response is received. </p>"},{"location":"redux/#receive_response","title":"RECEIVE_RESPONSE","text":"<pre><code>{\n  type: \"@@superglue/RECEIVE_RESPONSE\",\n  payload: {\n    pageKey: \"/posts\",\n    response: {...the page response},\n  },\n}\n</code></pre>"},{"location":"redux/#other-actions","title":"Other actions","text":"<p>There are also other actions that gets dispatched during lifecycle events that you can make use of.</p> <p>To higlight a few:</p>"},{"location":"redux/#before_fetch","title":"BEFORE_FETCH","text":"<p><code>BEFORE_FETCH</code> - Action created before a before a fetch is called.</p> <pre><code>{\n  type: \"@@superglue/BEFORE_FETCH\",\n  payload: [..array args that are passed to fetch]\n}\n</code></pre>"},{"location":"redux/#before_visit","title":"BEFORE_VISIT","text":"<p><code>BEFORE_VISIT</code> - Same as above, but called only for a <code>visit</code> action. Your <code>flash</code> slice has been setup to use this to clear the flash before navigating.</p> <pre><code>{\n  type: \"@@superglue/BEFORE_VISIT\",\n  payload: [..array args that are passed to fetch]\n}\n</code></pre>"},{"location":"redux/#before_remote","title":"BEFORE_REMOTE","text":"<p><code>BEFORE_REMOTE</code> - Same as above, but called only a <code>remote</code> action.</p> <pre><code>{\n  type: \"@@superglue/BEFORE_REMOTE\",\n  payload: [..array args that are passed to fetch]\n}\n</code></pre>"},{"location":"redux/#save_response","title":"SAVE_RESPONSE","text":"<p><code>SAVE_RESPONSE</code> is called before a response is saved as a page.</p> <pre><code>{\n  type: \"@@superglue/SAVE_RESPONSE\",\n  payload: {\n    pageKey: \"/posts\",\n    page: {...the page response},\n  },\n}\n</code></pre>"},{"location":"requests/","title":"Requests","text":"<p>If you prefer to navigate using Javascript, or need more functionality than what UJS offers, Superglue comes with two functions built around <code>fetch</code>, <code>visit</code> and <code>remote</code>. These are wrapped with your own implementation in application_visit.js and can be accessed via the NavigationContext.</p> <p>Tip</p> <p>Superglue does not come with a <code>&lt;Link&gt;</code> component. Instead we encourage you to build one that is unique to your projects needs using the functions provided by the NavigationContext.</p> <pre><code>import { NavigationContext } from '@thoughtbot/superglue';\n\nconst { remote, visit } = useContext(NavigationContext)\n</code></pre>"},{"location":"requests/#visit","title":"visit","text":"<p><code>visit</code> is designed to mimic browser navigation for clicks and form submissions without the impact of a full page reload. There can be only one visit at a time and when successful <code>visit</code> will swap out the current page component for the next one.</p> <p>At glance it looks like this:</p> <pre><code>sequenceDiagram\n    autonumber\n    Browser -&gt;&gt; Superglue: Click request to `/posts/new` intercepted\n    activate Superglue\n    Superglue --&gt;&gt; Server: Re-request with format JSON `/posts/new.json`\n    activate Server\n    Server --&gt;&gt; Superglue: `/posts/new.json` response\n    Superglue --&gt;&gt; Superglue: Save response and swap page components\n    deactivate Server\n    Superglue --&gt;&gt; Browser: Update browser history, scroll position\n    deactivate Superglue</code></pre> <p>Hint</p> <p>Its possible to modify the visit payload before it saves to the store. See the beforeSave callback.</p> <ul> <li> See complete reference      for <code>visit</code></li> </ul>"},{"location":"requests/#remote","title":"remote","text":"<p>Use <code>remote</code> when you want to asynchronously update parts of a page or save a page to the store without swapping the page component or change the browser history. Unlike visit, you can fire off as many async <code>remote</code> requests as you want.</p> <p>Hint</p> <p>Its possible to modify the remote payload before it saves to the store. See the beforeSave callback.</p> <p>At glance it looks like this:</p> <pre><code>sequenceDiagram\n  alt target default current page\n    autonumber\n    Browser -&gt;&gt; Superglue: Click request to `/posts/new` intercepted\n    activate Superglue\n    Superglue --&gt;&gt; Server: Re-request with format JSON `/posts/new.json`\n    activate Server\n    Server --&gt;&gt; Superglue: `/posts/new.json` response\n    Superglue --&gt;&gt; Superglue: Save response\n    Superglue --&gt;&gt; Browser: User on current page sees update\n    deactivate Server\n    deactivate Superglue\n  end</code></pre> <p>By default, <code>remote</code> derives a <code>pagekey</code> from the response to save the page. You can override this behavior and expliclity pass a <code>pageKey</code> option to target a different page in the store. If the user is not viewing the target page, they will not see an update.</p> <p>Warning</p> <p>The componentIdentifier from the page response MUST match the target page, otherwise remote will throw a <code>MismatchedComponentError</code> error. You can override this by using the <code>force: true</code> option. See the docs for details.</p> <pre><code>sequenceDiagram\n  alt target another page in the store\n    autonumber\n    Browser -&gt;&gt; Superglue: Click request to `/posts/new` intercepted\n    activate Superglue\n    Superglue --&gt;&gt; Server: Re-request with format JSON `/posts/new.json`\n    activate Server\n    Server --&gt;&gt; Superglue: `/posts/new.json` response\n    Superglue --&gt;&gt; Superglue: Save response or update target page\n    Note right of Browser: User does not see an update to the current page\n    deactivate Server\n    deactivate Superglue\n  end</code></pre> <ul> <li> See complete reference      for <code>remote</code></li> </ul> <ul> <li> See note      for differences between <code>remote</code> and <code>data-sg-remote</code></li> </ul> <p>Customizations</p> <p>You can modify the behavior of <code>visit</code> and <code>remote</code> functions globally from <code>application_visit.js</code>. If you need a global customization, e.g, progress bars, you can add them there.</p>"},{"location":"requests/#the-beforesave-callback","title":"The <code>beforeSave</code> callback","text":"<p>Alert</p> <p><code>beforeSave</code> looks deceptively simple, but is an advanced Supeglue feature. It requires</p> <ol> <li>Knowing how Fragments and FragmentRefs work, the first parameter passed to <code>beforeSave</code> is a proxy that lazily normalizes fragments.</li> <li>How to get the unproxied state.</li> <li>Knowing the shape of savePage or graft responses.</li> <li>Knowing how denormaliztion works </li> </ol> <p>Both <code>visit</code> and <code>remote</code> can be passed a <code>beforeSave</code> callback. This is your  opportunity to modify the incoming savePage or graft payload before it persists. Its ideal for features like infinite-scroll where you need to concatenate a list of results into an existing list:</p> <pre><code>const beforeSave = (prevPageProxy, receivedResponse) =&gt; {\n  receivedResponse.data.messages = [\n    prevPageProxy.data.messages,\n    ... receivedResponse.data.messages\n  ]\n\n  return receivedResponse \n}\n\nremote(\"/posts\", {beforeSave})\n</code></pre> <p>Warning</p> <p>If you are concatenating arrays in a <code>beforeSave</code> callback and using nesting Fragments like so:</p> <p><code>index.json.props</code> <pre><code>  json.posts(partial: [\"post_list\", fragment: \"posts_list\"]) do\n  end\n</code></pre></p> <p><code>_post_list.json.props</code> <pre><code>  json.array!(partial: [\"post\", fragment: -&gt;(post){\"post-#{post.id}\" }]) do\n  end\n</code></pre></p> <p><code>_post.json.props</code> <pre><code>  json.title post.id\n  json.body post.body\n</code></pre></p> <p>be sure to use the key to help Superglue identify fragments in the concatenated array.</p> <p><code>_post_list.json.props</code></p> <pre><code>- json.array!(partial: [\"post\", fragment: -&gt;(post){\"post-#{post.id}\" }]) do\n+ json.array!(partial: [\"post\", fragment: -&gt;(post){\"post-#{post.id}\" }, key: :id]) do\n  end\n</code></pre> <p>This will ensure that Superglue denormalizes the fragments properly.</p>"},{"location":"securing/","title":"Security","text":"<p>Superglue stores your content in memory. If you were to navigate using a normal HTML link or form that does a full page reload the state would be destroyed.</p> <p>Tip</p> <p>Superglue does store the following in History.state for convience:</p> <pre><code>export interface HistoryState {\n  /** Is always `true` so superglue can differentiate pages that have superglue enabled or not */\n  superglue: true\n  /** The scroll position X of the page*/\n  posX: number\n  /** The scroll position Y of the page*/\n  posY: number\n}\n</code></pre>"},{"location":"securing/#authentication","title":"Authentication","text":"<p>You can use any Rails authentication system; Devise, Authentication Zero, etc. Superglue leverages standard Rails patterns - routes, controllers, and views - making it friendly with the Rails ecosystem.</p>"},{"location":"securing/#logging-out","title":"Logging out","text":"<p>When implementing a logout button use a normal HTML link or form that does a full page reload. This will clear out Superglue's state in memory.</p> <p>\u2705 Do <pre><code>  &lt;a href=\"/users/logout\"&gt; Logout &lt;/a&gt;\n</code></pre></p> <p>\u274c Don't</p> <pre><code>  &lt;a data-sg-visit href=\"/users/logout\"&gt; Logout &lt;/a&gt;\n</code></pre>"},{"location":"securing/#navigational-formats","title":"Navigational formats","text":"<p>When working with Devise, be sure to enable <code>json</code> as a navigational format</p> <pre><code># config/initializers/devise.rb\nconfig.navigational_formats = [\"/\", :html, :json]\n</code></pre>"},{"location":"securing/#csrf-protection","title":"CSRF Protection","text":""},{"location":"securing/#forms","title":"Forms","text":"<p>Superglue comes with form_props to build forms. Like its Rails counterpart, <code>form_with</code>, <code>form_props</code> generates a CSRF token per form.</p> <p>For example, the below would create two forms with unique CSRF tokens each:</p> <pre><code>json.updateFormA do\n  form_props(model: @post) do |f|\n    f.submit\n  end\nend\n\njson.updateFormB do\n  form_props(model: @post) do |f|\n    f.submit\n  end\nend\n</code></pre>"},{"location":"securing/#remote-and-visit","title":"<code>remote</code> and <code>visit</code>","text":"<p>Both functions will use a CSRF token generated at the page level when used with a non-GET request. This CSRF token can be accessed from the state returned from the useSuperglue hook and gets updated on each page response received. You can also make use of this state for your own custom <code>fetch</code> calls.</p>"},{"location":"shaping/","title":"Shaping State","text":"<p>When building <code>.props</code> for your pages, it's useful to know that Superglue believes the server generally drives UI state. If you worked with <code>erb</code> files then you'll feel right at home. </p> <p>Let's take a familiar approach to shaping state:</p> <pre><code>&lt;header&gt;\n  Email: &lt;%= current_user.email %&gt;\n  First Name: &lt;%= current_user.first_name.capitalize %&gt; \n&lt;/header&gt;\n\n&lt;div&gt;\n  &lt;h2&gt;Post List&lt;/h2&gt;\n  &lt;%- @posts.each do |post| %&gt;\n    &lt;div&gt;\n      &lt;h3&gt;&lt;%= post.title.capitalize %&gt;&lt;/h3&gt;\n      &lt;p&gt;&lt;%= post.body %&gt;&lt;/p&gt;\n    &lt;/div&gt;\n  &lt;% end %&gt;\n&lt;/div&gt;\n\n&lt;div&gt;\n  &lt;h3&gt;Menu&lt;/h3&gt;\n  &lt;%= link_to \"Home\", root_path%&gt;\n&lt;div&gt;\n</code></pre> <p>The <code>.props</code> version of this is</p> <pre><code>json.header do\n  json.email current_user.email\n  json.firstName current_user.first_name\nend\n\njson.postList do\n  json.array! @posts do |post|\n    json.title post.title.capitalize\n    json.body post.body\n  end\nend\n\njson.menu do \n  json.homePath root_path\nend\n</code></pre> <p>Note</p> <p>Notice the convention of camelizing vs. non camelizing If you need to transform data, do it on the server side.</p> <p>\u2705 Do it in ruby land <pre><code>json.title @post.title.upcase\n</code></pre></p> <p>\u274c Not in JS Land <pre><code>const content = useContent()\nconst title = content.title.toUpperCase()\n</code></pre></p>"},{"location":"shaping/#why-ui-state","title":"Why UI state","text":"<p>Superglue encourages you to shape UI state on the server because</p> <ol> <li> <p>Ruby combined with Rails view heleprs is just as good, if not better, than Javascript at shaping state for React components. </p> </li> <li> <p>UI patterns are universal - headers, footers, a body with a list of items exist in every app. Business logic varies wildly, but these presentational structures remain constant. This creates immediate intuition; a developer can easily guess the shape of the store, and make close-to-correct assumptions on how to update the store without looking at any code.</p> </li> <li> <p>It's extremely productive with PropsTemplate. A keypath like props_at=data.content.barChart queries the server and grafts the response at the exact same location in your Redux state. This eliminates the traditional API dance - the path IS the query. Your component structure directly maps to your data fetching strategy. </p> </li> </ol>"},{"location":"shaping/#view-logic","title":"View logic","text":"<p>Conventional Rails wisdom discourages excessive view logic, but <code>.props</code> templates don't have the usual structural markup that you'd find with ERB templates. Its not uncommon to see more logic in your views.</p> <p>Note</p> <p>You can think of <code>.props</code> as a presentational layer for your React components. We keep most of the UI state on the server the simplify the amount of Javascript we need.</p> <pre><code>daily_events = @events\n  .order(:starts_at)\n  .group_by do |event|\n    event.start_date\n  end\n\nevent_dates = daily_events.keys\n\njson.rightMenu do\n  json.dailyLinks do\n    json.array! event_dates do |date|\n      json.text date.strftime(\"%A\")\n      json.href \"##{date}\"\n    end\n  end\n\n  json.isChecked !!params[:mine_only]\n  json.newEventPath new_plan_event_path\nend\n\njson.dailyEvents do\n  json.array! event_dates do |date|\n    json.id date.to_s\n    json.header date.strftime(\"%A\")\n\n    json.events do\n      json.array!(daily_events[date]) do |event|\n        json.starts_at event.starts_at\n        json.id event.id\n        json.name event.name\n        json.users event.users.map(&amp;:full_name).to_sentence\n\n        json.editPath edit_event_path(event)\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"shaping/#deferment-nodes","title":"Deferment nodes","text":"<p><code>props_template</code>can selectively load parts of your JSON tree on demand using [digging] improving initial page load performance. To make the most of this feature, defer expensive operations until they're needed.</p> <p>\u274c Instead of</p> <pre><code>num_of_foo = 3.tap {sleep 4}\nnum_of_bar = 3.tap {sleep 1}\n\njson.foo do\n  json.amount num_of_foo\nend\n\njson.bar do\n  json.bar num_of_bar\nend\n</code></pre> <p>\u2705 Do</p> <pre><code>json.foo do\n  num_of_foo = 3.tap {sleep 4}\n  json.amount num_of_foo\nend\n\njson.bar do\n  num_of_bar = 3.tap {sleep 1}\n  json.bar num_of_bar\nend\n</code></pre> <p>This allows you to make use of digging which allows you to skip the execution of longer running blocks. </p> <p>For example: </p> <pre><code>&lt;a href=/posts?props_at=data.bar&gt; Reload me &lt;/a&gt;\n</code></pre>"},{"location":"shared-data/","title":"Shared data","text":"<p>If you have state that should be shared between all pages. Just use common Rails patterns. Simply put them in your layout.</p> <p>For example, in the generated <code>application.json.props</code></p> <pre><code>path = request.format.json? ? param_to_dig_path(params[:props_at]) : nil\n\njson.data(dig: path) do\n+  json.header do\n+    json.email \"foo@foo.com\"\n+  end\n\n  yield json\nend\n</code></pre> <p>In the above, every page that gets rendered will have <code>header</code> as part of the [page response]. </p> <p>You can also use partials:</p> <pre><code>app/\n|-- controllers/\n|-- views/\n|   |-- shared/\n|   |   |-- _header.json.props\n</code></pre> <pre><code>path = request.format.json? ? param_to_dig_path(params[:props_at]) : nil\n\njson.data(dig: path) do\n+  json.header(partial: 'shared/header') do\n+  end\n  yield json\nend\n</code></pre>"},{"location":"shared-data/#advanced-functionality","title":"Advanced functionality","text":"<p>The above results in duplicate JSON nodes across our <code>pages</code>:</p> <pre><code>{\n  pages: {\n    \"/posts\": {\n      data: {\n        header: {\n          email: \"foo@foo.com\"\n        }\n      }\n    },\n    \"/comments\": {\n      data: {\n        header: {\n          email: \"foo@foo.com\"\n        }\n      }\n    },\n  }\n}\n</code></pre> <p>For most cases where you don't need client side updates, this may be good enough. Its a fine tradeoff for simplicity.</p> <p>In scenarios where you need client side updates, or you need to keep data with semantic identity consistent across pages. Superglue encourages you to use:</p> <ol> <li>Fragments for most situations</li> <li>And Redux slices for more complex usecases.</li> </ol> <p>Hint</p> <p>You may not need to use fragments or Redux slices. For some apps, the only slices you'll ever need is the generated <code>flash.js</code> slice that comes with the install step.</p>"},{"location":"super-turbo-streams/","title":"Super Turbo Streams","text":""},{"location":"super-turbo-streams/#vs-turbostreams","title":"vs. Turbostreams","text":"<p>TurboStreams is an amazing tool from the Hotwire world. It's often associated with streaming HTML updates: replacing an element, updating an element, appending/prepending an element to another element. If we step back and consider what we're sending over the wire, it's less about HTML and more about content. </p> <p>When you do <code>broadcast_append_to :messages, @message</code>, you're not thinking \"send some HTML.\" You're thinking \"add this message to the messages collection.\" The semantic operation is more so about content and identity, than markup.</p> <p>The same goes for Super Turbo Streams, but we're using JSON instead of HTML as the delivery mechanism.</p>"},{"location":"super-turbo-streams/#setting-up-streaming","title":"Setting Up Streaming","text":"<p>Before you can broadcast updates, clients need to subscribe to streams. This requires setup on both the server and client side.</p>"},{"location":"super-turbo-streams/#server-side-stream_from_props","title":"Server-Side: <code>stream_from_props</code>","text":"<p>Use <code>stream_from_props</code> in your JSON templates to generate subscription data. It's the equivalent to turbo_stream_from</p> <pre><code># app/views/messages/index.json.props\njson.header \"Messages\"\n\n# Set up streaming subscription\njson.streamFromMessages stream_from_props(\"messages\")\n\njson.messages(partial: [\"message_list\", fragment: \"messages\"]) do\n  json.array! @messages do |message|\n    json.id message.id\n    json.content message.content\n    json.author message.user.name\n  end\nend\n</code></pre> <p>What <code>stream_from_props</code> does:</p> <ul> <li>Generates secure ActionCable subscription data</li> <li>Returns <code>{ channel: \"Superglue::StreamsChannel\", signed_stream_name: \"encrypted_data\" }</code></li> </ul> <p>Advanced usage:</p> <pre><code># Custom channel with parameters\njson.streamFromRoomMessages stream_from_props(\"room_#{@room.id}\", \n  channel: RoomChannel,\n  room: @room\n)\n\n# Multiple streams\njson.streamFromMessages stream_from_props(\"messages\")\njson.streamFromNotifications stream_from_props(\"notifications\")\n</code></pre>"},{"location":"super-turbo-streams/#client-side-usestreamsource","title":"Client-Side: <code>useStreamSource</code>","text":"<p>Subscribe to streams in your React components using <code>useStreamSource</code>:</p> <pre><code>// app/views/messages/index.jsx\nimport React from 'react'\nimport { useContent, useStreamSource } from '@thoughtbot/superglue'\n\nexport default function MessagesIndex() {\n  const content = useContent()\n  const { streamFromMessages, messages } = content\n\n  // Subscribe to real-time updates\n  const { connected } = useStreamSource(streamFromMessages)\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Messages {connected ? '\ud83d\udfe2' : '\ud83d\udd34'}&lt;/h1&gt;\n      &lt;div id=\"messages\"&gt;\n        {messages().map(message =&gt; (\n          &lt;Message key={message.id} {...message} /&gt;\n        ))}\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>What <code>useStreamSource</code> does:</p> <ul> <li>Establishes ActionCable WebSocket connection</li> <li>Subscribes to the specific stream using the subscription data</li> <li>Handles incoming stream messages</li> <li>Provides connection status for UI feedback</li> </ul> <p>Connection status:</p> <pre><code>const { connected, subscription } = useStreamSource(streamFromMessages)\n\n// Use connected for UI indicators\n{connected ? '\ud83d\udfe2 Live Updates' : '\ud83d\udd34 Connecting...'}\n\n// subscription object is rarely needed (for manual operations)\n</code></pre> <p>Multiple streams:</p> <pre><code>// Subscribe to multiple streams in the same component\nuseStreamSource(content.streamFromMessages)\nuseStreamSource(content.streamFromNotifications)\nuseStreamSource(content.streamFromPresence)\n</code></pre>"},{"location":"super-turbo-streams/#actions","title":"Actions","text":"<p>Lets imagine we have the following partials:</p> <pre><code>app/views/messages/_messages.json.props\napp/views/messages/_message.json.props\n</code></pre>"},{"location":"super-turbo-streams/#append","title":"Append","text":"<p>Appends a rendered <code>.props</code> partial to a collection fragment. Equivalent to Turbo Stream's <code>append</code> action but operates on fragment data.</p> <pre><code># In a controller or model\n@message.broadcast_append_to \"messages\"\n\n# With custom fragment targeting\n@message.broadcast_append_to \"chat_room\", target: \"room_messages\"\n\n# With extended options\n@message.broadcast_append_to(\n  [current_user, \"chat_room\"], \n  target: \"my_message_list\", \n  save_target: \"message-#{@message.id}\", \n  options: {}, # options for the js handler if any\n  partial: \"messages/_another_message\",\n  locals: {\n    highlight: true\n  }\n)\n\n# Using later for async execution\n@message.broadcast_append_to_later \"messages\"\n</code></pre> <p>The partial is rendered using the model's partial path and appended to the specified fragment on connected clients.</p> <p>You can also save the rendered partial as a fragment with <code>save_to</code> before it appends to the target fragment.</p> <pre><code># In a controller or model\n@message.broadcast_append_to \"messages\", save_to: \"message-#{@message.id}\"\n</code></pre>"},{"location":"super-turbo-streams/#prepend","title":"Prepend","text":"<p>Prepends the rendered <code>.props</code> partial to the beginning of a collection fragment.</p> <pre><code># Add to beginning of collection\n@message.broadcast_prepend_to \"messages\"\n\n# With custom fragment and stream targeting\n@message.broadcast_prepend_to \"notifications\", target: \"user_notifications\"\n\n# With extended options\n@message.broadcast_prepend_to(\n  [current_user, \"chat_room\"], \n  target: \"my_message_list\", \n  save_target: \"message-#{@message.id}\", \n  options: {}, # options for the js handler if any\n  partial: \"messages/_another_message\",\n  locals: {\n    highlight: true\n  }\n)\n\n# Async execution\n@message.broadcast_prepend_to_later \"messages\"\n</code></pre> <p>You can also save the rendered partial as a fragment with <code>save_to</code> before it appends to the target fragment.</p> <pre><code># In a controller or model\n@message.broadcast_prepend_to \"messages\", save_to: \"message-#{@message.id}\"\n</code></pre>"},{"location":"super-turbo-streams/#save","title":"Save","text":"<p>Serves the same purpose as turbostream's <code>replace</code>, and <code>update</code>. Save will update an existing fragment with new content. This is the most commonly used action for updating individual records.</p> <pre><code># Update existing fragment\n@message.broadcast_save_to \"messages\"\n\n# Save with custom fragment name\n@message.broadcast_save_to \"chat_room\"\n\n# With extended options\n@message.broadcast_save_to(\n  [current_user, \"chat_room\"], \n  target: \"custom-message-#{@message.id}\", \n  options: {}, # options for the js handler if any\n  partial: \"messages/_another_message\",\n  locals: {\n    highlight: true\n  }\n)\n\n# Async execution\n@message.broadcast_save_to_later \"messages\"\n</code></pre> <p>The fragment id is auto generated by using <code>ActionView::RecordIdentifier.dom_id</code> to override this you can pass in the <code>fragment</code> option.</p> <pre><code>@message.broadcast_save_to \"messages\", target: \"spotlight-message\"\n</code></pre>"},{"location":"super-turbo-streams/#refresh","title":"Refresh","text":"<p>Triggers a page or fragment refresh on connected clients. </p> <pre><code># Simple refresh\n@board.broadcast_refresh_to \"board_updates\"\n\n# Refresh with debouncing (prevents rapid refreshes)\n@board.broadcast_refresh_to \"board_updates\", debounce: 1.second\n\n# Async refresh\n@board.broadcast_refresh_to_later \"board_updates\"\n</code></pre> <p>Refreshes are automatically debounced to prevent performance issues from rapid successive updates.</p>"},{"location":"super-turbo-streams/#stream-responses","title":"Stream Responses","text":"<p>Stream responses are supported for <code>append</code>, <code>prepend</code>, and <code>save</code>.</p> <pre><code>class MessagesController &lt; ApplicationController\n  def create\n    @message = Message.create(message_params)\n\n    respond_to do |format|\n      format.html { redirect_to messages_path }\n      format.json { render layout: \"stream\" }\n    end\n  end\nend\n</code></pre> <p>and in <code>create.json.props</code></p> <pre><code>broadcast_append_props(model: @message)\nbroadcast_save_props(model: current_user)\n</code></pre>"},{"location":"super-turbo-streams/#model-configuration","title":"Model Configuration","text":"<p>Configure broadcasting behavior at the model level is also supported:</p> <pre><code>class Message &lt; ApplicationRecord\n  include Superglue::Broadcastable\n\n  # Default configuration - broadcasts to model name stream\nend\n\nclass Article &lt; ApplicationRecord\n  include Superglue::Broadcastable\n\n  # Custom stream and fragment\n  broadcasts \"articles_stream\", target: \"article_list\"\nend\n\nclass Comment &lt; ApplicationRecord\n  include Superglue::Broadcastable\n\n  # Dynamic configuration with lambdas\n  broadcasts_to -&gt;(comment) { [comment.article, :comments] },\n    fragment: -&gt;(comment) { \"article_#{comment.article_id}_comments\" },\n    partial: \"comments/comment\",\n    locals: { highlight: true }\nend\n</code></pre>"},{"location":"super-turbo-streams/#broadcasting-suppression","title":"Broadcasting Suppression","text":"<p>Temporarily disable broadcasting within a block:</p> <pre><code>suppressing_superglue_broadcasts do\n  # These operations won't trigger broadcasts\n  Message.create(content: \"Silent message\")\n  @message.update(content: \"Updated silently\")\nend\n</code></pre> <p>This is useful for bulk operations or when you want to manually control broadcast timing.</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#building-a-collaborative-shopping-list","title":"Building a Collaborative Shopping List","text":"<p>For this tutorial, you'll build a shared shopping list that multiple people can collaborate on in real-time. We'll start simple and progressively add complexity to showcase Superglue's key features. You can find the finished tutorial here</p> <p>Let's build a new Rails project:</p> <pre><code>rails new shopping_list -j esbuild --skip-hotwire\n</code></pre> <p>Tip</p> <p>We're using esbuild here, but you can also use vite</p> <p>Then follow the installation instructions to setup Superglue.</p>"},{"location":"tutorial/#hello-world","title":"Hello World","text":""},{"location":"tutorial/#start-with-the-usual","title":"Start with the usual","text":"<p>Let's begin by creating our models, then adding routes and controllers.</p> Generate models<code>routes.rb</code><code>shopping_lists_controller.rb</code><code>items_controller.rb</code> <pre><code>rails generate model Item name:string completed:boolean\nrails db:migrate\n</code></pre> <p>in <code>config/routes.rb</code></p> <pre><code>Rails.application.routes.draw do\n  root 'shopping_lists#show'\n  resource :shopping_list, only: [:show]\n  resources :items, only: [:show]\nend\n</code></pre> <p>in <code>app/controllers/shopping_lists_controller.rb</code></p> <p>Don't forget! Enable jsx rendering defaults</p> <p><code>use_jsx_rendering_defaults</code> enables Rails to look for <code>.jsx</code> files and pairs with <code>.props</code> files.</p> <pre><code>class ApplicationController &lt; ActionController::Base\n  before_action :use_jsx_rendering_defaults\nend\n</code></pre> <pre><code>class ShoppingListsController &lt; ApplicationController\n  def show\n    @items = Item.all\n  end\nend\n</code></pre> <p>in <code>app/controllers/items_controller.rb</code></p> <pre><code>class ItemsController &lt; ApplicationController\n  def show\n    @item = Item.find(params[:id])\n  end\nend\n</code></pre>"},{"location":"tutorial/#add-the-views","title":"Add the views","text":"<p>Next, let's add the views for our shopping list.</p> <code>show.json.props</code><code>show.jsx</code><code>items/show.json.props</code><code>items/show.jsx</code> <p>in <code>app/views/shopping_lists/show.json.props</code></p> <pre><code>json.header do\n  json.title \"Family Shopping List\"\nend\n\njson.items do\n  json.array! @items do |item|\n    json.id item.id\n    json.name item.name  \n    json.completed item.completed\n    json.detailPath item_path(item)\n  end\nend\n</code></pre> <p>in <code>app/views/shopping_lists/show.jsx</code></p> <pre><code>import React from 'react'\nimport { useContent } from '@thoughtbot/superglue'\n\nexport default function ShoppingListsShow() {\n  const { header, items } = useContent()\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{header.title}&lt;/h1&gt;\n\n      &lt;ul&gt;\n        {items.map(item =&gt; (\n          &lt;li key={item.id}&gt;\n            &lt;input \n              type=\"checkbox\" \n              checked={item.completed}\n              readOnly \n            /&gt;\n            {item.name}\n            &lt;a href={item.detailPath}&gt;Details&lt;/a&gt;\n          &lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>in <code>app/views/items/show.json.props</code></p> <pre><code>json.itemDetails do\n  json.name @item.name\n  json.completed @item.completed\n  json.addedAt @item.created_at.strftime(\"%B %d, %Y at %I:%M %p\")\nend\n\njson.backPath root_path\n</code></pre> <p>in <code>app/views/items/show.jsx</code></p> <pre><code>import React from 'react'\nimport { useContent } from '@thoughtbot/superglue'\n\nexport default function ItemsShow() {\n  const { itemDetails, backPath } = useContent()\n\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;{itemDetails.name}&lt;/h1&gt;\n      &lt;p&gt;Status: {itemDetails.completed ? 'Completed' : 'Pending'}&lt;/p&gt;\n      &lt;p&gt;Added: {itemDetails.addedAt}&lt;/p&gt;\n      &lt;a href={backPath}&gt;\u2190 Back to list&lt;/a&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"tutorial/#connect-the-dots","title":"Connect the dots","text":"<p>Update your page mapping to include both components:</p> <p>Info</p> <p>Vite Users This step can be entirely optional if you're using Vite. See the recipe for more information.</p> <pre><code>// app/javascript/page_to_page_mapping.js\nimport ShoppingListsShow from '../views/shopping_lists/show'\nimport ItemsShow from '../views/items/show'\n\nexport const pageIdentifierToPageComponent = {\n  'shopping_lists/show': ShoppingListsShow,\n  'items/show': ItemsShow,\n}\n</code></pre>"},{"location":"tutorial/#see-it-in-action","title":"See it in action","text":"<p>Let's add some sample data and visit our app:</p> <pre><code># db/seeds.rb\nItem.create!([\n  { name: \"Milk\", completed: false },\n  { name: \"Bread\", completed: true },\n  { name: \"Eggs\", completed: false },\n  { name: \"Apples\", completed: false },\n  { name: \"Cheese\", completed: true }\n])\n</code></pre> <pre><code>rails db:seed\nbin/dev\n</code></pre> <p>Visit http://localhost:3000 - you'll see your shopping list with clickable item details!</p>"},{"location":"tutorial/#add-create","title":"Add create","text":"<p>Now let's add a form to create new items. Superglue provides <code>form_props</code> to transform Rails form helpers into React-compatible props:</p> <code>show.json.props</code><code>show.jsx</code><code>routes.rb</code><code>items_controller.rb</code> <p>Update <code>app/views/shopping_lists/show.json.props</code></p> <pre><code>  json.header do\n    json.title \"Family Shopping List\"\n  end\n\njson.items do\n  json.array! @items do |item|\n    json.id item.id\n    json.name item.name  \n    json.completed item.completed\n    json.detailPath item_path(item)\n  end\nend\n\n+ json.newItemForm do\n+   form_props(model: Item.new, url: items_path) do |f|\n+     f.text_field :name, placeholder: \"Add item...\"\n+     f.submit \"Add\"\n+   end\n+ end\n</code></pre> <p>Update <code>app/views/shopping_lists/show.jsx</code></p> <p>Note</p> <p>The installation will also add vanilla form input components from candy_wrapper</p> <pre><code>  import React from 'react'\n  import { useContent } from '@thoughtbot/superglue'\n+ import { Form, TextField, SubmitButton } from '@javascript/components'\n\n  export default function ShoppingListsShow() {\n-   const { header, items } = useContent()\n+   const { header, items, newItemForm } = useContent()\n+   const { form, extras, inputs } = newItemForm\n\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{header.title}&lt;/h1&gt;\n\n        &lt;ul&gt;\n          {items.map(item =&gt; (\n            &lt;li key={item.id}&gt;\n              &lt;input \n                type=\"checkbox\" \n                checked={item.completed}\n                readOnly \n              /&gt;\n              {item.name}\n              &lt;a href={item.detailPath}&gt;Details&lt;/a&gt;\n            &lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n\n+       &lt;Form {...form} extras={extras}&gt;\n+         &lt;TextField {...inputs.name} /&gt;\n+         &lt;SubmitButton {...inputs.submit} /&gt;\n+       &lt;/Form&gt;\n      &lt;/div&gt;\n    )\n  }\n</code></pre> <p>in <code>config/routes.rb</code></p> <pre><code>Rails.application.routes.draw do\n  root 'shopping_lists#show'\n  resource :shopping_list, only: [:show]\n- resources :items, only: [:show]\n+ resources :items, only: [:show, :create]\nend\n</code></pre> <p>Update <code>app/controllers/items_controller.rb</code> to handle form submissions</p> <pre><code>class ItemsController &lt; ApplicationController\n  def show\n    @item = Item.find(params[:id])\n  end\n\n+ def create\n+   @item = Item.new(item_params.merge(completed: false))\n+   \n+   if @item.save\n+     redirect_to root_path, notice: 'Item added successfully!'\n+   else\n+     redirect_to root_path, alert: 'Failed to add item'\n+   end\n+ end\n+\n+ private\n+\n+ def item_params\n+   params.require(:item).permit(:name)\n+ end\nend\n</code></pre>"},{"location":"tutorial/#add-flash","title":"Add flash","text":"<p>The <code>create</code> action redirects with a notice. Lets make sure these show up in our react app.</p> <p>Tip</p> <p>The flash is an example of a custom slice. It is for you to customize.</p> <pre><code>  import React from 'react'\n  import { useContent } from '@thoughtbot/superglue'\n  import { Form, TextField, SubmitButton } from '@javascript/components'\n+ import { useAppSelector } from '@javascript/store'\n\n  export default function ShoppingListsShow() {\n    const { header, items, newItemForm } = useContent()\n    const { form, extras, inputs } = newItemForm\n+   const flash = useAppSelector((state) =&gt; state.flash)\n\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{header.title}&lt;/h1&gt;\n+       {flash.notice &amp;&amp; &lt;p&gt;{flash.notice}&lt;/p&gt;}\n+       {flash.alert &amp;&amp; &lt;p&gt;{flash.alert}&lt;/p&gt;}\n\n        &lt;ul&gt;\n          {items.map(item =&gt; (\n            &lt;li key={item.id}&gt;\n              &lt;input \n                type=\"checkbox\" \n                checked={item.completed}\n                readOnly \n              /&gt;\n              {item.name}\n              &lt;a href={item.detailPath}&gt;Details&lt;/a&gt;\n            &lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n\n        &lt;Form {...form} extras={extras}&gt;\n          &lt;TextField {...inputs.name} /&gt;\n          &lt;SubmitButton {...inputs.submit} /&gt;\n        &lt;/Form&gt;\n      &lt;/div&gt;\n    )\n  }\n</code></pre>"},{"location":"tutorial/#add-update","title":"Add update","text":"<p>Now let's add a form to toggle <code>completed</code> on existing items. </p> <code>show.json.props</code><code>show.jsx</code><code>routes.rb</code><code>items_controller.rb</code> <p>Update <code>app/views/shopping_lists/show.json.props</code></p> <pre><code>  json.header do\n    json.title \"Family Shopping List\"\n  end\n\n  json.items do\n    json.array! @items do |item|\n      json.id item.id\n      json.name item.name  \n      json.completed item.completed\n      json.detailPath item_path(item)\n+     json.toggleForm do\n+       form_props(model: item) do |f|\n+         f.submit \"Toggle\"\n+       end\n+     end\n    end\n  end\n\n  json.newItemForm do\n    form_props(model: Item.new, url: items_path) do |f|\n      f.text_field :name, placeholder: \"Add item...\"\n      f.submit \"Add\"\n    end\n  end\n</code></pre> <p>Update <code>app/views/shopping_lists/show.jsx</code></p> <pre><code>  import React from 'react'\n  import { useContent } from '@thoughtbot/superglue'\n  import { Form, TextField, SubmitButton } from '@javascript/components'\n  import { useAppSelector } from '@javascript/store'\n\n  export default function ShoppingListsShow() {\n    const { header, items, newItemForm } = useContent()\n    const { form, extras, inputs } = newItemForm\n    const flash = useAppSelector((state) =&gt; state.flash)\n\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{header.title}&lt;/h1&gt;\n        {flash.notice &amp;&amp; &lt;p&gt;{flash.notice}&lt;/p&gt;} \n        {flash.alert &amp;&amp; &lt;p&gt;{flash.alert}&lt;/p&gt;} \n\n        &lt;ul&gt;\n          {items.map(item =&gt; (\n            &lt;li key={item.id}&gt;\n-             &lt;input \n-               type=\"checkbox\" \n-               checked={item.completed}\n-               readOnly \n-             /&gt;\n+             {item.completed ? \"\u2705\"  : \"\u274c\"}\n+             &lt;Form {...item.toggleForm.form} extras={item.toggleForm.extras}&gt;\n+               &lt;SubmitButton {...item.toggleForm.inputs.submit} /&gt;\n+             &lt;/Form&gt;\n              {item.name}\n              &lt;a href={item.detailPath}&gt;Details&lt;/a&gt;\n            &lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n\n        &lt;Form {...form} extras={extras}&gt;\n          &lt;TextField {...inputs.name} /&gt;\n          &lt;SubmitButton {...inputs.submit} /&gt;\n        &lt;/Form&gt;\n      &lt;/div&gt;\n    )\n  }\n</code></pre> <p>in <code>config/routes.rb</code></p> <pre><code>Rails.application.routes.draw do\n  root 'shopping_lists#show'\n  resource :shopping_list, only: [:show]\n- resources :items, only: [:show, :create]\n+ resources :items, only: [:show, :create, :update]\nend\n</code></pre> <p>Update <code>app/controllers/items_controller.rb</code> to handle toggle submissions</p> <pre><code>class ItemsController &lt; ApplicationController\n  def show\n    @item = Item.find(params[:id])\n  end\n\n  def create\n    @item = Item.new(item_params.merge(completed: false))\n\n    if @item.save\n      redirect_to root_path, notice: 'Item added successfully!'\n    else\n      redirect_to root_path, alert: 'Failed to add item'\n    end\n  end\n\n+ def update\n+   @item = Item.find(params[:id])\n+   @item.update!(completed: !@item.completed)\n+   redirect_to root_path\n+ end\n\n  private\n\n  def item_params\n    params.require(:item).permit(:name)\n  end\nend\n</code></pre>"},{"location":"tutorial/#ujs-power","title":"UJS Power","text":"<p>What we've built so far is a multi-page application backed by classic Rails conventions with a touch of React. Lets progressively add SPA navigation to forms and links by bringing back a Rails favorite: Unobtrusive Javascript</p> <code>show.jsx</code><code>items/show.jsx</code> <p>Update <code>app/views/shopping_lists/show.jsx</code></p> <p>Note</p> <p>Setting a HTTP method like <code>put</code> on a <code>&lt;a&gt;</code> tag is not supported with Unobtrusive Javascript. This is by design. Instead, create a form that looks like a link. This is inspired by link_to.</p> <pre><code>  import React from 'react'\n  import { useContent } from '@thoughtbot/superglue'\n  import { Form, TextField, SubmitButton } from '@javascript/components'\n  import { useAppSelector } from '@javascript/store'\n\n  export default function ShoppingListsShow() {\n    const { header, items, newItemForm } = useContent()\n    const { form, extras, inputs } = newItemForm\n    const flash = useAppSelector((state) =&gt; state.flash)\n\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{header.title}&lt;/h1&gt;\n        {flash.notice &amp;&amp; &lt;p&gt;{flash.notice}&lt;/p&gt;} \n        {flash.alert &amp;&amp; &lt;p&gt;{flash.alert}&lt;/p&gt;}  \n\n        &lt;ul&gt;\n          {items.map(item =&gt; (\n            &lt;li key={item.id}&gt;\n              {item.completed ? \"\u2705\"  : \"\u274c\"}\n-             &lt;Form {...item.toggleForm.form} extras={item.toggleForm.extras}&gt;\n+             &lt;Form {...item.toggleForm.form} extras={item.toggleForm.extras} data-sg-remote&gt;\n                &lt;SubmitButton {...item.toggleForm.inputs.submit} /&gt;\n              &lt;/Form&gt;\n              {item.name}\n-             &lt;a href={item.detailPath}&gt;Details&lt;/a&gt;\n+             &lt;a href={item.detailPath} data-sg-visit&gt;Details&lt;/a&gt;\n            &lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n\n-       &lt;Form {...form} extras={extras}&gt;\n+       &lt;Form {...form} extras={extras} data-sg-remote&gt;\n          &lt;TextField {...inputs.name} /&gt;\n          &lt;SubmitButton {...inputs.submit} /&gt;\n        &lt;/Form&gt;\n      &lt;/div&gt;\n    )\n  }\n</code></pre> <p>Update <code>app/views/items/show.jsx</code></p> <pre><code>  import React from 'react'\n  import { useContent } from '@thoughtbot/superglue'\n\n  export default function ItemsShow() {\n    const { itemDetails, backPath } = useContent()\n\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{itemDetails.name}&lt;/h1&gt;\n        &lt;p&gt;Status: {itemDetails.completed ? 'Completed' : 'Pending'}&lt;/p&gt;\n        &lt;p&gt;Added: {itemDetails.addedAt}&lt;/p&gt;\n-       &lt;a href={backPath}&gt;\u2190 Back to list&lt;/a&gt;\n+       &lt;a href={backPath} data-sg-visit&gt;\u2190 Back to list&lt;/a&gt;\n      &lt;/div&gt;\n    )\n  }\n</code></pre> <p>Now you have:</p> <ul> <li><code>data-sg-remote</code>: AJAX requests that stay on the same page</li> <li><code>data-sg-visit</code>: SPA-like navigation between pages</li> <li>All using Rails routes and controllers - no client-side routing needed!</li> </ul>"},{"location":"tutorial/#performance","title":"Performance","text":"<p>In practice, not all applications are as performant as this one. Let's simulate a slow running operation:</p> <code>show.json.props</code><code>show.jsx</code> <p>Update <code>app/views/shopping_lists/show.json.props</code></p> <pre><code>  json.header do\n    json.title \"Family Shopping List\"\n  end\n\n  json.items do\n    json.array! @items do |item|\n      json.id item.id\n      json.name item.name  \n      json.completed item.completed\n      json.detailPath item_path(item)\n      json.toggleForm do\n        form_props(model: item) do |f|\n          f.submit \"Toggle\"\n        end\n      end\n    end\n  end\n\n+ json.totalCost do\n+   # Simulate expensive API call to get current prices\n+   sleep 3\n+   json.amount \"$23.45\"\n+   json.message \"Estimated total based on current prices\"\n+ end\n\n  json.newItemForm do\n    form_props(model: Item.new, url: items_path) do |f|\n      f.text_field :name, placeholder: \"Add item...\"\n      f.submit \"Add\"\n    end\n  end\n</code></pre> <p>Update <code>app/views/shopping_lists/show.jsx</code> to display the cost</p> <pre><code>  import React from 'react'\n  import { useContent } from '@thoughtbot/superglue'\n  import { Form, TextField, SubmitButton } from '@javascript/components'\n  import { useAppSelector } from '@javascript/store'\n\n  export default function ShoppingListsShow() {\n-   const { header, items, newItemForm } = useContent()\n+   const { header, items, newItemForm, totalCost } = useContent()\n    const { form, extras, inputs } = newItemForm\n    const flash = useAppSelector((state) =&gt; state.flash)\n\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{header.title}&lt;/h1&gt;\n        {flash.notice &amp;&amp; &lt;p&gt;{flash.notice}&lt;/p&gt;} \n        {flash.alert &amp;&amp; &lt;p&gt;{flash.alert}&lt;/p&gt;} \n\n+       &lt;div style={{border: '1px solid #ccc', padding: '10px', margin: '10px 0'}}&gt;\n+         &lt;h3&gt;Total Cost: {totalCost.amount}&lt;/h3&gt;\n+         &lt;small&gt;{totalCost.message}&lt;/small&gt;\n+       &lt;/div&gt;\n+       \n        &lt;ul&gt;\n          {items.map(item =&gt; (\n            &lt;li key={item.id}&gt;\n              {item.completed ? \"\u2705\"  : \"\u274c\"}\n              &lt;Form {...item.toggleForm.form} extras={item.toggleForm.extras} data-sg-remote&gt;\n                &lt;SubmitButton {...item.toggleForm.inputs.submit} /&gt;\n              &lt;/Form&gt;\n              {item.name}\n              &lt;a href={item.detailPath} data-sg-visit&gt;Details&lt;/a&gt;\n            &lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n\n        &lt;Form {...form} extras={extras} data-sg-remote&gt;\n          &lt;TextField {...inputs.name} /&gt;\n          &lt;SubmitButton {...inputs.submit} /&gt;\n        &lt;/Form&gt;\n      &lt;/div&gt;\n    )\n  }\n</code></pre> <p>Now your page takes 3 seconds to load! This is exactly the problem defer solves.</p>"},{"location":"tutorial/#defer-auto","title":"<code>defer: auto</code>","text":"<p>Let's fix the performance issue with <code>defer: :auto</code>, which allows us to skip blocks and automatically fetch it later. </p> <code>show.json.props</code> <p>Update <code>app/views/shopping_lists/show.json.props</code></p> <pre><code>  json.header do\n    json.title \"Family Shopping List\"\n  end\n\n  json.items do\n    json.array! @items do |item|\n      json.id item.id\n      json.name item.name  \n      json.completed item.completed\n      json.detailPath item_path(item)\n      json.toggleForm do\n        form_props(model: item) do |f|\n          f.submit \"Toggle\"\n        end\n      end\n    end\n  end\n\n- json.totalCost do\n+ json.totalCost(defer: [:auto, placeholder: { amount: \"Calculating...\", message: \"Getting current prices\" }]) do\n    # Simulate expensive API call to get current prices\n    sleep 3\n    json.amount \"$23.45\"\n    json.message \"Estimated total based on current prices\"\n  end\n\n  json.newItemForm do\n    form_props(model: Item.new, url: items_path) do |f|\n      f.text_field :name, placeholder: \"Add item...\"\n      f.submit \"Add\"\n    end\n  end\n</code></pre> <p>Now reload the page, and watch it instantly load with \"Calculating...\". Wait another 3 seconds and watch real cost appears automatically!</p> <p>Tip</p> <p>You can defer any deeply nested child node and nest deferments. For example:</p> <pre><code>json.metrics do \n  json.visits(defer: :auto) do\n    json.total(defer: :auto) do\n    end\n    json.average(defer: :auto) do\n    end\n  end\nend\n</code></pre> <p>Read more about this in deferments</p> <p>Tip</p> <p>There is also a <code>defer: :manual</code>. Its for cases where we want to be explicit when the deferred content loads. This is useful for modals and tabs.</p> <p>What happens behind the scenes:</p> <ol> <li>Initial response contains placeholder data</li> <li>Superglue automatically makes a second request for the deferred content</li> <li>When the calculation completes, the UI updates automatically</li> </ol> <p>This is what the requests in step 2 looks like:</p> <pre><code>GET /shopping_list?props_at=data.totalCost\n</code></pre>"},{"location":"tutorial/#digging-with-props_at","title":"Digging with <code>props_at</code>","text":"<p>The second step behind the scenes is called digging. You can use the same <code>props_at</code> pattern with Unobtrusive Javascript via <code>data-sg-remote</code> or with requests.</p> <p>Here's how reloading a part of the screen would look like:</p> Manual refresh buttonUpdate just the items <pre><code>&lt;button&gt;\n  &lt;a href=\"/shopping_list?props_at=data.totalCost\" data-sg-remote&gt;\n    Refresh Cost\n  &lt;/a&gt;\n&lt;/button&gt;\n</code></pre> <pre><code>&lt;a href=\"/shopping_list?props_at=data.items\" data-sg-remote&gt;\n  Refresh List\n&lt;/a&gt;\n</code></pre> <p>The power of props_at: In both cases, we are selectively choosing a block of state to fetch from your <code>props</code>. This helps us update any part of your page without full reloads.</p>"},{"location":"tutorial/#super-turbo-stream-streaming-responses","title":"Super Turbo Stream: Streaming Responses","text":"<p>We've been redirecting the user back after an item is created. This reloads the entire page, it would be nice to just render the <code>_item.json.props</code> partial append to the list.</p> <p>Now we can! We've taken the power of Turbo Streams and ported it to Superglue as Super Turbo Stream. Before we get to real time streaming, lets start with Super Turbo Streaming responses to surgically update our list.</p> Update templates with fragments<code>items_controller.rb</code><code>create.json.props</code><code>update.json.props</code> <p>Update <code>app/views/shopping_lists/show.json.props</code> to add fragment IDs:</p> <p>Tip</p> <p>This step declares a fragment with an id of <code>shopping_list</code> that we can refer to in the frontend</p> <pre><code>json.header do\n  json.title \"Family Shopping List\"\nend\n\n+ json.items(partial: [\"item_list\", fragment: \"shopping_list\"]) do\n- json.items do\n-   json.array! @items do |item|\n-     json.id item.id\n-     json.name item.name  \n-     json.completed item.completed\n-     json.detailPath item_path(item)\n-     json.toggleForm do\n-       form_props(model: item) do |f|\n-         f.submit \"Toggle\"\n-       end\n-     end\n-   end\n  end\n\n  # ... rest remains the same\n</code></pre> <p>Create <code>app/views/shopping_lists/_item_list.json.props</code>:</p> <p>Tip</p> <p>This step declares <code>n</code> fragments, 1 for each item in <code>@items</code> with an id that looks like <code>item_1</code>, <code>item_2</code>, etc.</p> <pre><code>json.array!(\n  @items, \n  partial: ['item', fragment: -&gt;(item){\"item_#{item.id}\"}]\n  ) do |item|\nend\n</code></pre> <p>Create <code>app/views/shopping_lists/_item.json.props</code>:</p> <p>Tip</p> <p>This step creates the content of the item fragments.</p> <pre><code>json.id item.id\njson.name item.name  \njson.completed item.completed\njson.detailPath item_path(item)\njson.toggleForm do\n  form_props(model: item) do |f|\n    f.submit \"Toggle\"\n  end\nend\n</code></pre> <p>Tip</p> <p>Using fragments denormalizes the state, which gets lazily re-normalized with useContent. Before we update the controller, go ahead and reload the page. Everything should still work. </p> <p>Update <code>app/controllers/items_controller.rb</code> for streaming responses</p> <pre><code>  class ItemsController &lt; ApplicationController\n    def show\n      @item = Item.find(params[:id])\n    end\n\n    def create\n      @item = Item.new(item_params.merge(completed: false))\n\n      if @item.save\n-       redirect_to root_path, notice: 'Item added successfully!'\n+       respond_to do |format|\n+         flash[:notice] = \"Item added succesfully\"\n+         format.html { redirect_to root_path }\n+         format.json { render layout: \"stream\" }\n+       end\n      else\n        redirect_to root_path, alert: 'Failed to add item'\n      end\n    end\n\n    def update\n      @item = Item.find(params[:id])\n      @item.update!(completed: !@item.completed)\n-     redirect_to root_path\n+     respond_to do |format|\n+       format.html { redirect_to root_path }\n+       format.json { render layout: \"stream\" }\n+     end\n    end\n\n    private\n\n    def item_params\n      params.require(:item).permit(:name)\n    end\n  end\n</code></pre> <p>Create <code>app/views/items/create.json.props</code></p> <p>Tip</p> <p>The below will create a streaming response that will save the content as fragment <code>item_1</code> and append a reference to it to fragment <code>shopping_list</code></p> <pre><code>broadcast_append_props(\n  model: @item, \n  save_target: \"item_#{@item.id}\",\n  target: \"shopping_list\",\n  partial: \"shopping_lists/item\"\n)\n</code></pre> <p>Create <code>app/views/items/update.json.props</code></p> <p>Tip</p> <p>The below will create a streaming response that will save the content as fragment <code>item_1</code> and override any existing fragment with that id.</p> <pre><code># This will update the item for all connected clients\nbroadcast_save_props(\n  model: @item, \n  target: \"item_#{@item.id}\",\n  partial: \"shopping_lists/item\",\n)\n</code></pre>"},{"location":"tutorial/#super-turbo-stream-subscriptions","title":"Super Turbo Stream: Subscriptions","text":"<p>Now let's make this truly collaborative. Let's use Super Turbo Streams to update all connected users.</p> Update templates with fragments<code>show.jsx</code><code>item.rb</code> <p>Update <code>app/views/shopping_lists/show.json.props</code> to create ActionCable subscription props:</p> <pre><code>  json.header do\n    json.title \"Family Shopping List\"\n  end\n\n+ # Set up streaming subscription\n+ json.streamFromShopping stream_from_props(\"shopping\")\n\n  json.items(partial: [\"item_list\", fragment: \"shopping_list\"]) do\n  end\n\n  # ... rest remains the same\n</code></pre> <p>Update <code>app/views/shopping_lists/show.jsx</code> to subscribe using those props.</p> <pre><code>  import React from 'react'\n- import { useContent } from '@thoughtbot/superglue'\n+ import { useContent, useStreamSource } from '@thoughtbot/superglue'\n  import { Form, TextField, SubmitButton } from '@javascript/components'\n  import { useAppSelector } from '@javascript/store'\n  export default function ShoppingListsShow() {\n-   const { header, items, newItemForm, totalCost } = useContent()\n+   const { header, items, newItemForm, totalCost, streamFromShopping } = useContent()\n    const { form, extras, inputs } = newItemForm\n    const flash = useAppSelector((state) =&gt; state.flash)\n\n+   // Subscribe to real-time updates\n+   const { connected } = useStreamSource(streamFromShopping)\n\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{header.title}&lt;/h1&gt;\n        {flash.notice &amp;&amp; &lt;p&gt;{flash.notice}&lt;/p&gt;} \n        {flash.alert &amp;&amp; &lt;p&gt;{flash.alert}&lt;/p&gt;}  \n\n        &lt;div style={{border: '1px solid #ccc', padding: '10px', margin: '10px 0'}}&gt;\n          &lt;h3&gt;Total Cost: {totalCost.amount}&lt;/h3&gt;\n          &lt;small&gt;{totalCost.message}&lt;/small&gt;\n+         &lt;div style={{float: 'right', fontSize: '12px'}}&gt;\n+           {connected ? '\ud83d\udfe2 Live Updates' : '\ud83d\udd34 Connecting...'}\n+         &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;ul&gt;\n          {items.map(item =&gt; (\n            &lt;li key={item.id}&gt;\n              {item.completed ? \"\u2705\"  : \"\u274c\"}\n              &lt;Form {...item.toggleForm.form} extras={item.toggleForm.extras} data-sg-remote&gt;\n                &lt;SubmitButton {...item.toggleForm.inputs.submit} /&gt;\n              &lt;/Form&gt;\n              {item.name}\n              &lt;a href={item.detailPath} data-sg-visit&gt;Details&lt;/a&gt;\n            &lt;/li&gt;\n          ))}\n        &lt;/ul&gt;\n\n        &lt;Form {...form} extras={extras} data-sg-remote&gt;\n          &lt;TextField {...inputs.name} /&gt;\n          &lt;SubmitButton {...inputs.submit} /&gt;\n        &lt;/Form&gt;\n      &lt;/div&gt;\n    )\n  }\n</code></pre> <p>Add the <code>Broadcastable</code> module to the model.</p> <pre><code> class Item &lt; ApplicationRecord\n+  include Superglue::Broadcastable\n end\n</code></pre> <code>items_controller.rb</code> <p>And broadcast it from the controller.</p> <pre><code>  class ItemsController &lt; ApplicationController\n    def show\n      @item = Item.find(params[:id])\n    end\n\n    def create\n      @item = Item.new(item_params.merge(completed: false))\n\n      if @item.save\n +      @item.broadcast_append_later_to(\n +        \"shopping\",\n +        save_target: \"item_#{@item.id}\",\n +        target: \"shopping_list\",\n +        partial: \"shopping_lists/item\"\n +      )\n\n        respond_to do |format|\n          flash[:notice] = \"Item added succesfully\"\n          format.html { redirect_to root_path }\n          format.json { render layout: \"stream\" }\n        end\n      else\n        respond_to do |format|\n          format.html { redirect_to root_path }\n          format.json { render layout: \"stream\" }\n        end\n      end\n    end\n\n    def update\n      @item = Item.find(params[:id])\n      @item.update!(completed: !@item.completed)\n +    @item.broadcast_save_later_to(\n +      \"shopping\",\n +      target: \"item_#{@item.id}\",\n +      partial: \"shopping_lists/item\"\n +    )\n      respond_to do |format|\n        format.html { redirect_to root_path }\n        format.json { render layout: \"stream\" }\n      end\n    end\n\n    private\n\n    def item_params\n      params.require(:item).permit(:name)\n    end\n  end\n</code></pre> <p>Open two tabs to the app to simlate two users. Now when one user adds an item or toggles completion, all connected users see the update instantly!</p>"},{"location":"tutorial/#performance-with-fragment-references","title":"Performance with Fragment References","text":"<p>When working with React, it's ideal to minimize re-renders - if one part of the page changes, let's not re-render everything. It's a common issue with props drilling, and at first glance <code>useContent</code> looks to be affected. But Superglue has you covered.</p> <p>Fragment references solve this by letting child components subscribe only to their specific fragments. This means only the components that actually need to update will re-render.</p> <p>Let's optimize our app:</p> <code>show.jsx</code>Component files <p>Update <code>app/views/shopping_lists/show.jsx</code> to use fragment references</p> <pre><code>  import React from 'react'\n- import { useContent, useStreamSource } from '@thoughtbot/superglue'\n+ import { useContent, useStreamSource, unproxy } from '@thoughtbot/superglue'\n+ import ItemsList from '@javascript/components/ItemsList'\n  import { Form, TextField, SubmitButton } from '@javascript/components'\n  import { useAppSelector } from '@javascript/store'\n\n  export default function ShoppingListsShow() {\n-   const { header, items, newItemForm, totalCost, streamFromShopping } = useContent()\n+   const content = useContent()\n+   const { header, newItemForm, totalCost, streamFromShopping } = content\n    const { form, extras, inputs } = newItemForm\n    const flash = useAppSelector((state) =&gt; state.flash)\n\n    // Subscribe to real-time updates\n    const { connected } = useStreamSource(streamFromShopping)\n+   \n+   // Get the raw content and pass fragment reference for items \n+   // to prevent parent re-renders\n+   const itemsRef = unproxy(content).items\n\n    return (\n      &lt;div&gt;\n        &lt;h1&gt;{header.title}&lt;/h1&gt;\n        {flash.notice &amp;&amp; &lt;p&gt;{flash.notice}&lt;/p&gt;} \n        {flash.alert &amp;&amp; &lt;p&gt;{flash.alert}&lt;/p&gt;} \n\n        &lt;div style={{border: '1px solid #ccc', padding: '10px', margin: '10px 0'}}&gt;\n          &lt;h3&gt;Total Cost: {totalCost.amount}&lt;/h3&gt;\n          &lt;small&gt;{totalCost.message}&lt;/small&gt;\n          &lt;div style={{float: 'right', fontSize: '12px'}}&gt;\n            {connected ? '\ud83d\udfe2 Live Updates' : '\ud83d\udd34 Connecting...'}\n          &lt;/div&gt;\n        &lt;/div&gt;\n\n-       &lt;ul&gt;\n-         {items.map(item =&gt; (\n-           &lt;li key={item.id}&gt;\n-             {item.completed ? \"\u2705\"  : \"\u274c\"}\n-             &lt;Form {...item.toggleForm.form} extras={item.toggleForm.extras} data-sg-remote&gt;\n-               &lt;SubmitButton {...item.toggleForm.inputs.submit} /&gt;\n-             &lt;/Form&gt;\n-             {item.name}\n-             &lt;a href={item.detailPath} data-sg-visit&gt;Details&lt;/a&gt;\n-           &lt;/li&gt;\n-         ))}\n-       &lt;/ul&gt;\n+       &lt;ItemsList itemsRef={itemsRef} /&gt;\n\n        &lt;Form {...form} extras={extras} data-sg-remote&gt;\n          &lt;TextField {...inputs.name} /&gt;\n          &lt;SubmitButton {...inputs.submit} /&gt;\n        &lt;/Form&gt;\n      &lt;/div&gt;\n    )\n  }\n</code></pre> <p>Create <code>app/javascript/components/ItemsList.jsx</code></p> <p>Note</p> <p>Using <code>useContent(itemRef)</code> returns a proxy that keeps track of every fragment used by the proxy. Here, if the item changes at all, then the component will rerender without triggering the parent.</p> <pre><code>import React from 'react'\nimport { useContent, unproxy } from '@thoughtbot/superglue'\nimport { Form, SubmitButton } from '@javascript/components'\n\nconst Item = ({ itemRef }) =&gt; {\n  const {\n    name,\n    completed,\n    detailPath,\n    toggleForm,\n  } = useContent(itemRef)\n\n  return (\n    &lt;li&gt;\n      {completed ? \"\u2705\"  : \"\u274c\"}\n      &lt;Form {...toggleForm.form} extras={toggleForm.extras} data-sg-remote&gt;\n        &lt;SubmitButton {...toggleForm.inputs.submit} /&gt;\n      &lt;/Form&gt;\n      {name}\n      &lt;a href={detailPath} data-sg-visit&gt;Details&lt;/a&gt;\n    &lt;/li&gt;\n  )\n}\n\nexport default function ItemsList({ itemsRef }) {\n  const items = useContent(itemsRef)\n\n  return (\n    &lt;ul&gt;\n      {unproxy(items).map(itemRef =&gt; (\n        &lt;Item key={itemRef.__id} itemRef={itemRef} /&gt;\n      ))}\n    &lt;/ul&gt;\n  )\n}\n</code></pre>"},{"location":"tutorial/#client-side-updates","title":"Client-Side Updates","text":"<p>For the final touch, let's add optimistic updates using <code>useSetFragment</code>:</p> <p>Note</p> <p>In this example we'll use <code>remote</code>, the async request helper that powers Superglue's <code>data-sg-remote</code>. Unlike the UJS counterpart, this method allows us to set the HTTP method <code>PATCH</code>.</p> Optimistic toggle <p>Update <code>app/javascript/components/ItemsList.jsx</code></p> <pre><code>- import React from 'react'\n+ import React, { useContext } from 'react'\n- import { useContent, unproxy } from '@thoughtbot/superglue'\n+ import { useContent, useSetFragment, unproxy, NavigationContext } from '@thoughtbot/superglue'\n\n  const Item = ({ itemRef }) =&gt; {\n    const {\n      id,\n      name,\n      completed,\n      detailPath,\n      toggleForm,\n    } = useContent(itemRef)\n+   const set = useSetFragment()\n+   const { remote } = useContext(NavigationContext)\n+\n+   const handleToggle = (currentState) =&gt; {\n+     // Optimistic update - immediate UI feedback on specific item fragment\n+     set(`item_${id}`, (draft) =&gt; {\n+       draft.completed = !currentState\n+     })\n+\n+     // Sync with server (this would trigger streaming to other users)\n+     remote(`/items/${id}`, { method: 'PATCH' })\n+       .catch(() =&gt; {\n+         // Revert on error\n+         set(`item_${id}`, (draft) =&gt; {\n+           draft.completed = currentState\n+         })\n+       })\n+   }\n\n    return (\n      &lt;li&gt;\n        {completed ? \"\u2705\"  : \"\u274c\"}\n-       &lt;Form {...toggleForm.form} extras={toggleForm.extras} data-sg-remote&gt;\n-         &lt;SubmitButton {...toggleForm.inputs.submit} /&gt;\n-       &lt;/Form&gt;\n+       &lt;button onClick={() =&gt; handleToggle(completed)}&gt;\n+         Toggle\n+       &lt;/button&gt;\n        {name}\n        &lt;a href={detailPath} data-sg-visit&gt;Details&lt;/a&gt;\n      &lt;/li&gt;\n    )\n  }\n\n  export default function ItemsList({ itemsRef }) {\n    const items = useContent(itemsRef)\n\n    return (\n      &lt;ul&gt;\n        {unproxy(items).map(itemRef =&gt; (\n          &lt;Item key={itemRef.__id} itemRef={itemRef} /&gt;\n        ))}\n      &lt;/ul&gt;\n    )\n  }\n</code></pre>"},{"location":"tutorial/#finish","title":"Finish","text":"<p>Congratulations! You've built a collaborative shopping list that demonstrates Superglue's key features. Explore the documentation to discover what else is possible.</p>"},{"location":"ujs/","title":"The return of Rails UJS","text":"<p>Unobtrusive Javascript is an easy way to added single page app like features to HTML links and form tags. Its taken a backseat since the introduction of Hotwire, but Superglue puts UJS back in the forefront and packs it with functionality that makes building SPA-like functionality easy and consistent.</p> <p>Want to reload a shopping cart?</p> <pre><code>&lt;a href=\"/props_at=data.sideBar.shoppingCart\" data-sg-remote&gt;Reload the cart&lt;/a&gt;\n</code></pre> <p>Or maybe load a modal efficiently when the next page has one?</p> <pre><code>&lt;a href=\"/posts/new?props_at=data.modal\"&gt;Create Post&lt;/a&gt;\n</code></pre> <p>With Superglue, there is just one concept. No need for the complexity of Stimulus controllers, Turbo Streams, or Turbo Frames.</p>"},{"location":"ujs/#navigating-with-ujs","title":"Navigating with UJS","text":"<p>Superglue operates like a multipage application. In other to transition to the next page without reloading you'll need to use UJS attributes <code>data-sg-remote</code> or <code>data-sg-visit</code>.</p>"},{"location":"ujs/#data-sg-visit","title":"<code>data-sg-visit</code>","text":"<p>Use <code>data-sg-visit</code> when you want to navigate to the next page and update the address bar without reloading.</p> <pre><code>&lt;a href='/posts/new' data-sg-visit /&gt;\n</code></pre> <p>In the above example, when the link is clicked, Superglue will intercept the click, make a request for <code>/posts/new.json</code>, swap your page component, and pass the payload.</p> <p>Note</p> <p>You are not able to specify the HTTP method used in a UJS link.</p> <p>This is intentional. If you want to create a link that can support <code>POST</code>, <code>PUT</code>, <code>DELETE</code> methods, create a form component that looks like a link and use props generated from form_props</p> <p>You can also use <code>data-sg-visit</code> on forms:</p> <pre><code>&lt;form action='/some_url' data-sg-visit /&gt;\n</code></pre>"},{"location":"ujs/#data-sg-remote","title":"<code>data-sg-remote</code>","text":"<p>Use <code>data-sg-remote</code> when you want to update parts of the current page without reloading the screen.</p> <p>Differences from <code>remote</code></p> <p>The only difference between <code>data-sg-remote</code> and <code>remote</code>, is that <code>data-sg-remote</code> passes the current page as the target <code>pageKey</code> of <code>remote</code>.</p> <p><code>remote</code>, normally would work like a background <code>visit</code> that doesn't change the url and will use the URL of the response to save the payload.</p> <p>But most of the time, if you're using <code>data-sg-remote</code> on a page, you want to dig for <code>props</code> and attach that somewhere in the current page. For convienence, we've modified the call so that we set the <code>pageKey</code> for you.</p> <p>Combine this with props_template's [digging] to selectively load content.</p> <pre><code>&lt;a href='/posts?page_num=2&amp;props_at=data.body.postsList' data-sg-remote/&gt;\n  Next Page\n&lt;/a&gt;\n</code></pre> <p>You can also use <code>data-sg-remote</code> on forms.</p> <pre><code>&lt;form action=\"/posts\" method=\"GET\" data-sg-remote&gt;\n  &lt;input type=\"search\" .... /&gt;\n  ....\n&lt;/form&gt;\n</code></pre>"},{"location":"ujs/#expanding-ujs","title":"Expanding UJS","text":"<p>The dataset of the element enabled with <code>data-sg-visit</code> or <code>data-sg-remote</code> is passed to your application_visit.js. You can add your own options to control the behavior of the UJS helpers. For example, if you want to selectively show a progress bar on some links.</p>"},{"location":"ujs/#data-sg-replace","title":"<code>data-sg-replace</code>","text":"<p>Included in application_visit.js as an expanded option is <code>data-sg-replace</code>. It pairs with <code>data-sg-visit</code> to replace history instead of pushing when a user clicks on a form or a link. This can be useful when working with data tables with a large number of click-to-filter options that push history.</p>"},{"location":"recipes/infinite-scroll/","title":"Infinite scroll","text":"<p>In this recipe, we'll add infinite scroll to our application. Superglue doesn't have an infinite scroll component, but it has tools that make it easy to work with React's ecosystem.</p> <p>Lets begin by adding <code>react-infinite-scroll-hook</code></p> <pre><code>yarn add react-infinite-scroll-hook\n</code></pre> <p>And continue off from our pagination recipe.</p> <p>Tip</p> <p>We'll use the <code>beforeSave</code> callback to modify the payload before superglue saves it to the store. This callback is an option for both <code>visit</code> and <code>remote</code> functions. See the beforeSave reference for more details.</p> <pre><code>// app/views/posts/index.js\n\nimport React from 'react'\n- import {useContent} from '@thoughtbot/superglue'\n+ import {useContent, NavigationContext} from '@thoughtbot/superglue'\nimport PostList from './PostList'\nimport Header from './Header'\n+ import useInfiniteScroll from 'react-infinite-scroll-hook';\n\nexport default PostIndex = () =&gt; {\n  const {\n    posts,\n    header,\n    pathToNextPage,\n    pathToPrevPage\n  } = useContent()\n\n+ const { remote, pageKey } = useContext(NavigationContext)\n+ const { loading, setLoading } = useState(false)\n+ const hasNextPage = !!pathToNextPage\n+\n+ const beforeSave = (prevPage, receivedPage) =&gt; {\n+   const prevPosts = prevPage.data.posts\n+   const receivedPosts = receivedPage.data.posts\n+   receivedPage.data.posts = prevPosts + receivedPosts\n+\n+   return receivedPage\n+ }\n+\n+ const loadMore = () =&gt; {\n+   setLoading(true)\n+   remote(pathToNextPage, {pageKey, beforeSave})\n+     .then(() =&gt; setLoading(false))\n+ }\n+\n+ const [sentryRef] = useInfiniteScroll({\n+   loading,\n+   hasNextPage,\n+   onLoadMore: loadMore,\n+ });\n\n  return (\n    &lt;&gt;\n      &lt;Header {...header}/&gt;\n      &lt;div&gt;\n        {\n          posts.list.map(({id, body}) =&gt; (\n            &lt;p key={id}&gt;{body}&lt;/p&gt;\n          ))\n        }\n+       {(loading || hasNextPage) &amp;&amp; (\n+         &lt;p ref={sentryRef}&gt;\n+           loading\n+         &lt;/p&gt;\n+       )}\n      &lt;/div&gt;\n-     {pathToPrevPage &amp;&amp; &lt;a href={pathToPrevPage} data-sg-visit&gt;Prev Page&lt;/a&gt;}\n-     {pathToNextPage &amp;&amp; &lt;a href={pathToNextPage} data-sg-visit&gt;Next Page&lt;/a&gt;}\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/modals/","title":"Modals","text":"<p>Modals are easy. Lets imagine a scenario where we have two urls:</p> <ol> <li><code>/posts</code></li> <li><code>/posts/new</code></li> </ol> <p>When a user visits <code>/posts/new</code> from <code>/posts</code>, we want a modal to appear overlaying the existing list of posts. The overlay should work if a user chooses instead to directly visit <code>/posts/new</code>.</p>"},{"location":"recipes/modals/#the-setup","title":"The setup","text":"<p>Both urls render a list of posts. Lets set up the controller and the <code>page_to_page_mapping.js</code> the same way.</p> <code>posts_controller.rb</code><code>page_to_page_mapping.js</code> <p>Same template different action</p> <p>Notice that we're rendering the <code>index</code> for the <code>new</code> action. While the content is the same, the <code>componentIdentifier</code> is different as that has been setup to use the controller and action name.</p> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\nend\n\ndef new\n  @posts = Post.all\n  render :index\nend\n</code></pre> <p>Info</p> <p>Similarly, we tie the <code>componentIdentifier</code> to the same page component.</p> <p>Vite Users This step can be entirely optional if you're using Vite. See the recipe for more information.</p> <pre><code>import PostIndex from '../views/posts/index'\n\nexport const pageIdentifierToPageComponent = {\n  'posts/index': PostIndex,\n  'posts/new': PostIndex,\n};\n</code></pre>"},{"location":"recipes/modals/#add-a-link-to-postsnew","title":"Add a link to <code>/posts/new</code>","text":"<p>Imagine a list of posts, lets add a button somewhere on the index page to direct the user to <code>/posts/new</code>. As seen previously, both <code>/posts</code> and <code>/posts/new</code> render the same thing.</p> <code>posts/index.json.props</code><code>posts/index.js</code> <pre><code># app/views/posts/index.json.props\n\n...\n\njson.newPostPath new_post_path\n</code></pre> <pre><code>import { useContent } from '@thoughtbot/superglue'\n\nexport default PostIndex = () =&gt; {\n  const { \n    newPostPath, \n    ...rest \n  } = useContent()\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n      &gt;\n      New Post\n    &lt;/a&gt;\n    ...\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#the-modal","title":"The modal","text":"<p>The link appears and we're able to navigate to <code>/posts/new</code>, but <code>/posts/new</code> is missing a modal. Not surprising as both routes are rendering the same content.</p> <p>Lets add a modal.</p> <code>posts/index.json.props</code><code>index.js</code><code>Modal.js</code> <p>Info</p> <p>For simplicity, we'll use a \"Hello World\" as the modal contents</p> <pre><code># app/views/posts/index.json\n\n...\n\njson.newPostPath new_post_path\n\n+ json.createPostModal do\n+   json.greeting \"Hello World\"\n+ end\n</code></pre> <pre><code>+ import Modal from './Modal'\n\nexport default PostIndex = () =&gt; {\n  const { \n    newPostPath, \n+    createPostModal, \n    ...rest \n  } = useContent()\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n    &gt;\n      New Post\n    &lt;/a&gt;\n+   &lt;Modal {...createPostModal} /&gt;\n    ...\n  )\n}\n</code></pre> <p>Info</p> <p>This is a simplified modal, in practice you'll use this with <code>&lt;Dialog&gt;</code> or other modal library.</p> <pre><code>import Modal from './Modal'\n\nexport default Modal = ({\n  greeting\n}) =&gt; {\n  return (\n    &lt;div className=\"my-modal\"&gt;{greeting}&lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#too-many-modals","title":"Too many modals","text":"<p>Unfortunately, now BOTH routes have modals! Lets fix that by adding a conditional render.</p> <code>index.json.props</code><code>posts_controller.rb</code><code>Modal.js</code> <pre><code># app/views/posts/index.json.props\n\n...\n\njson.newPostPath new_post_path\n\njson.createPostModal do\n  json.greeting \"Hello World\"\n+ json.showModal @show_modal\nend\n</code></pre> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\n+ @show_modal = false\nend\n\ndef new\n  @posts = Post.all\n+ @show_modal = true\n  render :index\nend\n</code></pre> <pre><code>import Modal from './Modal'\n\nexport default Modal = ({\n  greeting,\n+  showModal\n}) =&gt; {\n  return (\n-   &lt;div className=\"my-modal\"&gt;{greeting}&lt;/div&gt;\n+   {showModal &amp;&amp; &lt;div className=\"my-modal\"&gt;{greeting}&lt;/div&gt;}\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#finish","title":"Finish!","text":"<p>Awesome! We have modals! Unfortunately, clicking <code>&lt;a href={newPostPath}&gt;New Post&lt;/a&gt;</code> will cause a new page load. We can remove the page load by adding <code>data-sg-visit</code> to the link. With <code>data-sg-visit</code>, Superglue will navigate to the next page without reloading the page, just like Turbo.</p>"},{"location":"recipes/modals/#postsindexjs","title":"<code>posts/index.js</code>","text":"<pre><code>import Modal from './Modal'\nimport { useContent } from '@thoughtbot/superglue'\n\nexport default PostIndex = () =&gt; {\n  const {\n    newPostPath,\n    createPostModal,\n    ...rest\n  } = useContent()\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n+     data-sg-visit\n    &gt;\n      New Post\n    &lt;/a&gt;\n    &lt;Modal {...createPostModal} /&gt;\n    ...\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#optimization","title":"Optimization","text":"<p>With the above, a click on New Post while on <code>/posts</code> will</p> <ol> <li>Fetch <code>/posts/new</code> with <code>format=json</code></li> <li>Save the page to the store</li> <li>Swap the page components</li> <li>Change the url</li> </ol> <p>Unfortunately, step 1 is still a full page load. Commonly, we just want to load the modal without loading the entire page.</p> <p>Lets fix that!</p>"},{"location":"recipes/modals/#indexjson","title":"<code>index.json</code>","text":"<p>Recall how digging for content works. We'll add a <code>props_at</code> that digs for the modal on <code>/posts/new</code> while skipping other content on that page.</p> <pre><code># app/views/posts/index.json\n\n...\n\n- json.newPostPath new_post_path\n+ json.newPostPath new_post_path(props_at: `data.createPostModal`)\n\njson.createPostModal do\n  json.greeting \"Hello World\"\n  json.showModal @show_modal\nend\n</code></pre> <p>With that change, the sequence becomes:</p> <ol> <li>Copy the state in <code>/posts</code> to <code>/posts/new</code> in the store.</li> <li>Fetch <code>/posts/new?props_at=data.createPostModal</code></li> <li>Graft the result to the store at <code>/posts/new</code></li> <li>Swap the page components</li> <li>Change the url</li> </ol>"},{"location":"recipes/progress-bar/","title":"Progress Bars","text":"<p>Superglue does not come with a progress bar as it can be a personalized choice on how the indicator functions and looks. Instead we have <code>application_visit.js</code> where you can add the functionality however you like.</p> <p>In this recipe, we'll add a simple progress bar that will show when <code>visit</code> and <code>remote</code> gets used. You can choose to implement it for only <code>visit</code> instead.</p> <pre><code>yarn add request-stripe\n</code></pre> <p>And make the following edits to <code>application_visit.js</code></p> <pre><code>import { visit, remote } from '@thoughtbot/superglue/action_creators'\n+ import { requestStripe } from 'request-stripe';\n\nexport function buildVisitAndRemote(ref, store) {\n  const appRemote = (path, {dataset, options} = {}) =&gt; {\n    /**\n     * You can make use of `dataset` to add custom UJS options.\n     * If you are implementing a progress bar, you can selectively\n     * hide it for some links. For example:\n     *\n     * ```\n     * &lt;a href=\"/posts?props_at=data.header\" data-sg-remote data-sg-hide-progress&gt;\n     *   Click me\n     * &lt;/a&gt;\n     * ```\n     *\n     * This would be available as `sgHideProgress` on the dataset\n     */\n+   const done = requestStripe()\n    return store.dispatch(remote(path, options))\n+       .finally(() =&gt; done())\n  }\n\n  const appVisit = (path, {dataset, ...options} = {}) =&gt; {\n+   const done = requestStripe()\n    return store\n      .dispatch(visit(path, options))\n      .then((meta) =&gt; {\n        if (meta.needsRefresh) {\n          window.location = meta.url\n          return\n        }\n\n        ref.current.navigateTo(meta.pageKey, {\n          action: meta.navigationAction,\n        })\n\n        return meta\n      })\n      .finally(() =&gt; {\n+       done()\n      })\n      .catch((err) =&gt; {\n        const response = err.response\n\n        if (!response) {\n          console.error(err)\n          return\n        }\n\n        if (response.ok) {\n          window.location = response.url\n        } else {\n          if (response.status &gt;= 400 &amp;&amp; response.status &lt; 500) {\n            window.location = '/400.html'\n            return\n          }\n\n          if (response.status &gt;= 500) {\n            window.location = '/500.html'\n            return\n          }\n        }\n      })\n  }\n\n  return { visit: appVisit, remote: appRemote }\n}\n</code></pre>"},{"location":"recipes/spa-pagination/","title":"SPA (Single Page Application) Pagination","text":"<p>In this recipe, we'll be adding pagination that works without reloading the page.</p>"},{"location":"recipes/spa-pagination/#starting-point","title":"Starting point","text":"<p>Lets pretend that we're already able to see a list of posts.</p> <code>posts_controller.rb</code><code>index.json.props</code><code>index.js</code> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\nend\n</code></pre> <p>Info</p> <p>In this example, we have a <code>sleep</code> that we will optimize for later</p> <pre><code># app/views/posts/index.json.props\n\njson.header do\n  json.name \"bob\"\n  sleep 2\nend\n\njson.posts do\n  json.list do\n    json.array! @posts do |post|\n      json.id post.id\n      json.body post.body\n      json.editPostPath edit_post_path(post)\n    end\n  end\nend\n</code></pre> <p>Info</p> <p>Let's assume <code>Header</code> is a simple component that exist.</p> <pre><code>// app/views/posts/index.js\n\nimport React from 'react'\nimport {useContent} from '@thoughtbot/superglue'\nimport Header from './Header'\n\nexport default PostIndex = () =&gt; {\n  const {\n    posts,\n    header\n  } = useContent()\n\n  return (\n    &lt;&gt;\n      &lt;Header {...header}/&gt;\n      &lt;div&gt;\n        {\n          posts.list.map(({id, body}) =&gt; (\n            &lt;p key={id}&gt;{body}&lt;/p&gt;\n          ))\n        }\n      &lt;/div&gt;\n      &lt;PostList items={posts}&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/spa-pagination/#add-gems","title":"Add gems","text":"<p>Lets also add Kaminari to your gem file</p> <pre><code>gem 'kaminari'\n</code></pre> <p>and <code>bundle</code></p>"},{"location":"recipes/spa-pagination/#add-pagination","title":"Add pagination","text":"<p>The changes here are almost same with the <code>.erb</code> counterpart. We're using <code>path_to_next_page</code> and <code>path_to_prev_page</code> which come with Kaminari, both methods return <code>nil</code> if there are no subsequent pages.</p> <p>Info</p> <p>Some helpers like <code>paginate</code> output HTML instead of JSON, but we can still use more primitives methods.</p> <code>posts_controller.rb</code><code>index.json.props</code><code>index.js</code> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\n+   .page(params[:page_num])\n+   .per(10)\n+   .order(created_at: :desc)\nend\n</code></pre> <pre><code># app/views/posts/index.json.props\n\njson.posts do\n  json.list do\n    json.array! @posts do |post|\n      json.id post.id\n      json.body post.body\n      json.editPostPath edit_post_path(post)\n    end\n  end\n+\n+ json.pathToNextPage path_to_next_page(@posts)\n+ json.pathToPrevPage path_to_prev_page(@posts)\nend\n</code></pre> <pre><code>// app/views/posts/index.js\n\nimport React from 'react'\nimport {useContent} from '@thoughtbot/superglue'\nimport Header from './Header'\n\nexport default PostIndex = () =&gt; {\n  const {\n    posts,\n    header,\n+   pathToNextPage,\n+   pathToPrevPage\n  } = useContent()\n\n  return (\n    &lt;&gt;\n      &lt;Header {...header}/&gt;\n      &lt;div&gt;\n        {\n          posts.list.map(({id, body}) =&gt; (\n            &lt;p key={id}&gt;{body}&lt;/p&gt;\n          ))\n        }\n      &lt;/div&gt;\n+     {pathToPrevPage &amp;&amp; &lt;a href={pathToPrevPage}&gt;Prev Page&lt;/a&gt;}\n+     {pathToNextPage &amp;&amp; &lt;a href={pathToNextPage}&gt;Next Page&lt;/a&gt;}\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/spa-pagination/#smooth-navigation","title":"Smooth navigation","text":"<p>The above adds pagination, but each click on Next Page is a new page load.</p> <p>Lets navigate without a reload. In this example, we're using the UJS helper <code>data-sg-visit</code>, which would set the current page's state to the response without changing the URL.</p> <p><code>index.js</code></p> <pre><code>// app/views/posts/index.js\n\nimport React from 'react'\nimport {useContent} from '@thoughtbot/superglue'\nimport PostList from './PostList'\nimport Header from './Header'\n\nexport default PostIndex = () =&gt; {\n  const {\n    posts,\n    header,\n    pathToNextPage,\n    pathToPrevPage\n  } = useContent()\n\n  return (\n    &lt;&gt;\n      &lt;Header {...header}/&gt;\n      &lt;div&gt;\n        {\n          posts.list.map(({id, body}) =&gt; (\n            &lt;p key={id}&gt;{body}&lt;/p&gt;\n          ))\n        }\n      &lt;/div&gt;\n-     {pathToPrevPage &amp;&amp; &lt;a href={pathToPrevPage}&gt;Prev Page&lt;/a&gt;}\n+     {pathToPrevPage &amp;&amp; &lt;a href={pathToPrevPage} data-sg-visit&gt;Prev Page&lt;/a&gt;}\n-     {pathToNextPage &amp;&amp; &lt;a href={pathToNextPage}&gt;Next Page&lt;/a&gt;}\n+     {pathToNextPage &amp;&amp; &lt;a href={pathToNextPage} data-sg-visit&gt;Next Page&lt;/a&gt;}\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/spa-pagination/#optimize","title":"Optimize!","text":"<p>Let's skip <code>data.header</code> when navigating and dig for <code>data.posts</code>. For the user, only the posts list changes, but the header stays the same.</p> <p>Info</p> <p>In effect, this achieves the same functionality as Turbo Frames, but Superglue leans more on Unobtrusive Javascript for better ergonomics.</p> <p><code>index.json.props</code></p> <p>Recall how digging for content works. We'll add a <code>props_at</code> that digs for the <code>json.posts</code> while skipping other content on that page.</p> <pre><code># app/views/posts/index.json.props\n\njson.header do\n  ...\nend\n\njson.posts do\n  json.list do\n    json.array! @posts do |post|\n      json.id post.id\n      json.body post.body\n      json.editPostPath edit_post_path(post)\n    end\n  end\n\n- json.pathToNextPage path_to_next_page(@posts)\n+ json.pathToNextPage path_to_next_page(@posts, props_at: 'data.posts')\n- json.pathToPrevPage path_to_prev_page(@posts)\n+ json.pathToPrevPage path_to_prev_page(@posts, props_at: 'data.posts')\nend\n</code></pre> <ul> <li> Interested in infinite-scroll?      for <code>visit</code></li> </ul>"},{"location":"recipes/ssr/","title":"Server-Side Rendering","text":"<p>Superglue's generators does not include Server Side Rendering, but we can add support using Humid, a SSR library built for Superglue.</p> <p>Follow the instructions. Then, if you're using esbuild, create a <code>app/javascript/server_rendering.js</code>:</p> <pre><code>import React from 'react';\nimport { Application } from '@thoughtbot/superglue';\nimport { buildVisitAndRemote } from './application_visit';\nimport { pageIdentifierToPageComponent } from './page_to_page_mapping';\nimport { store } from './store'\nimport { renderToString } from 'react-dom/server';\n\nrequire(\"source-map-support\").install({\n  retrieveSourceMap: filename =&gt; {\n    return {\n      url: filename,\n      map: readSourceMap(filename)\n    };\n  }\n});\n\nsetHumidRenderer((json, baseUrl, path) =&gt; {\n  const initialState = JSON.parse(json)\n  return renderToString(\n    &lt;Application\n      className=\"full-height\"\n      // The base url prefixed to all calls made by the `visit`\n      // and `remote` thunks.\n      baseUrl={baseUrl}\n      // The global var SUPERGLUE_INITIAL_PAGE_STATE is set by your erb\n      // template, e.g., application/superglue.html.erb\n      initialPage={initialState}\n      // The initial path of the page, e.g., /foobar\n      path={path}\n      // Callback used to setup visit and remote\n      buildVisitAndRemote={buildVisitAndRemote}\n      // Callback used to setup the store\n      store={store}\n      // Mapping between the page identifier to page component\n      mapping={pageIdentifierToPageComponent}\n    /&gt;,\n    {\n      concurrentFeatures: false,\n    }\n  )\n})\n</code></pre> <p>Next</p> <pre><code>yarn add esbuild-plugin-polyfill-node text-encoding whatwg-url\n</code></pre> <p>and add a esbuild build file.</p> <pre><code>import * as esbuild from 'esbuild'\nimport { polyfillNode } from \"esbuild-plugin-polyfill-node\";\n\n\nawait esbuild.build({\n  entryPoints: ['app/javascript/server_rendering.js'],\n  bundle: true,\n  platform: \"browser\",\n  define: {\n    \"process.env.NODE_ENV\": '\"production\"'\n  },\n  sourcemap: true,\n  outfile: 'app/assets/builds/server_rendering.js',\n  logLevel: \"info\",\n  loader: {\n    \".js\": \"jsx\",\n    \".svg\": \"dataurl\"\n  },\n  inject: [\"./shim.js\"],\n  plugins: [\n    polyfillNode({\n      globals: false\n    }),\n  ]\n})\n</code></pre> <p>Add a <code>shim.js</code> for the above. We'll need this for the v8 environment that mini-racer runs on.</p> <pre><code>export {TextEncoder, TextDecoder} from 'text-encoding'\nexport { URL, URLSearchParams } from 'whatwg-url'\n\nexport function MessageChannel() {\n  this.port1 = {\n    postMessage: function (message) {\n      console.log('Message sent from port1:', message);\n    },\n  };\n\n  this.port2 = {\n    addEventListener: function (event, handler) {\n      console.log(`Event listener added for ${event} on port2`);\n      this._eventHandler = handler;\n    },\n    removeEventListener: function (event) {\n      console.log(`Event listener removed for ${event} on port2`);\n      this._eventHandler = null;\n    },\n    simulateMessage: function (data) {\n      if (this._eventHandler) {\n        this._eventHandler({ data });\n      }\n    },\n  };\n}\n\nexport const navigator = {language: \"en-us\"}\n</code></pre> <p>Add a line to your <code>package.json</code> like so:</p> <pre><code>   \"scripts\": {\n+    \"build:ssr\": \"node ./build-ssr.mjs\"\n</code></pre> <p>Use <code>Humid.render</code> in all your <code>html</code> templates, e.g., <code>index.html.erb</code> or <code>superglue.html.erb</code>:</p> <pre><code>  &lt;script type=\"text/javascript\"&gt;\n-   window.SUPERGLUE_INITIAL_PAGE_STATE=&lt;%= render_props %&gt;;&lt;%# erblint:disable ErbSafety %&gt;\n+   &lt;% initial_state = render_props %&gt;\n+   window.SUPERGLUE_INITIAL_PAGE_STATE=&lt;%= initial_state %&gt;;&lt;%# erblint:disable ErbSafety %&gt;\n  &lt;/script&gt;\n- &lt;div id=\"app\"&gt;&lt;/div&gt;\n+ &lt;div id=\"app\"&gt;&lt;%= Humid.render(initial_state, request.scheme + '://' + request.host_with_port, request.fullpath).html_safe %&gt;&lt;/div&gt;\n</code></pre> <p>!&gt; Do not render spacing inside of <code>&lt;div id=\"app\"&gt;</code>. If you do, React will not hydrate properly and warn <code>Hydration failed because the initial UI does not match what was rendered on the server</code></p> <p>Change your <code>application.js</code> to use <code>hydrateRoot</code>:</p> <pre><code>- import { createRoot } from 'react-dom/client';\n+ import { hydrateRoot } from 'react-dom/client';\n</code></pre> <p>and change the rest of <code>application.js</code> accordingly. For example:</p> <pre><code>import React from 'react';\nimport { Application, VisitResponse } from '@thoughtbot/superglue';\nimport { hydrateRoot } from 'react-dom/client';\nimport { buildVisitAndRemote } from './application_visit';\nimport { pageIdentifierToPageComponent } from './page_to_page_mapping';\nimport { store } from './store'\n\nif (typeof window !== \"undefined\") {\n  document.addEventListener(\"DOMContentLoaded\", function () {\n    const appEl = document.getElementById(\"app\");\n    const location = window.location;\n\n    if (appEl) {\n      hydrateRoot(appEl,\n        &lt;Application\n          className=\"full-height\"\n          // The base url prefixed to all calls made by the `visit`\n          // and `remote` thunks.\n          baseUrl={location.origin}\n          // The global var SUPERGLUE_INITIAL_PAGE_STATE is set by your erb\n          // template, e.g., index.html.erb\n          initialPage={window.SUPERGLUE_INITIAL_PAGE_STATE}\n          // The initial path of the page, e.g., /foobar\n          path={location.pathname + location.search + location.hash}\n          // Callback used to setup visit and remote\n          buildVisitAndRemote={buildVisitAndRemote}\n          // Callback used to setup the store\n          store={store}\n          // Mapping between the page identifier to page component\n          mapping={pageIdentifierToPageComponent}\n        /&gt;\n      );\n    }\n  });\n}\n</code></pre> <p>and add build script your <code>package.json</code> to build both the client and server js bundles. For example:</p> <pre><code>   \"build\": \"yarn run build:web &amp;&amp; yarn run build:ssr\",\n   \"build:web\": \"esbuild app/javascript/application.js --bundle --sourcemap --outdir=app/assets/builds --loader:.js=jsx --loader:.svg=dataurl --public-path=/assets\",\n   \"build:ssr\": \"node ./build-ssr.mjs\",\n</code></pre>"},{"location":"recipes/turbo/","title":"Replicating Turbo behavior","text":"<p>With <code>data-sg-visit</code>, Superglue will always wait for a response before a navigation transition. Turbo's behavior is to transition first if possible while waiting for the response. To replicate this behavior:</p> <p>In your <code>application_visit.js</code> file:</p> <pre><code>+ import { urlToPageKey } from '@thoughtbot/superglue'\n\nconst appVisit = (...args) =&gt; {\n\n  const pageKey = urlToPageKey(args[0])\n+ // attempt to navigate first\n+ ref.current?.navigateTo(pageKey)\n\n  return store\n    .dispatch(visit(...args))\n    ....\n</code></pre> <p>This is different from restore strategy which controls what happens when the browser's <code>history</code> object pops.</p>"},{"location":"recipes/vite/","title":"Usage with vite","text":"<p>While you can use any js bundler you want with Superglue. Vite has conveniences that make working with Superglue easier.</p> <p>To get started, go ahead and follow the instructions to install vite_rails</p> <p>Next move your <code>app/javascript/entrypoints/application.jsx</code> file to <code>app/javascript/entrypoints/application.jsx</code> and update the references.</p> <p>Info</p> <p>When using Superglue's installation generator, a <code>app/javascript/application.jsx</code> gets generated. <code>vite_rails</code> expects this to be put in an <code>entrypoints</code> folder. If you're installing <code>vite_rails</code> after superglue's installation, the is set by <code>vite_rails</code> to be <code>app/javascript/entrypoints</code>.</p> <p>Migrate your <code>@views</code>, <code>@javascript</code> aliases to <code>vite.config.mts</code></p> <pre><code>import { defineConfig } from \"vite\";\nimport path from \"path\";\n\nimport RubyPlugin from \"vite-plugin-ruby\";\n\nexport default defineConfig({\n  resolve: {\n    alias: {\n      \"@views\": path.resolve(__dirname, \"app/views\"),\n      \"@javascript\": path.resolve(__dirname, \"app/javascript\"),\n    },\n  },\n  plugins: [RubyPlugin()],\n});\n</code></pre> <p>Make sure you're using <code>vite_javascript_tag</code> in your layout, <code>application.html.erb</code>.</p> <pre><code>&lt;%= vite_javascript_tag 'application.jsx' %&gt;\n</code></pre> <p>And finally, one of the more manual process of using superglue is the manual build of your <code>page_to_page_mapping.js</code> file. We can improve the developer experience by  removing that step by using this snippet:</p> <pre><code>const pageIdentifierToPageComponent = {}\nconst pages = import.meta.glob('../views/**/*.jsx', {eager: true})\n\nfor (const key in pages) {\n  if (pages.hasOwnProperty(key)) {\n    const identifier = key.replace(\"../views/\", \"\").split('.')[0];\n    pageIdentifierToPageComponent[identifier] = pages[key].default;\n  }\n}\n\nexport { pageIdentifierToPageComponent }\n</code></pre>"},{"location":"reference/","title":"Superglue","text":""},{"location":"reference/#variables","title":"Variables","text":""},{"location":"reference/#grafting_error","title":"GRAFTING_ERROR","text":"<p><code>const</code> GRAFTING_ERROR: <code>\"@@superglue/GRAFTING_ERROR\"</code> = <code>'@@superglue/GRAFTING_ERROR'</code></p> <p>Defined in: actions.ts:12</p> <p></p>"},{"location":"reference/#grafting_success","title":"GRAFTING_SUCCESS","text":"<p><code>const</code> GRAFTING_SUCCESS: <code>\"@@superglue/GRAFTING_SUCCESS\"</code> = <code>'@@superglue/GRAFTING_SUCCESS'</code></p> <p>Defined in: actions.ts:13</p> <p></p>"},{"location":"reference/#saveresponse","title":"saveResponse","text":"<p><code>const</code> saveResponse: <code>ActionCreatorWithPreparedPayload</code>\\&lt;[{ <code>pageKey</code>: <code>string</code>; <code>page</code>: <code>SaveResponse</code>; }], { <code>pageKey</code>: <code>string</code>; <code>page</code>: <code>SaveResponse</code>; }, <code>\"@@superglue/SAVE_RESPONSE\"</code>, <code>never</code>, <code>never</code>&gt;</p> <p>Defined in: actions.ts:15</p> <p></p>"},{"location":"reference/#copypage","title":"copyPage","text":"<p><code>const</code> copyPage: <code>ActionCreatorWithPayload</code>\\&lt;{ <code>from</code>: <code>string</code>; <code>to</code>: <code>string</code>; }, <code>string</code>&gt;</p> <p>Defined in: actions.ts:61</p> <p>A redux action you can dispatch to copy a page from one pageKey to another. Its a very useful way to create optimistic updates with a URL change. For example:</p> <pre><code>import { copyPage, remote } from '@thoughtbot/superglue'\n\ndispatch(copyPage({ from: originalKey, to: targetKey}))\n\n... make edits to target page and finally\n\nnavigateTo(targetKey)\n</code></pre> <p></p>"},{"location":"reference/#removepage","title":"removePage","text":"<p><code>const</code> removePage: <code>ActionCreatorWithPayload</code>\\&lt;{ <code>pageKey</code>: <code>string</code>; }, <code>string</code>&gt;</p> <p>Defined in: actions.ts:74</p> <p>A redux action you can dispatch to remove a page from your store.</p> <pre><code>import { removePage } from '@thoughtbot/superglue'\n\ndispatch(removePage({ pageKey: '/delete_me_please\"}))\n</code></pre> <p></p>"},{"location":"reference/#beforefetch","title":"beforeFetch","text":"<p><code>const</code> beforeFetch: <code>ActionCreatorWithPayload</code>\\&lt;{ <code>fetchArgs</code>: <code>FetchArgs</code>; }, <code>string</code>&gt;</p> <p>Defined in: actions.ts:92</p> <p>A redux action called before a <code>fetch</code> takes place. It will fire in <code>remote</code> and <code>visit</code>. You can hook into this event in your redux slices like this:</p> <pre><code>import { beforeFetch } from '@thoughtbot/superglue'\n\nexport const exampleSlice = createSlice({\n name: 'Example',\n initialState: {},\n extraReducers: (builder) =&gt; {\n   builder.addCase(beforeFetch, (state, action) =&gt; {\n</code></pre> <p></p>"},{"location":"reference/#beforevisit","title":"beforeVisit","text":"<p><code>const</code> beforeVisit: <code>ActionCreatorWithPayload</code>\\&lt;{ <code>currentPageKey</code>: <code>string</code>; <code>fetchArgs</code>: <code>FetchArgs</code>; }, <code>string</code>&gt;</p> <p>Defined in: actions.ts:110</p> <p>A redux action called before a <code>visit</code> takes place. You can hook into this event in your redux slices like this:</p> <pre><code>import { beforeVisit } from '@thoughtbot/superglue'\n\nexport const exampleSlice = createSlice({\n name: 'Example',\n initialState: {},\n extraReducers: (builder) =&gt; {\n   builder.addCase(beforeVisit, (state, action) =&gt; {\n</code></pre> <p></p>"},{"location":"reference/#beforeremote","title":"beforeRemote","text":"<p><code>const</code> beforeRemote: <code>ActionCreatorWithPayload</code>\\&lt;{ <code>currentPageKey</code>: <code>string</code>; <code>fetchArgs</code>: <code>FetchArgs</code>; }, <code>string</code>&gt;</p> <p>Defined in: actions.ts:129</p> <p>A redux action called before <code>remote</code> takes place. You can hook into this event in your redux slices like this:</p> <pre><code>import { beforeRemote } from '@thoughtbot/superglue'\n\nexport const exampleSlice = createSlice({\n name: 'Example',\n initialState: {},\n extraReducers: (builder) =&gt; {\n   builder.addCase(beforeRemote, (state, action) =&gt; {\n</code></pre> <p></p>"},{"location":"reference/#receiveresponse","title":"receiveResponse","text":"<p><code>const</code> receiveResponse: <code>ActionCreatorWithPreparedPayload</code>\\&lt;[{ <code>pageKey</code>: <code>string</code>; <code>response</code>: <code>PageResponse</code>; }], { <code>pageKey</code>: <code>string</code>; <code>response</code>: <code>PageResponse</code>; }, <code>\"@@superglue/RECEIVE_RESPONSE\"</code>, <code>never</code>, <code>never</code>&gt;</p> <p>Defined in: actions.ts:176</p> <p></p>"},{"location":"reference/#rootreducer","title":"rootReducer","text":"<p><code>const</code> rootReducer: { <code>superglue</code>: (<code>state</code>: <code>SuperglueState</code>, <code>action</code>: <code>Action</code>) =&gt; <code>SuperglueState</code>; <code>pages</code>: (<code>state</code>: <code>AllPages</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllPages</code>; <code>fragments</code>: (<code>state</code>: <code>AllFragments</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllFragments</code>; }</p> <p>Defined in: reducers/index.ts:290</p>"},{"location":"reference/#type-declaration","title":"Type declaration","text":"Name Type Default value Defined in <code>superglue()</code> (<code>state</code>: <code>SuperglueState</code>, <code>action</code>: <code>Action</code>) =&gt; <code>SuperglueState</code> <code>superglueReducer</code> reducers/index.ts:291 <code>pages()</code> (<code>state</code>: <code>AllPages</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllPages</code> <code>pageReducer</code> reducers/index.ts:292 <code>fragments()</code> (<code>state</code>: <code>AllFragments</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllFragments</code> <code>fragmentReducer</code> reducers/index.ts:293"},{"location":"reference/#functions","title":"Functions","text":""},{"location":"reference/#saveandprocesspage","title":"saveAndProcessPage()","text":"<p>saveAndProcessPage(<code>pageKey</code>: <code>string</code>, <code>page</code>: <code>PageResponse</code>): <code>SaveAndProcessPageThunk</code></p> <p>Defined in: action_creators/index.ts:91</p> <p>Save and process a rendered view from PropsTemplate. This is the primitive function that <code>visit</code> and <code>remote</code> calls when it receives a page.</p> <p>If you render a page outside the normal request response cycle, e.g, websocket, you can use this function to save the payload.</p>"},{"location":"reference/#parameters","title":"Parameters","text":"Parameter Type <code>pageKey</code> <code>string</code> <code>page</code> <code>PageResponse</code>"},{"location":"reference/#returns","title":"Returns","text":"<p><code>SaveAndProcessPageThunk</code></p> <p></p>"},{"location":"reference/#usesetfragment","title":"useSetFragment()","text":"<p>useSetFragment(): {\\&lt;<code>T</code>&gt;(<code>fragmentRef</code>: <code>T</code>, <code>updater</code>: (<code>draft</code>: <code>Unproxy</code>\\&lt;<code>Unpack</code>\\&lt;<code>T</code>&gt;&gt;) =&gt; <code>void</code>): <code>void</code>; \\&lt;<code>T</code>&gt;(<code>fragmentId</code>: <code>string</code>, <code>updater</code>: (<code>draft</code>: <code>T</code>) =&gt; <code>void</code>): <code>void</code>; }</p> <p>Defined in: hooks/useSetFragment.tsx:37</p> <p>Hook for mutating fragments using Immer drafts.</p>"},{"location":"reference/#returns_1","title":"Returns","text":"<p>\\&lt;<code>T</code>&gt;(<code>fragmentRef</code>: <code>T</code>, <code>updater</code>: (<code>draft</code>: <code>Unproxy</code>\\&lt;<code>Unpack</code>\\&lt;<code>T</code>&gt;&gt;) =&gt; <code>void</code>): <code>void</code></p> <p>Updates a fragment using a FragmentRef object.</p>"},{"location":"reference/#type-parameters","title":"Type Parameters","text":"Type Parameter <code>T</code> extends <code>Fragment</code>\\&lt;<code>unknown</code>, <code>unknown</code>&gt;"},{"location":"reference/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>fragmentRef</code> <code>T</code> Fragment reference object containing __id <code>updater</code> (<code>draft</code>: <code>Unproxy</code>\\&lt;<code>Unpack</code>\\&lt;<code>T</code>&gt;&gt;) =&gt; <code>void</code> Immer draft function for mutating fragment data"},{"location":"reference/#returns_2","title":"Returns","text":"<p><code>void</code></p> <p>\\&lt;<code>T</code>&gt;(<code>fragmentId</code>: <code>string</code>, <code>updater</code>: (<code>draft</code>: <code>T</code>) =&gt; <code>void</code>): <code>void</code></p> <p>Updates a fragment using a fragment ID string.</p>"},{"location":"reference/#type-parameters_1","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>unknown</code>"},{"location":"reference/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>fragmentId</code> <code>string</code> The fragment ID string <code>updater</code> (<code>draft</code>: <code>T</code>) =&gt; <code>void</code> Immer draft function for mutating fragment data"},{"location":"reference/#returns_3","title":"Returns","text":"<p><code>void</code></p>"},{"location":"reference/#example","title":"Example","text":"<pre><code>const set = useSetFragment()\n\n// Update via fragment reference\nset(userRef, draft =&gt; {\n  draft.name = \"Updated Name\"\n  draft.email = \"new@email.com\"\n})\n\n// Update via fragment ID directly\nset('user_123', draft =&gt; {\n  draft.profile.bio = \"Updated bio\"\n})\n</code></pre>"},{"location":"reference/#usestreamsource","title":"useStreamSource()","text":"<p>useStreamSource(<code>channel</code>: <code>StreamSourceProps</code>): { <code>connected</code>: <code>boolean</code>; <code>subscription</code>: <code>null</code> | <code>Subscription</code>\\&lt;<code>Consumer</code>&gt;; }</p> <p>Defined in: hooks/useStreamSource.tsx:172</p> <p>Creates a subscription to an ActionCable channel for real-time streaming updates.</p> <p>This hook manages the lifecycle of an ActionCable subscription, automatically connecting when the cable is available and cleaning up on unmount. Stream messages are processed through StreamActions to update the Redux store.</p> <p>Typically used with channel configuration generated by the Rails helper <code>stream_from_props</code> helper in your <code>props</code> templates.</p> <p>*</p>"},{"location":"reference/#parameters_3","title":"Parameters","text":"Parameter Type Description <code>channel</code> <code>StreamSourceProps</code> Channel configuration as string or ChannelNameWithParams object, typically generated by Rails <code>stream_from_props</code> helper"},{"location":"reference/#returns_4","title":"Returns","text":"<p>Object containing connection status and subscription instance</p> Name Type Description Defined in <code>connected</code> <code>boolean</code> Whether the ActionCable subscription is currently connected hooks/useStreamSource.tsx:174 <code>subscription</code> <code>null</code> | <code>Subscription</code>\\&lt;<code>Consumer</code>&gt; The active ActionCable subscription instance, null if not connected hooks/useStreamSource.tsx:176"},{"location":"reference/#examples","title":"Examples","text":"<p>Using the helper:</p> <p><pre><code># app/views/chat_rooms/show.json.props\njson.chatChannel stream_from_props(\"messages\")\n</code></pre> <pre><code>const content = useContent()\nconst { connected } = useStreamSource(content.chatChannel)\n</code></pre></p> <p>Basic channel subscription: <pre><code>const { connected } = useStreamSource('ChatChannel')\n</code></pre></p> <p>Channel with parameters: <pre><code>const { connected } = useStreamSource({\n  channel: 'ChatChannel',\n  room_id: roomId\n})\n</code></pre></p> <p>Using connection status: <pre><code>const { connected, subscription } = useStreamSource('NotificationsChannel')\n\nreturn (\n  &lt;div&gt;\n    {connected ? 'Connected' : 'Connecting...'}\n    {subscription &amp;&amp; &lt;span&gt;Subscription active&lt;/span&gt;}\n  &lt;/div&gt;\n)\n</code></pre></p> <p></p>"},{"location":"reference/#preparestore","title":"prepareStore()","text":"<p>prepareStore(<code>store</code>: <code>SuperglueStore</code>, <code>initialPage</code>: <code>SaveResponse</code>, <code>path</code>: <code>string</code>): <code>void</code></p> <p>Defined in: index.tsx:71</p>"},{"location":"reference/#parameters_4","title":"Parameters","text":"Parameter Type <code>store</code> <code>SuperglueStore</code> <code>initialPage</code> <code>SaveResponse</code> <code>path</code> <code>string</code>"},{"location":"reference/#returns_5","title":"Returns","text":"<p><code>void</code></p> <p></p>"},{"location":"reference/#setup","title":"setup()","text":"<p>setup(<code>__namedParameters</code>: <code>SetupProps</code>): { <code>visit</code>: <code>ApplicationVisit</code>; <code>remote</code>: <code>ApplicationRemote</code>; <code>nextHistory</code>: <code>History</code>; <code>initialPageKey</code>: <code>string</code>; <code>ujs</code>: <code>Handlers</code>; <code>streamActions</code>: <code>StreamActions</code>; }</p> <p>Defined in: index.tsx:95</p> <p>This is the setup function that the Application calls. Use this function if you like to build your own Application component.</p>"},{"location":"reference/#parameters_5","title":"Parameters","text":"Parameter Type <code>__namedParameters</code> <code>SetupProps</code>"},{"location":"reference/#returns_6","title":"Returns","text":"<p>{ <code>visit</code>: <code>ApplicationVisit</code>; <code>remote</code>: <code>ApplicationRemote</code>; <code>nextHistory</code>: <code>History</code>; <code>initialPageKey</code>: <code>string</code>; <code>ujs</code>: <code>Handlers</code>; <code>streamActions</code>: <code>StreamActions</code>; }</p> Name Type Default value Defined in <code>visit</code> <code>ApplicationVisit</code> - index.tsx:123 <code>remote</code> <code>ApplicationRemote</code> - index.tsx:124 <code>nextHistory</code> <code>History</code> - index.tsx:125 <code>initialPageKey</code> <code>string</code> - index.tsx:126 <code>ujs</code> <code>Handlers</code> <code>handlers</code> index.tsx:127 <code>streamActions</code> <code>StreamActions</code> - index.tsx:128 <p></p>"},{"location":"reference/#application","title":"Application()","text":"<p>Application(<code>__namedParameters</code>: <code>ApplicationProps</code>): <code>Element</code></p> <p>Defined in: index.tsx:139</p> <p>The entry point to your superglue application. It sets up the redux Provider, redux state and the Navigation component.</p> <p>This is a simple component, you can override this by copying the source code and use the exported methods used by this component (<code>start</code> and <code>ujsHandler</code>).</p>"},{"location":"reference/#parameters_6","title":"Parameters","text":"Parameter Type <code>__namedParameters</code> <code>ApplicationProps</code>"},{"location":"reference/#returns_7","title":"Returns","text":"<p><code>Element</code></p> <p></p>"},{"location":"reference/#pagereducer","title":"pageReducer()","text":"<p>pageReducer(<code>state</code>: <code>AllPages</code>, <code>action</code>: <code>Action</code>): <code>AllPages</code></p> <p>Defined in: reducers/index.ts:159</p>"},{"location":"reference/#parameters_7","title":"Parameters","text":"Parameter Type <code>state</code> <code>AllPages</code> <code>action</code> <code>Action</code>"},{"location":"reference/#returns_8","title":"Returns","text":"<p><code>AllPages</code></p> <p></p>"},{"location":"reference/#supergluereducer","title":"superglueReducer()","text":"<p>superglueReducer(<code>state</code>: <code>SuperglueState</code>, <code>action</code>: <code>Action</code>): <code>SuperglueState</code></p> <p>Defined in: reducers/index.ts:192</p>"},{"location":"reference/#parameters_8","title":"Parameters","text":"Parameter Type <code>state</code> <code>SuperglueState</code> <code>action</code> <code>Action</code>"},{"location":"reference/#returns_9","title":"Returns","text":"<p><code>SuperglueState</code></p> <p></p>"},{"location":"reference/#getin","title":"getIn()","text":"<p>getIn(<code>node</code>: <code>JSONMappable</code>, <code>path</code>: <code>string</code>): <code>JSONValue</code></p> <p>Defined in: utils/immutability.ts:22</p> <p>Retrieves data from a JSON object using a Keypath</p>"},{"location":"reference/#parameters_9","title":"Parameters","text":"Parameter Type Description <code>node</code> <code>JSONMappable</code> <code>path</code> <code>string</code>"},{"location":"reference/#returns_10","title":"Returns","text":"<p><code>JSONValue</code></p> <p></p>"},{"location":"reference/#urltopagekey","title":"urlToPageKey()","text":"<p>urlToPageKey(<code>url</code>: <code>string</code>): <code>string</code></p> <p>Defined in: utils/url.ts:49</p> <p>Converts a url to a PageKey.</p>"},{"location":"reference/#parameters_10","title":"Parameters","text":"Parameter Type Description <code>url</code> <code>string</code>"},{"location":"reference/#returns_11","title":"Returns","text":"<p><code>string</code></p>"},{"location":"reference/#references","title":"References","text":""},{"location":"reference/#usecontent","title":"useContent","text":"<p>Re-exports useContent</p> <p></p>"},{"location":"reference/#usesuperglue","title":"useSuperglue","text":"<p>Re-exports useSuperglue</p> <p></p>"},{"location":"reference/#navigationprovider","title":"NavigationProvider","text":"<p>Re-exports NavigationProvider</p> <p></p>"},{"location":"reference/#navigationcontext","title":"NavigationContext","text":"<p>Re-exports NavigationContext</p> <p></p>"},{"location":"reference/#unproxy","title":"unproxy","text":"<p>Re-exports unproxy</p> <p></p>"},{"location":"reference/#fetchargs","title":"FetchArgs","text":"<p>Re-exports FetchArgs</p> <p></p>"},{"location":"reference/#graftingsuccessaction","title":"GraftingSuccessAction","text":"<p>Re-exports GraftingSuccessAction</p> <p></p>"},{"location":"reference/#graftingerroraction","title":"GraftingErrorAction","text":"<p>Re-exports GraftingErrorAction</p> <p></p>"},{"location":"reference/#pagekey","title":"PageKey","text":"<p>Re-exports PageKey</p> <p></p>"},{"location":"reference/#restorestrategy","title":"RestoreStrategy","text":"<p>Re-exports RestoreStrategy</p> <p></p>"},{"location":"reference/#navigationaction","title":"NavigationAction","text":"<p>Re-exports NavigationAction</p> <p></p>"},{"location":"reference/#componentidentifier","title":"ComponentIdentifier","text":"<p>Re-exports ComponentIdentifier</p> <p></p>"},{"location":"reference/#keypath","title":"Keypath","text":"<p>Re-exports Keypath</p> <p></p>"},{"location":"reference/#jsonprimitive","title":"JSONPrimitive","text":"<p>Re-exports JSONPrimitive</p> <p></p>"},{"location":"reference/#jsonobject","title":"JSONObject","text":"<p>Re-exports JSONObject</p> <p></p>"},{"location":"reference/#jsonmappable","title":"JSONMappable","text":"<p>Re-exports JSONMappable</p> <p></p>"},{"location":"reference/#jsonkeyable","title":"JSONKeyable","text":"<p>Re-exports JSONKeyable</p> <p></p>"},{"location":"reference/#jsonvalue","title":"JSONValue","text":"<p>Re-exports JSONValue</p> <p></p>"},{"location":"reference/#fragment","title":"Fragment","text":"<p>Re-exports Fragment</p> <p></p>"},{"location":"reference/#unproxy_1","title":"Unproxy","text":"<p>Re-exports Unproxy</p> <p></p>"},{"location":"reference/#parsedresponse","title":"ParsedResponse","text":"<p>Re-exports ParsedResponse</p> <p></p>"},{"location":"reference/#defer","title":"Defer","text":"<p>Re-exports Defer</p> <p></p>"},{"location":"reference/#saveresponse_1","title":"SaveResponse","text":"<p>Re-exports SaveResponse</p> <p></p>"},{"location":"reference/#page","title":"Page","text":"<p>Re-exports Page</p> <p></p>"},{"location":"reference/#graftresponse","title":"GraftResponse","text":"<p>Re-exports GraftResponse</p> <p></p>"},{"location":"reference/#streammessage","title":"StreamMessage","text":"<p>Re-exports StreamMessage</p> <p></p>"},{"location":"reference/#streamresponse","title":"StreamResponse","text":"<p>Re-exports StreamResponse</p> <p></p>"},{"location":"reference/#pageresponse","title":"PageResponse","text":"<p>Re-exports PageResponse</p> <p></p>"},{"location":"reference/#fragmentpath","title":"FragmentPath","text":"<p>Re-exports FragmentPath</p> <p></p>"},{"location":"reference/#fragmentref","title":"FragmentRef","text":"<p>Re-exports FragmentRef</p> <p></p>"},{"location":"reference/#allpages","title":"AllPages","text":"<p>Re-exports AllPages</p> <p></p>"},{"location":"reference/#allfragments","title":"AllFragments","text":"<p>Re-exports AllFragments</p> <p></p>"},{"location":"reference/#supergluestate","title":"SuperglueState","text":"<p>Re-exports SuperglueState</p> <p></p>"},{"location":"reference/#rootstate","title":"RootState","text":"<p>Re-exports RootState</p> <p></p>"},{"location":"reference/#meta","title":"Meta","text":"<p>Re-exports Meta</p> <p></p>"},{"location":"reference/#visitmeta","title":"VisitMeta","text":"<p>Re-exports VisitMeta</p> <p></p>"},{"location":"reference/#visitcreator","title":"VisitCreator","text":"<p>Re-exports VisitCreator</p> <p></p>"},{"location":"reference/#remotecreator","title":"RemoteCreator","text":"<p>Re-exports RemoteCreator</p> <p></p>"},{"location":"reference/#dispatch","title":"Dispatch","text":"<p>Re-exports Dispatch</p> <p></p>"},{"location":"reference/#supergluestore","title":"SuperglueStore","text":"<p>Re-exports SuperglueStore</p> <p></p>"},{"location":"reference/#handlers","title":"Handlers","text":"<p>Re-exports Handlers</p> <p></p>"},{"location":"reference/#ujshandlers","title":"UJSHandlers","text":"<p>Re-exports UJSHandlers</p> <p></p>"},{"location":"reference/#historystate","title":"HistoryState","text":"<p>Re-exports HistoryState</p> <p></p>"},{"location":"reference/#saveandprocesspagethunk","title":"SaveAndProcessPageThunk","text":"<p>Re-exports SaveAndProcessPageThunk</p> <p></p>"},{"location":"reference/#metathunk","title":"MetaThunk","text":"<p>Re-exports MetaThunk</p> <p></p>"},{"location":"reference/#visitmetathunk","title":"VisitMetaThunk","text":"<p>Re-exports VisitMetaThunk</p> <p></p>"},{"location":"reference/#defermentthunk","title":"DefermentThunk","text":"<p>Re-exports DefermentThunk</p> <p></p>"},{"location":"reference/#basicrequestinit","title":"BasicRequestInit","text":"<p>Re-exports BasicRequestInit</p> <p></p>"},{"location":"reference/#navigateto","title":"NavigateTo","text":"<p>Re-exports NavigateTo</p> <p></p>"},{"location":"reference/#navigationcontextprops","title":"NavigationContextProps","text":"<p>Re-exports NavigationContextProps</p> <p></p>"},{"location":"reference/#navigationproviderprops","title":"NavigationProviderProps","text":"<p>Re-exports NavigationProviderProps</p> <p></p>"},{"location":"reference/#buildstore","title":"BuildStore","text":"<p>Re-exports BuildStore</p> <p></p>"},{"location":"reference/#buildvisitandremote","title":"BuildVisitAndRemote","text":"<p>Re-exports BuildVisitAndRemote</p> <p></p>"},{"location":"reference/#setupprops","title":"SetupProps","text":"<p>Re-exports SetupProps</p> <p></p>"},{"location":"reference/#applicationprops","title":"ApplicationProps","text":"<p>Re-exports ApplicationProps</p> <p></p>"},{"location":"reference/#visit","title":"Visit","text":"<p>Re-exports Visit</p> <p></p>"},{"location":"reference/#visitprops","title":"VisitProps","text":"<p>Re-exports VisitProps</p> <p></p>"},{"location":"reference/#remote","title":"Remote","text":"<p>Re-exports Remote</p> <p></p>"},{"location":"reference/#remoteprops","title":"RemoteProps","text":"<p>Re-exports RemoteProps</p> <p></p>"},{"location":"reference/#beforesave","title":"BeforeSave","text":"<p>Re-exports BeforeSave</p> <p></p>"},{"location":"reference/#applicationremote","title":"ApplicationRemote","text":"<p>Re-exports ApplicationRemote</p> <p></p>"},{"location":"reference/#applicationvisit","title":"ApplicationVisit","text":"<p>Re-exports ApplicationVisit</p>"},{"location":"reference/components.Navigation/","title":"Navigation","text":""},{"location":"reference/components.Navigation/#variables","title":"Variables","text":""},{"location":"reference/components.Navigation/#navigationcontext","title":"NavigationContext","text":"<p><code>const</code> NavigationContext: <code>Context</code>\\&lt;<code>NavigationContextProps</code>&gt;</p> <p>Defined in: components/Navigation.tsx:23</p> <p></p>"},{"location":"reference/components.Navigation/#navigationprovider","title":"NavigationProvider","text":"<p><code>const</code> NavigationProvider: <code>ForwardRefExoticComponent</code>\\&lt;<code>NavigationProviderProps</code> &amp; <code>RefAttributes</code>\\&lt;{ <code>navigateTo</code>: <code>null</code> | <code>NavigateTo</code>; }&gt;&gt;</p> <p>Defined in: components/Navigation.tsx:47</p>"},{"location":"reference/hooks/","title":"Hooks","text":""},{"location":"reference/hooks/#functions","title":"Functions","text":""},{"location":"reference/hooks/#usesuperglue","title":"useSuperglue()","text":"<p>useSuperglue(): <code>SuperglueState</code></p> <p>Defined in: hooks/index.ts:10</p> <p>A lightweight hook that grabs the superglue state from the store.</p>"},{"location":"reference/hooks/#returns","title":"Returns","text":"<p><code>SuperglueState</code></p>"},{"location":"reference/hooks/#references","title":"References","text":""},{"location":"reference/hooks/#usecontent","title":"useContent","text":"<p>Re-exports useContent</p> <p></p>"},{"location":"reference/hooks/#unproxy","title":"unproxy","text":"<p>Re-exports unproxy</p> <p></p>"},{"location":"reference/hooks/#usesetfragment","title":"useSetFragment","text":"<p>Re-exports useSetFragment</p> <p></p>"},{"location":"reference/hooks/#usestreamsource","title":"useStreamSource","text":"<p>Re-exports useStreamSource</p>"},{"location":"reference/hooks.useContent/","title":"hooks.useContent","text":""},{"location":"reference/hooks.useContent/#type-aliases","title":"Type Aliases","text":""},{"location":"reference/hooks.useContent/#fragmentproxy","title":"FragmentProxy","text":"<p>FragmentProxy = { <code>__fragment</code>: <code>true</code>; }</p> <p>Defined in: hooks/useContent.tsx:13</p>"},{"location":"reference/hooks.useContent/#properties","title":"Properties","text":""},{"location":"reference/hooks.useContent/#__fragment","title":"__fragment","text":"<p>__fragment: <code>true</code></p> <p>Defined in: hooks/useContent.tsx:13</p> <p></p>"},{"location":"reference/hooks.useContent/#proxiedcontentt","title":"ProxiedContent\\&lt;T&gt;","text":"<p>ProxiedContent\\&lt;<code>T</code>&gt; = <code>T</code> extends <code>Fragment</code>\\&lt;infer U, <code>true</code>&gt; ? <code>ProxiedContent</code>\\&lt;<code>U</code>&gt; &amp; <code>FragmentProxy</code> : <code>T</code> extends <code>Fragment</code>\\&lt;infer U, <code>false</code> | <code>undefined</code>&gt; ? <code>ProxiedContent</code>\\&lt;<code>U</code>&gt; &amp; <code>FragmentProxy</code> | <code>undefined</code> : <code>T</code> extends infer U[] ? <code>ProxiedContent</code>\\&lt;<code>U</code>&gt;[] : <code>T</code> extends <code>object</code> ? <code>{ [K in keyof T]: ProxiedContent&lt;T[K]&gt; }</code> : <code>T</code></p> <p>Defined in: hooks/useContent.tsx:18</p> <p>A proxy type that enables reactive access to nested content with automatic fragment resolution</p>"},{"location":"reference/hooks.useContent/#type-parameters","title":"Type Parameters","text":"Type Parameter <code>T</code>"},{"location":"reference/hooks.useContent/#fragmentreforid","title":"FragmentRefOrId","text":"<p>FragmentRefOrId = <code>FragmentRef</code> | <code>string</code></p> <p>Defined in: hooks/useContent.tsx:32</p> <p>Union type for fragment references, accepting either FragmentRef objects or string IDs</p>"},{"location":"reference/hooks.useContent/#functions","title":"Functions","text":""},{"location":"reference/hooks.useContent/#usecontent","title":"useContent()","text":""},{"location":"reference/hooks.useContent/#call-signature","title":"Call Signature","text":"<p>useContent\\&lt;<code>T</code>&gt;(): <code>ProxiedContent</code>\\&lt;<code>T</code>&gt;</p> <p>Defined in: hooks/useContent.tsx:78</p> <p>Returns a proxy for accessing your page's content e.g, <code>index.json.props</code>, <code>show.json.props</code>, etc.</p> <p>For advanced scenarios where you are using Fragments.</p> <pre><code>{\n  data: {\n    body: {\n      cart: {__id: 'user_cart'}\n    },\n   footer: {title: \"welcome\"}},\n  },\n  fragments: {user_cart: {total: 100}}\n}\n</code></pre> <p>The proxy will lazily and automatically resolve any FragmentRefs making it as easy as</p> <pre><code>const data = useContent()\nconst total = data.body.cart.total\n</code></pre> <p>The hook will also automatically tracks fragment dependencies and triggers re-renders only when accessed fragments change.</p>"},{"location":"reference/hooks.useContent/#type-parameters_1","title":"Type Parameters","text":"Type Parameter Default type Description <code>T</code> <code>JSONMappable</code> The data type being accessed (defaults to JSONMappable)"},{"location":"reference/hooks.useContent/#returns","title":"Returns","text":"<p><code>ProxiedContent</code>\\&lt;<code>T</code>&gt;</p> <p>Reactive proxy to page data or fragment data, undefined if fragment not found</p>"},{"location":"reference/hooks.useContent/#example","title":"Example","text":"<pre><code>// Access current page data\nconst page = useContent()\n\n// Access specific fragment by reference\nconst user = useContent({__id: 'user_123'})\n\n// Access specific fragment by ID string\nconst cart = useContent('userCart')\n</code></pre>"},{"location":"reference/hooks.useContent/#call-signature_1","title":"Call Signature","text":"<p>useContent\\&lt;<code>T</code>&gt;(<code>fragmentRef</code>: <code>FragmentRefOrId</code>): <code>ProxiedContent</code>\\&lt;<code>T</code>&gt;</p> <p>Defined in: hooks/useContent.tsx:108</p> <p>Passing in a fragment to useContent allows us to scope the tracking of fragments to that hook usage. Its useful in performance scenarios where you want a child component to update, but not the parent.</p> <pre><code>import {unproxy} from '@thoughtbot/superglue'\n\nconst content = useContent()\nconst rawContent = unproxy(content)\n\n&lt;h1&gt;{content.title}&lt;/h1&gt;\n&lt;SlidingCart cartRef={rawContent.cart} /&gt;\n</code></pre> <p>then in SlidingCart</p> <pre><code>const SlidingCart = (cartRef) =&gt; {\n  const cart = useContent(cartRef)\n}\n</code></pre> <p>SlidingCart will update only if the fragment referenced by <code>cartRef</code> updates.</p>"},{"location":"reference/hooks.useContent/#type-parameters_2","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/hooks.useContent/#parameters","title":"Parameters","text":"Parameter Type Description <code>fragmentRef</code> <code>FragmentRefOrId</code> Optional fragment reference for scoped access"},{"location":"reference/hooks.useContent/#returns_1","title":"Returns","text":"<p><code>ProxiedContent</code>\\&lt;<code>T</code>&gt;</p> <p></p>"},{"location":"reference/hooks.useContent/#unproxy","title":"unproxy()","text":"<p>unproxy\\&lt;<code>T</code>&gt;(<code>proxy</code>: <code>T</code>): <code>Unproxy</code>\\&lt;<code>T</code>&gt;</p> <p>Defined in: hooks/useContent.tsx:172</p> <p>Extracts the underlying state from an useContent proxy</p>"},{"location":"reference/hooks.useContent/#type-parameters_3","title":"Type Parameters","text":"Type Parameter <code>T</code>"},{"location":"reference/hooks.useContent/#parameters_1","title":"Parameters","text":"Parameter Type <code>proxy</code> <code>T</code>"},{"location":"reference/hooks.useContent/#returns_2","title":"Returns","text":"<p><code>Unproxy</code>\\&lt;<code>T</code>&gt;</p>"},{"location":"reference/types.actions/","title":"Actions","text":""},{"location":"reference/types.actions/#interfaces","title":"Interfaces","text":""},{"location":"reference/types.actions/#graftingsuccessaction","title":"GraftingSuccessAction","text":"<p>Defined in: types/actions.ts:11</p>"},{"location":"reference/types.actions/#extends","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types.actions/#properties","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>string</code> <code>Action.type</code> types/actions.ts:12 <code>payload</code> { <code>pageKey</code>: <code>string</code>; <code>keyPath</code>: <code>string</code>; } - types/actions.ts:13 <code>payload.pageKey</code> <code>string</code> - types/actions.ts:14 <code>payload.keyPath</code> <code>string</code> - types/actions.ts:15"},{"location":"reference/types.actions/#graftingerroraction","title":"GraftingErrorAction","text":"<p>Defined in: types/actions.ts:19</p>"},{"location":"reference/types.actions/#extends_1","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types.actions/#properties_1","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>string</code> <code>Action.type</code> types/actions.ts:20 <code>payload</code> { <code>pageKey</code>: <code>string</code>; <code>url</code>: <code>string</code>; <code>err</code>: <code>unknown</code>; <code>keyPath</code>: <code>string</code>; } - types/actions.ts:21 <code>payload.pageKey</code> <code>string</code> - types/actions.ts:22 <code>payload.url</code> <code>string</code> - types/actions.ts:23 <code>payload.err</code> <code>unknown</code> - types/actions.ts:24 <code>payload.keyPath</code> <code>string</code> - types/actions.ts:25"},{"location":"reference/types.actions/#type-aliases","title":"Type Aliases","text":""},{"location":"reference/types.actions/#fetchargs","title":"FetchArgs","text":"<p>FetchArgs = [<code>string</code>, <code>BasicRequestInit</code>]</p> <p>Defined in: types/actions.ts:7</p> <p>Tuple of Fetch arguments that Superglue passes to Fetch.</p>"},{"location":"reference/types/","title":"Types","text":""},{"location":"reference/types/#interfaces","title":"Interfaces","text":""},{"location":"reference/types/#parsedresponse","title":"ParsedResponse","text":"<p>Defined in: types/index.ts:171</p>"},{"location":"reference/types/#properties","title":"Properties","text":"Property Type Defined in <code>rsp</code> <code>Response</code> types/index.ts:172 <code>json</code> <code>PageResponse</code> types/index.ts:173"},{"location":"reference/types/#defer","title":"Defer","text":"<p>Defined in: types/index.ts:197</p> <p>Defer is a node in the page response thats been intentionally filled with empty or placeholder data for the purposes of fetching it later.</p> <p>You would typically use it with props_template for parts of a page that you know would be slower to load.</p>"},{"location":"reference/types/#properties_1","title":"Properties","text":"Property Type Description Defined in <code>url</code> <code>string</code> A url with props_at keypath in the query parameter to indicate how to dig for the data, and where to place the data. types/index.ts:198 <code>type</code> <code>\"auto\"</code> | <code>\"manual\"</code> When set to <code>auto</code> Superglue will automatically make the request using the <code>url</code>. When set to <code>manual</code>, Superglue does nothing, and you would need to manually use <code>remote</code> with the <code>url</code> to fetch the missing data. types/index.ts:199 <code>path</code> <code>string</code> A keypath indicates how to dig for the data and where to place the data. types/index.ts:200 <code>successAction</code> <code>string</code> a user defined action for Superglue to dispatch when auto deferement is successful types/index.ts:201 <code>failAction</code> <code>string</code> a user defined action for Superglue to dispatch when auto deferement failed types/index.ts:202"},{"location":"reference/types/#graftresponset","title":"GraftResponse\\&lt;T&gt;","text":"<p>Defined in: types/index.ts:238</p> <p>The GraftResponse is responsible for partial updates using props_template's digging functionality in Superglue.</p>"},{"location":"reference/types/#type-parameters","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#properties_2","title":"Properties","text":"Property Type Description Defined in <code>data</code> <code>T</code> - types/index.ts:239 <code>componentIdentifier</code> <code>string</code> - types/index.ts:240 <code>assets</code> <code>string</code>[] - types/index.ts:241 <code>csrfToken?</code> <code>string</code> - types/index.ts:242 <code>fragments</code> <code>FragmentPath</code>[] - types/index.ts:243 <code>defers</code> <code>Defer</code>[] - types/index.ts:244 <code>slices</code> <code>JSONObject</code> - types/index.ts:245 <code>action</code> <code>\"graft\"</code> - types/index.ts:246 <code>renderedAt</code> <code>number</code> - types/index.ts:247 <code>path</code> <code>string</code> Used by superglue to replace the data at that location. types/index.ts:249 <code>fragmentContext?</code> <code>string</code> - types/index.ts:250"},{"location":"reference/types/#fragmentpath","title":"FragmentPath","text":"<p>Defined in: types/index.ts:287</p> <p>A FragmentPath identifies a fragment inside of a PageResponse. Its used internally by Superglue to denormalize a page response into fragments, if any.</p>"},{"location":"reference/types/#properties_3","title":"Properties","text":"Property Type Description Defined in <code>id</code> <code>string</code> - types/index.ts:288 <code>path</code> <code>string</code> A Keypath specifying the location of the fragment types/index.ts:289"},{"location":"reference/types/#fragmentref","title":"FragmentRef","text":"<p>Defined in: types/index.ts:300</p> <p>A FragmentRef is a reference to a Fragment.</p>"},{"location":"reference/types/#properties_4","title":"Properties","text":"Property Type Description Defined in <code>__id</code> <code>string</code> A user supplied string identifying the fragment. This is usually created using props_template types/index.ts:301"},{"location":"reference/types/#supergluestate","title":"SuperglueState","text":"<p>Defined in: types/index.ts:320</p> <p>A read only state that contains meta information about the current page.</p>"},{"location":"reference/types/#properties_5","title":"Properties","text":"Property Type Description Defined in <code>currentPageKey</code> <code>string</code> The PageKey (url pathname + search) of the current page. This can be pass to Remote. types/index.ts:322 <code>search</code> <code>Record</code>\\&lt;<code>string</code>, <code>string</code> | <code>undefined</code>&gt; The query string object of the current url. types/index.ts:324 <code>csrfToken?</code> <code>string</code> The Rails csrfToken that you can use for forms. types/index.ts:326 <code>assets</code> <code>string</code>[] The tracked asset digests. types/index.ts:328"},{"location":"reference/types/#rootstatet","title":"RootState\\&lt;T&gt;","text":"<p>Defined in: types/index.ts:335</p> <p>The root state for a Superglue application. It occupies 2 keys in your app.</p>"},{"location":"reference/types/#type-parameters_1","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#indexable","title":"Indexable","text":"<p>[<code>name</code>: <code>string</code>]: <code>unknown</code></p>"},{"location":"reference/types/#properties_6","title":"Properties","text":"Property Type Description Defined in <code>superglue</code> <code>SuperglueState</code> Contains readonly metadata about the current page types/index.ts:337 <code>pages</code> <code>AllPages</code>\\&lt;<code>T</code>&gt; Every PageResponse that superglue recieves is stored here. types/index.ts:339 <code>fragments</code> <code>AllFragments</code> - types/index.ts:340"},{"location":"reference/types/#meta","title":"Meta","text":"<p>Defined in: types/index.ts:349</p> <p>Meta is passed to the Promise when visit or remote resolves and contains additional information for navigation.</p>"},{"location":"reference/types/#extended-by","title":"Extended by","text":"<ul> <li><code>VisitMeta</code></li> </ul>"},{"location":"reference/types/#properties_7","title":"Properties","text":"Property Type Description Defined in <code>pageKey</code> <code>string</code> The URL of the response converted to a pageKey. Superglue uses this to persist the SaveResponse to store, when that happens. types/index.ts:354 <code>page</code> <code>PageResponse</code> The SaveResponse of the page types/index.ts:356 <code>redirected</code> <code>boolean</code> Indicates if response was redirected types/index.ts:358 <code>rsp</code> <code>Response</code> The original response object types/index.ts:360 <code>fetchArgs</code> <code>FetchArgs</code> The original args passed to fetch. types/index.ts:362 <code>componentIdentifier?</code> <code>string</code> The ComponentIdentifier extracted from the response. types/index.ts:364 <code>needsRefresh</code> <code>boolean</code> <code>true</code> when assets locally are detected to be out of date types/index.ts:366"},{"location":"reference/types/#visitmeta","title":"VisitMeta","text":"<p>Defined in: types/index.ts:369</p> <p>Meta is passed to the Promise when visit or remote resolves and contains additional information for navigation.</p>"},{"location":"reference/types/#extends","title":"Extends","text":"<ul> <li><code>Meta</code></li> </ul>"},{"location":"reference/types/#properties_8","title":"Properties","text":"Property Type Description Inherited from Defined in <code>pageKey</code> <code>string</code> The URL of the response converted to a pageKey. Superglue uses this to persist the SaveResponse to store, when that happens. <code>Meta</code>.<code>pageKey</code> types/index.ts:354 <code>page</code> <code>PageResponse</code> The SaveResponse of the page <code>Meta</code>.<code>page</code> types/index.ts:356 <code>redirected</code> <code>boolean</code> Indicates if response was redirected <code>Meta</code>.<code>redirected</code> types/index.ts:358 <code>rsp</code> <code>Response</code> The original response object <code>Meta</code>.<code>rsp</code> types/index.ts:360 <code>fetchArgs</code> <code>FetchArgs</code> The original args passed to fetch. <code>Meta</code>.<code>fetchArgs</code> types/index.ts:362 <code>componentIdentifier?</code> <code>string</code> The ComponentIdentifier extracted from the response. <code>Meta</code>.<code>componentIdentifier</code> types/index.ts:364 <code>needsRefresh</code> <code>boolean</code> <code>true</code> when assets locally are detected to be out of date <code>Meta</code>.<code>needsRefresh</code> types/index.ts:366 <code>navigationAction</code> <code>NavigationAction</code> The NavigationAction. This can be used for navigation. - types/index.ts:371"},{"location":"reference/types/#handlers","title":"Handlers","text":"<p>Defined in: types/index.ts:414</p>"},{"location":"reference/types/#properties_9","title":"Properties","text":"Property Type Defined in <code>onClick</code> (<code>event</code>: <code>MouseEvent</code>\\&lt;<code>HTMLDivElement</code>, <code>MouseEvent</code>&gt;) =&gt; <code>void</code> types/index.ts:415 <code>onSubmit</code> (<code>event</code>: <code>FormEvent</code>\\&lt;<code>HTMLDivElement</code>&gt;) =&gt; <code>void</code> types/index.ts:416"},{"location":"reference/types/#historystate","title":"HistoryState","text":"<p>Defined in: types/index.ts:436</p> <p>The state that is saved to history.state. Superglue stores information about the current page so that it can restore the page state when navigating back</p>"},{"location":"reference/types/#properties_10","title":"Properties","text":"Property Type Description Defined in <code>superglue</code> <code>true</code> Is always <code>true</code> so superglue can differentiate pages that have superglue enabled or not types/index.ts:438 <code>pageKey</code> <code>string</code> The page key in SuperglueState to restore from types/index.ts:440 <code>posX</code> <code>number</code> The scroll position X of the page types/index.ts:442 <code>posY</code> <code>number</code> The scroll position Y of the page types/index.ts:444"},{"location":"reference/types/#basicrequestinit","title":"BasicRequestInit","text":"<p>Defined in: types/index.ts:470</p> <p>A variation of RequestInit except the headers must be a regular object</p>"},{"location":"reference/types/#extends_1","title":"Extends","text":"<ul> <li><code>RequestInit</code></li> </ul>"},{"location":"reference/types/#properties_11","title":"Properties","text":"Property Type Description Overrides Defined in <code>headers?</code> {[<code>key</code>: <code>string</code>]: <code>string</code>; } A Headers object, an object literal, or an array of two-item arrays to set request's headers. <code>RequestInit.headers</code> types/index.ts:471"},{"location":"reference/types/#navigationcontextprops","title":"NavigationContextProps","text":"<p>Defined in: types/index.ts:519</p> <p>Superglue comes with a Navigation component that provides a context with access to Visit, Remote and other useful tooling.</p> <p>You can also use this to build your own <code>&lt;Link&gt;</code> component.</p>"},{"location":"reference/types/#properties_12","title":"Properties","text":"Property Type Description Defined in <code>navigateTo</code> <code>NavigateTo</code> - types/index.ts:520 <code>visit</code> <code>ApplicationVisit</code> - types/index.ts:521 <code>remote</code> <code>ApplicationRemote</code> - types/index.ts:522 <code>pageKey</code> <code>string</code> The pagekey that's being used to render the current page component. Useful when used in combination with Remote to create requests that target the current page. types/index.ts:523 <code>search</code> <code>Record</code>\\&lt;<code>string</code>, <code>undefined</code> | <code>string</code>&gt; The current pageKey (current url) query params as an object. types/index.ts:524"},{"location":"reference/types/#navigationproviderprops","title":"NavigationProviderProps","text":"<p>Defined in: types/index.ts:536</p> <p>This is the navigation component that gets used by ApplicationProps. The component takes a mapping of page components and swaps them when navigating and passes NavigateTo to all page components.</p>"},{"location":"reference/types/#properties_13","title":"Properties","text":"Property Type Description Defined in <code>history</code> <code>History</code> - types/index.ts:537 <code>visit</code> <code>ApplicationVisit</code> - types/index.ts:538 <code>remote</code> <code>ApplicationRemote</code> - types/index.ts:539 <code>mapping</code> <code>Record</code>\\&lt;<code>ComponentIdentifier</code>, <code>React.ComponentType</code>&gt; - types/index.ts:540 <code>initialPageKey</code> <code>string</code> The PageKey that's to be used when first rendering. Used to determine the initial page component to show. types/index.ts:541"},{"location":"reference/types/#buildstore","title":"BuildStore()","text":"<p>Defined in: types/index.ts:552</p> <p>Provide this callback to ApplicationProps returning a Redux store for Superglue to use. This would be setup and generated for you in <code>store.js</code>. We recommend using using Redux toolkit's <code>configureStore</code> to build the store.</p> <p>BuildStore(<code>initialState</code>: <code>RootState</code>, <code>reducer</code>: { <code>superglue</code>: (<code>state</code>: <code>SuperglueState</code>, <code>action</code>: <code>Action</code>) =&gt; <code>SuperglueState</code>; <code>pages</code>: (<code>state</code>: <code>AllPages</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllPages</code>; <code>fragments</code>: (<code>state</code>: <code>AllFragments</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllFragments</code>; }): <code>SuperglueStore</code></p> <p>Defined in: types/index.ts:553</p> <p>Provide this callback to ApplicationProps returning a Redux store for Superglue to use. This would be setup and generated for you in <code>store.js</code>. We recommend using using Redux toolkit's <code>configureStore</code> to build the store.</p>"},{"location":"reference/types/#parameters","title":"Parameters","text":"Parameter Type Description <code>initialState</code> <code>RootState</code> A preconfigured intial state to pass to your store. <code>reducer</code> { <code>superglue</code>: (<code>state</code>: <code>SuperglueState</code>, <code>action</code>: <code>Action</code>) =&gt; <code>SuperglueState</code>; <code>pages</code>: (<code>state</code>: <code>AllPages</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllPages</code>; <code>fragments</code>: (<code>state</code>: <code>AllFragments</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllFragments</code>; } A preconfigured reducer <code>reducer.superglue</code> (<code>state</code>: <code>SuperglueState</code>, <code>action</code>: <code>Action</code>) =&gt; <code>SuperglueState</code> - <code>reducer.pages</code> (<code>state</code>: <code>AllPages</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllPages</code> - <code>reducer.fragments</code> (<code>state</code>: <code>AllFragments</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllFragments</code> -"},{"location":"reference/types/#returns","title":"Returns","text":"<p><code>SuperglueStore</code></p> <p></p>"},{"location":"reference/types/#buildvisitandremote","title":"BuildVisitAndRemote()","text":"<p>Defined in: types/index.ts:568</p> <p>Provide this callback to ApplicationProps returning a visit and remote function. These functions will be used by Superglue to power its UJS attributes and passed to your page components and NavigationContextProps. You may customize this functionality to your liking, e.g, adding a progress bar.</p> <p>BuildVisitAndRemote(<code>navigatorRef</code>: <code>RefObject</code>\\&lt;<code>null</code> | { <code>navigateTo</code>: <code>NavigateTo</code>; }&gt;, <code>store</code>: <code>SuperglueStore</code>): { <code>visit</code>: <code>ApplicationVisit</code>; <code>remote</code>: <code>ApplicationRemote</code>; }</p> <p>Defined in: types/index.ts:569</p>"},{"location":"reference/types/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>navigatorRef</code> <code>RefObject</code>\\&lt;<code>null</code> | { <code>navigateTo</code>: <code>NavigateTo</code>; }&gt; <code>store</code> <code>SuperglueStore</code>"},{"location":"reference/types/#returns_1","title":"Returns","text":"<p>{ <code>visit</code>: <code>ApplicationVisit</code>; <code>remote</code>: <code>ApplicationRemote</code>; }</p> Name Type Defined in <code>visit</code> <code>ApplicationVisit</code> types/index.ts:573 <code>remote</code> <code>ApplicationRemote</code> types/index.ts:574 <p></p>"},{"location":"reference/types/#setupprops","title":"SetupProps","text":"<p>Defined in: types/index.ts:578</p>"},{"location":"reference/types/#properties_14","title":"Properties","text":"Property Type Description Defined in <code>initialPage</code> <code>SaveResponse</code> The global var SUPERGLUE_INITIAL_PAGE_STATE is set by your erb template, e.g., application/superglue.html.erb types/index.ts:583 <code>baseUrl</code> <code>string</code> The base url prefixed to all calls made by <code>visit</code> and <code>remote</code>. types/index.ts:588 <code>path</code> <code>string</code> The path of the current page. It should equal to the <code>location.pathname</code> + <code>location.search</code> + <code>location.hash</code> types/index.ts:593 <code>store</code> <code>SuperglueStore</code> The exported store from store.js. If you used the generators it would contain slices for superglue, pages, and the flash. types/index.ts:598 <code>buildVisitAndRemote</code> <code>BuildVisitAndRemote</code> A factory function that will return a <code>visit</code> and <code>remote</code> function. All of Superglue and UJS will use these functions. You should customize the function, for example, to add a progress bar. types/index.ts:605 <code>history?</code> <code>History</code> An optional history object https://github.com/remix-run/history. If none is provided Superglue will create one for you. types/index.ts:610 <code>navigatorRef</code> <code>RefObject</code>\\&lt;<code>null</code> | { <code>navigateTo</code>: <code>NavigateTo</code>; }&gt; A ref object created from the Application component that will be passed to buildVisitAndRemote types/index.ts:614"},{"location":"reference/types/#applicationprops","title":"ApplicationProps","text":"<p>Defined in: types/index.ts:622</p> <p>Props for the <code>Application</code> component</p>"},{"location":"reference/types/#extends_2","title":"Extends","text":"<ul> <li><code>ComponentPropsWithoutRef</code>\\&lt;<code>\"div\"</code>&gt;</li> </ul>"},{"location":"reference/types/#properties_15","title":"Properties","text":"Property Type Description Defined in <code>initialPage</code> <code>SaveResponse</code> The global var SUPERGLUE_INITIAL_PAGE_STATE is set by your erb template, e.g., application/superglue.html.erb types/index.ts:628 <code>baseUrl</code> <code>string</code> The base url prefixed to all calls made by <code>visit</code> and <code>remote</code>. types/index.ts:633 <code>path</code> <code>string</code> The path of the current page. It should equal to the <code>location.pathname</code> + <code>location.search</code> + <code>location.hash</code> types/index.ts:638 <code>buildVisitAndRemote</code> <code>BuildVisitAndRemote</code> A factory function that will return a <code>visit</code> and <code>remote</code> function. All of Superglue and UJS will use these functions. You should customize the function, for example, to add a progress bar. types/index.ts:645 <code>mapping</code> <code>Record</code>\\&lt;<code>string</code>, <code>React.ComponentType</code>&gt; A mapping between your page props and page component. This is setup for you in page_to_page_mapping. types/index.ts:650 <code>history?</code> <code>History</code> An optional history object https://github.com/remix-run/history. If none is provided Superglue will create one for you. types/index.ts:655 <code>store</code> <code>SuperglueStore</code> The exported store from store.js. If you used the generators it would contain slices for superglue, pages, and the flash. types/index.ts:660"},{"location":"reference/types/#type-aliases","title":"Type Aliases","text":""},{"location":"reference/types/#pagekey","title":"PageKey","text":"<p>PageKey = <code>string</code></p> <p>Defined in: types/index.ts:23</p> <p>A PageKey is a combination of a parsed URL's pathname + query string. No hash.</p> <p>*</p>"},{"location":"reference/types/#example","title":"Example","text":"<pre><code>/posts?foobar=123\n</code></pre>"},{"location":"reference/types/#restorestrategy","title":"RestoreStrategy","text":"<p>RestoreStrategy = <code>\"fromCacheOnly\"</code> | <code>\"revisitOnly\"</code> | <code>\"fromCacheAndRevisitInBackground\"</code></p> <p>Defined in: types/index.ts:39</p> <p>Defines the behavior when navigating to a page that is already stored on the client. For example, when navigating back.</p> <p>When the page already exists in the store: - <code>fromCacheOnly</code> - Use the cached page that exists on the store, only. - <code>revisitOnly</code> - Ignore the cache and make a request for the latest page. If the response was 200, the NavigationAction would be <code>none</code> as we don't want to push into history. If the response was redirected, the NavigationAction would be set to <code>replace</code>. - <code>fromCacheAndRevisitInBackground</code> - Use the cache version of the page so    superglue can optimistically navigate to it, then make an additional request    for the latest version.</p> <p></p>"},{"location":"reference/types/#navigationaction","title":"NavigationAction","text":"<p>NavigationAction = <code>\"push\"</code> | <code>\"replace\"</code> | <code>\"none\"</code></p> <p>Defined in: types/index.ts:48</p> <p>A NavigationAction is used to tell Superglue to history.push, history.replace or do nothing.</p> <p></p>"},{"location":"reference/types/#componentidentifier","title":"ComponentIdentifier","text":"<p>ComponentIdentifier = <code>string</code></p> <p>Defined in: types/index.ts:54</p> <p>An identifier that Superglue will uses to determine which page component to render with your page response.</p> <p></p>"},{"location":"reference/types/#keypath","title":"Keypath","text":"<p>Keypath = <code>string</code></p> <p>Defined in: types/index.ts:78</p> <p>A keypath is a string representing the location of a piece of data. Superglue uses the keypath to dig for or update data.</p>"},{"location":"reference/types/#examples","title":"Examples","text":"<p>Object access <pre><code>data.header.avatar\n</code></pre></p> <p>Array access <pre><code>data.body.posts.0.title\n</code></pre></p> <p>Array with lookahead <pre><code>data.body.posts.post_id=foobar.title\n</code></pre></p> <p></p>"},{"location":"reference/types/#jsonprimitive","title":"JSONPrimitive","text":"<p>JSONPrimitive = <code>string</code> | <code>number</code> | <code>boolean</code> | <code>null</code> | <code>undefined</code></p> <p>Defined in: types/index.ts:85</p> <p>A JSON Primitive value</p> <p></p>"},{"location":"reference/types/#jsonobject","title":"JSONObject","text":"<p>JSONObject = {[<code>key</code>: <code>string</code>]: <code>JSONValue</code>; }</p> <p>Defined in: types/index.ts:90</p> <p>A JSON Object</p>"},{"location":"reference/types/#index-signature","title":"Index Signature","text":"<p>[<code>key</code>: <code>string</code>]: <code>JSONValue</code></p> <p></p>"},{"location":"reference/types/#jsonmappable","title":"JSONMappable","text":"<p>JSONMappable = <code>JSONValue</code>[] | <code>JSONObject</code></p> <p>Defined in: types/index.ts:97</p> <p>A JSON Object or an array of values</p> <p></p>"},{"location":"reference/types/#jsonkeyable","title":"JSONKeyable","text":"<p>JSONKeyable = <code>JSONObject</code>[] | <code>JSONObject</code></p> <p>Defined in: types/index.ts:102</p> <p>A array of JSON key value objects or a JSON Object</p> <p></p>"},{"location":"reference/types/#jsonvalue","title":"JSONValue","text":"<p>JSONValue = <code>JSONPrimitive</code> | <code>JSONMappable</code></p> <p>Defined in: types/index.ts:107</p> <p>A primitive or a mappable object</p> <p></p>"},{"location":"reference/types/#fragmentt-present","title":"Fragment\\&lt;T, Present&gt;","text":"<p>Fragment\\&lt;<code>T</code>, <code>Present</code>&gt; = { <code>__id</code>: <code>string</code>; <code>__fragmentType?</code>: <code>T</code>; <code>__required?</code>: <code>Present</code> extends <code>boolean</code> ? <code>Present</code> : <code>false</code>; }</p> <p>Defined in: types/index.ts:146</p> <p>A Fragment is a rendered Rails partial with an identity. The use of this type is optional, but it makes usage with unproxy and useSetFragment type friendly.</p> <p>In general, Fragments enable normalized state management where Rails partials become referenceable entities on the client. The server renders partials as fragments with unique IDs, then Superglue normalizes them into a separate fragments store while replacing the original data with fragment references.</p>"},{"location":"reference/types/#examples_1","title":"Examples","text":"<pre><code>{\n  \"data\": { \"cart\": { \"__id\": \"userCart\" } },\n  \"fragments\": [{ \"type\": \"userCart\", \"path\": [\"cart\"] }]\n}\n</code></pre> <pre><code>{\n  pages: { \"/page\": { data: { cart: { __id: \"userCart\" } } } },\n  fragments: { \"userCart\": { items: [...], totalCost: 69.97 } }\n}\n</code></pre> <pre><code>type PageData = {\n  cart: Fragment&lt;{ items: Item[]; totalCost: number }, true&gt;;\n  user?: Fragment&lt;{ name: string; email: string }&gt;; // Optional fragment\n}\n\nconst content = useContent&lt;PageData&gt;()\nconst cart = content.cart // Resolves fragment reference to actual data\n</code></pre>"},{"location":"reference/types/#type-parameters_2","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> - <code>Present</code> <code>false</code>"},{"location":"reference/types/#properties_16","title":"Properties","text":""},{"location":"reference/types/#__id","title":"__id","text":"<p>__id: <code>string</code></p> <p>Defined in: types/index.ts:148</p> <p>The fragment ID *</p> <p></p>"},{"location":"reference/types/#__fragmenttype","title":"__fragmentType?","text":"<p><code>optional</code> __fragmentType: <code>T</code></p> <p>Defined in: types/index.ts:150</p> <p>Phantom type, please ignore *</p> <p></p>"},{"location":"reference/types/#__required","title":"__required?","text":"<p><code>optional</code> __required: <code>Present</code> extends <code>boolean</code> ? <code>Present</code> : <code>false</code></p> <p>Defined in: types/index.ts:152</p> <p>Phantom type, please ignore *</p> <p></p>"},{"location":"reference/types/#unproxyt","title":"Unproxy\\&lt;T&gt;","text":"<p>Unproxy\\&lt;<code>T</code>&gt; = <code>T</code> extends <code>FragmentProxy</code> ? <code>FragmentRef</code> : <code>T</code> extends <code>Fragment</code>\\&lt;<code>unknown</code>, <code>unknown</code>&gt; ? <code>FragmentRef</code> : <code>T</code> extends infer U[] ? <code>Unproxy</code>\\&lt;<code>U</code>&gt;[] : <code>T</code> extends <code>object</code> ? <code>{ [K in keyof T]: Unproxy&lt;T[K]&gt; }</code> : <code>T</code></p> <p>Defined in: types/index.ts:159</p> <p>Utility type for unproxy that converts Fragment types to fragment references. This recursively processes objects and arrays to convert Fragment to { __id: string }."},{"location":"reference/types/#type-parameters_3","title":"Type Parameters","text":"Type Parameter <code>T</code>"},{"location":"reference/types/#saveresponset","title":"SaveResponse\\&lt;T&gt;","text":"<p>SaveResponse\\&lt;<code>T</code>&gt; = { <code>data</code>: <code>T</code>; <code>componentIdentifier</code>: <code>ComponentIdentifier</code>; <code>assets</code>: <code>string</code>[]; <code>csrfToken?</code>: <code>string</code>; <code>fragments</code>: <code>FragmentPath</code>[]; <code>defers</code>: <code>Defer</code>[]; <code>slices</code>: <code>JSONObject</code>; <code>action</code>: <code>\"savePage\"</code>; <code>renderedAt</code>: <code>number</code>; <code>restoreStrategy</code>: <code>RestoreStrategy</code>; }</p> <p>Defined in: types/index.ts:209</p> <p>The SaveResponse response is responsible for persisting a full page visit in Superglue.</p>"},{"location":"reference/types/#type-parameters_4","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#properties_17","title":"Properties","text":""},{"location":"reference/types/#data","title":"data","text":"<p>data: <code>T</code></p> <p>Defined in: types/index.ts:210</p> <p></p>"},{"location":"reference/types/#componentidentifier_1","title":"componentIdentifier","text":"<p>componentIdentifier: <code>ComponentIdentifier</code></p> <p>Defined in: types/index.ts:211</p> <p></p>"},{"location":"reference/types/#assets","title":"assets","text":"<p>assets: <code>string</code>[]</p> <p>Defined in: types/index.ts:212</p> <p></p>"},{"location":"reference/types/#csrftoken","title":"csrfToken?","text":"<p><code>optional</code> csrfToken: <code>string</code></p> <p>Defined in: types/index.ts:213</p> <p></p>"},{"location":"reference/types/#fragments","title":"fragments","text":"<p>fragments: <code>FragmentPath</code>[]</p> <p>Defined in: types/index.ts:214</p> <p></p>"},{"location":"reference/types/#defers","title":"defers","text":"<p>defers: <code>Defer</code>[]</p> <p>Defined in: types/index.ts:215</p> <p></p>"},{"location":"reference/types/#slices","title":"slices","text":"<p>slices: <code>JSONObject</code></p> <p>Defined in: types/index.ts:216</p> <p></p>"},{"location":"reference/types/#action","title":"action","text":"<p>action: <code>\"savePage\"</code></p> <p>Defined in: types/index.ts:217</p> <p></p>"},{"location":"reference/types/#renderedat","title":"renderedAt","text":"<p>renderedAt: <code>number</code></p> <p>Defined in: types/index.ts:219</p> <p></p>"},{"location":"reference/types/#restorestrategy_1","title":"restoreStrategy","text":"<p>restoreStrategy: <code>RestoreStrategy</code></p> <p>Defined in: types/index.ts:220</p> <p></p>"},{"location":"reference/types/#paget","title":"Page\\&lt;T&gt;","text":"<p>Page\\&lt;<code>T</code>&gt; = <code>SaveResponse</code>\\&lt;<code>T</code>&gt; &amp; { <code>savedAt</code>: <code>number</code>; }</p> <p>Defined in: types/index.ts:226</p> <p>A Page is a SaveResponse that's been saved to the store</p>"},{"location":"reference/types/#type-declaration","title":"Type declaration","text":"Name Type Defined in <code>savedAt</code> <code>number</code> types/index.ts:227"},{"location":"reference/types/#type-parameters_5","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#streammessage","title":"StreamMessage","text":"<p>StreamMessage = { <code>data</code>: <code>JSONMappable</code>; <code>fragmentIds</code>: <code>string</code>[]; <code>handler</code>: <code>\"append\"</code> | <code>\"prepend\"</code> | <code>\"save\"</code>; <code>options</code>: <code>Record</code>\\&lt;<code>string</code>, <code>string</code>&gt;; }</p> <p>Defined in: types/index.ts:253</p>"},{"location":"reference/types/#properties_18","title":"Properties","text":""},{"location":"reference/types/#data_1","title":"data","text":"<p>data: <code>JSONMappable</code></p> <p>Defined in: types/index.ts:254</p> <p></p>"},{"location":"reference/types/#fragmentids","title":"fragmentIds","text":"<p>fragmentIds: <code>string</code>[]</p> <p>Defined in: types/index.ts:255</p> <p></p>"},{"location":"reference/types/#handler","title":"handler","text":"<p>handler: <code>\"append\"</code> | <code>\"prepend\"</code> | <code>\"save\"</code></p> <p>Defined in: types/index.ts:256</p> <p></p>"},{"location":"reference/types/#options","title":"options","text":"<p>options: <code>Record</code>\\&lt;<code>string</code>, <code>string</code>&gt;</p> <p>Defined in: types/index.ts:257</p> <p></p>"},{"location":"reference/types/#streamresponse","title":"StreamResponse","text":"<p>StreamResponse = { <code>data</code>: <code>StreamMessage</code>[]; <code>fragments</code>: <code>FragmentPath</code>[]; <code>assets</code>: <code>string</code>[]; <code>csrfToken?</code>: <code>string</code>; <code>action</code>: <code>\"handleStreamResponse\"</code>; <code>renderedAt</code>: <code>number</code>; <code>slices</code>: <code>JSONObject</code>; }</p> <p>Defined in: types/index.ts:260</p>"},{"location":"reference/types/#properties_19","title":"Properties","text":""},{"location":"reference/types/#data_2","title":"data","text":"<p>data: <code>StreamMessage</code>[]</p> <p>Defined in: types/index.ts:261</p> <p></p>"},{"location":"reference/types/#fragments_1","title":"fragments","text":"<p>fragments: <code>FragmentPath</code>[]</p> <p>Defined in: types/index.ts:262</p> <p></p>"},{"location":"reference/types/#assets_1","title":"assets","text":"<p>assets: <code>string</code>[]</p> <p>Defined in: types/index.ts:263</p> <p></p>"},{"location":"reference/types/#csrftoken_1","title":"csrfToken?","text":"<p><code>optional</code> csrfToken: <code>string</code></p> <p>Defined in: types/index.ts:264</p> <p></p>"},{"location":"reference/types/#action_1","title":"action","text":"<p>action: <code>\"handleStreamResponse\"</code></p> <p>Defined in: types/index.ts:265</p> <p></p>"},{"location":"reference/types/#renderedat_1","title":"renderedAt","text":"<p>renderedAt: <code>number</code></p> <p>Defined in: types/index.ts:266</p> <p></p>"},{"location":"reference/types/#slices_1","title":"slices","text":"<p>slices: <code>JSONObject</code></p> <p>Defined in: types/index.ts:267</p> <p></p>"},{"location":"reference/types/#pageresponse","title":"PageResponse","text":"<p>PageResponse = <code>GraftResponse</code> | <code>SaveResponse</code> | <code>StreamResponse</code></p> <p>Defined in: types/index.ts:275</p> <p>A PageResponse can be either a GraftResponse, SaveResponse. or a StreamResponse Its meant to be implemented by the server and if you are using superglue_rails, the generators will handle all cases.</p> <p></p>"},{"location":"reference/types/#allpagest","title":"AllPages\\&lt;T&gt;","text":"<p>AllPages\\&lt;<code>T</code>&gt; = <code>Record</code>\\&lt;<code>PageKey</code>, <code>Page</code>\\&lt;<code>T</code>&gt;&gt;</p> <p>Defined in: types/index.ts:308</p> <p>The store where all page responses are stored indexed by PageKey. You are encouraged to mutate the Pages in this store.</p>"},{"location":"reference/types/#type-parameters_6","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#allfragments","title":"AllFragments","text":"<p>AllFragments = <code>Record</code>\\&lt;<code>string</code>, <code>JSONMappable</code>&gt;</p> <p>Defined in: types/index.ts:314</p> <p>The store where all page responses are stored indexed by PageKey. You are encouraged to mutate the Pages in this store.</p> <p></p>"},{"location":"reference/types/#visitcreator","title":"VisitCreator()","text":"<p>VisitCreator = (<code>input</code>: <code>string</code> | <code>PageKey</code>, <code>options</code>: <code>VisitProps</code>) =&gt; <code>VisitMetaThunk</code></p> <p>Defined in: types/index.ts:380</p> <p>VisitCreator is a Redux action creator that returns a thunk. Use this to build the Visit function. Typically it's already generated in <code>application_visit.js</code></p>"},{"location":"reference/types/#parameters_2","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> | <code>PageKey</code> <code>options</code> <code>VisitProps</code>"},{"location":"reference/types/#returns_2","title":"Returns","text":"<p><code>VisitMetaThunk</code></p> <p></p>"},{"location":"reference/types/#remotecreator","title":"RemoteCreator()","text":"<p>RemoteCreator = (<code>input</code>: <code>string</code> | <code>PageKey</code>, <code>options</code>: <code>RemoteProps</code>) =&gt; <code>MetaThunk</code></p> <p>Defined in: types/index.ts:389</p> <p>RemoteCreator is a Redux action creator that returns a thunk. Use this to build the Remote function. Typically it's already generated in <code>application_visit.js</code></p>"},{"location":"reference/types/#parameters_3","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> | <code>PageKey</code> <code>options</code> <code>RemoteProps</code>"},{"location":"reference/types/#returns_3","title":"Returns","text":"<p><code>MetaThunk</code></p> <p></p>"},{"location":"reference/types/#dispatch","title":"Dispatch","text":"<p>Dispatch = <code>ThunkDispatch</code>\\&lt;<code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p> <p>Defined in: types/index.ts:394</p> <p></p>"},{"location":"reference/types/#supergluestore","title":"SuperglueStore","text":"<p>SuperglueStore = <code>EnhancedStore</code>\\&lt;<code>RootState</code>, <code>Action</code>, <code>Tuple</code>\\&lt;[<code>StoreEnhancer</code>\\&lt;{ <code>dispatch</code>: <code>Dispatch</code>; }&gt;, <code>StoreEnhancer</code>]&gt;&gt;</p> <p>Defined in: types/index.ts:401</p> <p>A Store created with Redux Toolkit's <code>configureStore</code> setup with reducers from Superglue. If you are using superglue_rails this would have been generated for you in <code>store.js</code> and setup correctly in application.js</p> <p></p>"},{"location":"reference/types/#ujshandlers","title":"UJSHandlers()","text":"<p>UJSHandlers = (<code>{   ujsAttributePrefix,   visit,   remote,   store, }</code>: { <code>ujsAttributePrefix</code>: <code>string</code>; <code>visit</code>: <code>ApplicationVisit</code>; <code>remote</code>: <code>ApplicationRemote</code>; <code>store</code>: <code>SuperglueStore</code>; }) =&gt; <code>Handlers</code></p> <p>Defined in: types/index.ts:419</p>"},{"location":"reference/types/#parameters_4","title":"Parameters","text":"Parameter Type <code>{ ujsAttributePrefix, visit, remote, store, }</code> { <code>ujsAttributePrefix</code>: <code>string</code>; <code>visit</code>: <code>ApplicationVisit</code>; <code>remote</code>: <code>ApplicationRemote</code>; <code>store</code>: <code>SuperglueStore</code>; } <code>{ ujsAttributePrefix, visit, remote, store, }.ujsAttributePrefix</code> <code>string</code> <code>{ ujsAttributePrefix, visit, remote, store, }.visit</code> <code>ApplicationVisit</code> <code>{ ujsAttributePrefix, visit, remote, store, }.remote</code> <code>ApplicationRemote</code> <code>{ ujsAttributePrefix, visit, remote, store, }.store</code> <code>SuperglueStore</code>"},{"location":"reference/types/#returns_4","title":"Returns","text":"<p><code>Handlers</code></p> <p></p>"},{"location":"reference/types/#saveandprocesspagethunk","title":"SaveAndProcessPageThunk","text":"<p>SaveAndProcessPageThunk = <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>void</code>&gt;, <code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p> <p>Defined in: types/index.ts:447</p> <p></p>"},{"location":"reference/types/#metathunk","title":"MetaThunk","text":"<p>MetaThunk = <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>Meta</code>&gt;, <code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p> <p>Defined in: types/index.ts:454</p> <p></p>"},{"location":"reference/types/#visitmetathunk","title":"VisitMetaThunk","text":"<p>VisitMetaThunk = <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>VisitMeta</code>&gt;, <code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p> <p>Defined in: types/index.ts:455</p> <p></p>"},{"location":"reference/types/#defermentthunk","title":"DefermentThunk","text":"<p>DefermentThunk = <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>void</code>[]&gt;, <code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p> <p>Defined in: types/index.ts:462</p> <p></p>"},{"location":"reference/types/#navigateto","title":"NavigateTo()","text":"<p>NavigateTo = (<code>path</code>: <code>Keypath</code>, <code>options</code>: { <code>action</code>: <code>NavigationAction</code>; }) =&gt; <code>boolean</code></p> <p>Defined in: types/index.ts:500</p> <p>Passed to every page component and also available as part of a NavigationContext:</p> <pre><code>import { NavigationContext } from '@thoughtbot/superglue';\n\nconst { navigateTo } = useContext(NavigationContext)\n</code></pre> <p>Manually navigate using pages that exists in the store and restores scroll position. <code>navigateTo</code> is what Visit in your <code>application_visit.js</code> ultimately calls.</p> <p>If there is an existing page in your store <code>navigateTo</code> will restore the props, render the correct component, and return <code>true</code>. Otherwise, it will return <code>false</code>. This is useful if you want to restore an existing page before making a call to <code>visit</code> or <code>remote</code>.</p>"},{"location":"reference/types/#parameters_5","title":"Parameters","text":"Parameter Type Description <code>path</code> <code>Keypath</code> <code>options</code> { <code>action</code>: <code>NavigationAction</code>; } - <code>options.action</code> <code>NavigationAction</code> when <code>none</code>, <code>navigateTo</code> will immediately return <code>false</code>"},{"location":"reference/types/#returns_5","title":"Returns","text":"<p><code>boolean</code></p> <p><code>true</code> if the navigation was a success, <code>false</code> if the page was not found in the store.</p>"},{"location":"reference/types/#references","title":"References","text":""},{"location":"reference/types/#fetchargs","title":"FetchArgs","text":"<p>Re-exports FetchArgs</p> <p></p>"},{"location":"reference/types/#graftingsuccessaction","title":"GraftingSuccessAction","text":"<p>Re-exports GraftingSuccessAction</p> <p></p>"},{"location":"reference/types/#graftingerroraction","title":"GraftingErrorAction","text":"<p>Re-exports GraftingErrorAction</p> <p></p>"},{"location":"reference/types/#visit","title":"Visit","text":"<p>Re-exports Visit</p> <p></p>"},{"location":"reference/types/#visitprops","title":"VisitProps","text":"<p>Re-exports VisitProps</p> <p></p>"},{"location":"reference/types/#remote","title":"Remote","text":"<p>Re-exports Remote</p> <p></p>"},{"location":"reference/types/#remoteprops","title":"RemoteProps","text":"<p>Re-exports RemoteProps</p> <p></p>"},{"location":"reference/types/#beforesave","title":"BeforeSave","text":"<p>Re-exports BeforeSave</p> <p></p>"},{"location":"reference/types/#applicationremote","title":"ApplicationRemote","text":"<p>Re-exports ApplicationRemote</p> <p></p>"},{"location":"reference/types/#applicationvisit","title":"ApplicationVisit","text":"<p>Re-exports ApplicationVisit</p>"},{"location":"reference/types.requests/","title":"Requests","text":""},{"location":"reference/types.requests/#interfaces","title":"Interfaces","text":""},{"location":"reference/types.requests/#visit","title":"Visit()","text":"<p>Defined in: types/requests.ts:11</p> <p>Visit(<code>input</code>: <code>string</code>, <code>options</code>: <code>VisitProps</code>): <code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p>Defined in: types/requests.ts:30</p> <p>Use visit to make single page transitions from one page. The function is a wrapper around fetch and made to mimic a link click or a form submision. When used, a <code>json</code> request will be made for the next page, then Superglue saves the response, swap the page component, and change the browser history.</p> <p>Note</p> <p>There can be only one <code>visit</code> at a time. If another <code>visit</code> is called from elsewhere, the previous visit would be aborted.</p> <p>You must provide the implentation and pass it back to Superglue in <code>application.js</code>. Superglue will then pass it to your page components and use it for UJS navigation. This is usually generated for you in <code>application_visit.js</code> where you can customize its behavior globally.</p>"},{"location":"reference/types.requests/#parameters","title":"Parameters","text":"Parameter Type Description <code>input</code> <code>string</code> The first argument to Fetch <code>options</code> <code>VisitProps</code>"},{"location":"reference/types.requests/#returns","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p></p>"},{"location":"reference/types.requests/#visitprops","title":"VisitProps","text":"<p>Defined in: types/requests.ts:38</p> <p>Options for Visit</p>"},{"location":"reference/types.requests/#extends","title":"Extends","text":"<ul> <li><code>Omit</code>\\&lt;<code>BaseProps</code>, <code>\"signal\"</code>&gt;</li> </ul>"},{"location":"reference/types.requests/#properties","title":"Properties","text":"Property Type Description Inherited from Defined in <code>placeholderKey?</code> <code>string</code> Defaults to the currentPageKey. When present, Superglue will use the page state located at that pageKey and optimistally navigates to it as the next page's state while the requests resolves. - types/requests.ts:44 <code>revisit?</code> <code>boolean</code> When <code>true</code> and the request method is a GET, changes the <code>suggestionAction</code> of the Meta object to <code>none</code> so that Superglue does nothing to window.history. When the GET response was redirected, changes <code>navigationAction</code> to <code>replace</code> - types/requests.ts:51 <code>method?</code> <code>string</code> The HTTP method <code>RemoteProps</code>.<code>method</code> types/requests.ts:76 <code>body?</code> <code>BodyInit</code> The HTTP body <code>RemoteProps</code>.<code>body</code> types/requests.ts:78 <code>headers?</code> {[<code>key</code>: <code>string</code>]: <code>string</code>; } The HTTP headers <code>Omit.headers</code> types/requests.ts:80 <code>beforeSave?</code> <code>BeforeSave</code>\\&lt;<code>JSONMappable</code>&gt; - <code>RemoteProps</code>.<code>beforeSave</code> types/requests.ts:83"},{"location":"reference/types.requests/#remote","title":"Remote()","text":"<p>Defined in: types/requests.ts:54</p> <p>Remote(<code>input</code>: <code>string</code>, <code>options</code>: <code>RemoteProps</code>): <code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p>Defined in: types/requests.ts:68</p> <p>Remote is a wrapper around fetch. It's used to make a request and mutate the store. Remote does not navigate, and it does not change the browser history. There can be multiple Remote requests running concurrently.</p> <p>This function is to be wrapped by a developer as a ApplicationRemote and returned to superglue.  This is usually generated as <code>application_visit.js</code> where you can make minimum edits to affect its global usage.</p>"},{"location":"reference/types.requests/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>input</code> <code>string</code> The first argument to Fetch <code>options</code> <code>RemoteProps</code> The fetch RequestInit with additional options"},{"location":"reference/types.requests/#returns_1","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p></p>"},{"location":"reference/types.requests/#remoteprops","title":"RemoteProps","text":"<p>Defined in: types/requests.ts:89</p> <p>Options for Visit</p>"},{"location":"reference/types.requests/#extends_1","title":"Extends","text":"<ul> <li><code>BaseProps</code></li> </ul>"},{"location":"reference/types.requests/#properties_1","title":"Properties","text":"Property Type Description Inherited from Defined in <code>method?</code> <code>string</code> The HTTP method <code>BaseProps.method</code> types/requests.ts:76 <code>body?</code> <code>BodyInit</code> The HTTP body <code>BaseProps.body</code> types/requests.ts:78 <code>headers?</code> {[<code>key</code>: <code>string</code>]: <code>string</code>; } The HTTP headers <code>BaseProps.headers</code> types/requests.ts:80 <code>beforeSave?</code> <code>BeforeSave</code>\\&lt;<code>JSONMappable</code>&gt; - <code>BaseProps.beforeSave</code> types/requests.ts:83 <code>pageKey?</code> <code>string</code> Specifies where to store the remote payload, if not provided Remote will derive a key from the response's url. - types/requests.ts:94 <code>force?</code> <code>boolean</code> By default, remote Remote disallows grafting a page response using props_at if the target pageKey provided has a different componentIdentifier. Setting <code>force: true</code> will ignore this limitation. This can be useful if you are absolutely sure that the page your grafting onto has a compatible shape with the response received with using props_at. A good example of this is a shared global header. - types/requests.ts:104"},{"location":"reference/types.requests/#beforesavet","title":"BeforeSave()\\&lt;T&gt;","text":"<p>Defined in: types/requests.ts:107</p>"},{"location":"reference/types.requests/#type-parameters","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code> <p>BeforeSave\\&lt;<code>U</code>&gt;(<code>prevPage</code>: <code>Page</code>\\&lt;<code>T</code>&gt;, <code>receivedPage</code>: <code>U</code>): <code>U</code></p> <p>Defined in: types/requests.ts:128</p> <p>A callback that fires in between recieving a payload and saving a payload. Use this callback to modify the payload before it gets saved. Its useful for appending, prepending, shuffeling, etc. recieved data to existing data.</p> <pre><code>const beforeSave = (prevPage, nextPage) =&gt; {\n  nextPage.data.messages = [\n    prevPage.data.messages,\n    ... nextPage.data.messages\n  ]\n\n  return nextPage\n}\n\nremote(\"/posts\", {beforeSave})\n</code></pre>"},{"location":"reference/types.requests/#type-parameters_1","title":"Type Parameters","text":"Type Parameter <code>U</code> extends <code>SaveResponse</code>\\&lt;<code>T</code>&gt; | <code>GraftResponse</code>\\&lt;<code>T</code>&gt;"},{"location":"reference/types.requests/#parameters_2","title":"Parameters","text":"Parameter Type <code>prevPage</code> <code>Page</code>\\&lt;<code>T</code>&gt; <code>receivedPage</code> <code>U</code>"},{"location":"reference/types.requests/#returns_2","title":"Returns","text":"<p><code>U</code></p> <p></p>"},{"location":"reference/types.requests/#applicationremote","title":"ApplicationRemote()","text":"<p>Defined in: types/requests.ts:134</p> <p>ApplicationRemote(<code>input</code>: <code>string</code>, <code>options?</code>: <code>RemoteProps</code> &amp; { <code>dataset?</code>: {[<code>name</code>: <code>string</code>]: <code>undefined</code> | <code>string</code>; }; }): <code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p>Defined in: types/requests.ts:146</p> <p>ApplicationRemote is the developer provided wrapper around Remote.</p> <p>It contains custom functionality, but is bound by the interface that Superglue uses to make a <code>remote</code> call. See Remote for more details.</p> <p>The only difference between the two interfaces is ApplicationRemote will also be passed a dataset as an option. This is because Superglue UJS uses ApplicationRemote and will pass the dataset of the HTML element where UJS is enabled on.</p>"},{"location":"reference/types.requests/#parameters_3","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> <code>options?</code> <code>RemoteProps</code> &amp; { <code>dataset?</code>: {[<code>name</code>: <code>string</code>]: <code>undefined</code> | <code>string</code>; }; }"},{"location":"reference/types.requests/#returns_3","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p></p>"},{"location":"reference/types.requests/#applicationvisit","title":"ApplicationVisit()","text":"<p>Defined in: types/requests.ts:156</p> <p>ApplicationVisit(<code>input</code>: <code>string</code>, <code>options?</code>: <code>VisitProps</code> &amp; { <code>dataset?</code>: {[<code>name</code>: <code>string</code>]: <code>undefined</code> | <code>string</code>; }; }): <code>Promise</code>\\&lt;<code>undefined</code> | <code>void</code> | <code>VisitMeta</code>&gt;</p> <p>Defined in: types/requests.ts:168</p> <p>ApplicationVisit is the developer provided wrapper around Remote.</p> <p>It contains custom functionality, but is bound by the interface that Superglue uses to make a <code>visit</code> call. See Remote for more details.</p> <p>The only difference between the two interfaces is ApplicationVisit will also be passed a dataset as an option. This is because Superglue UJS uses ApplicationVisit and will pass the dataset of the HTML element where UJS is enabled on.</p>"},{"location":"reference/types.requests/#parameters_4","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> <code>options?</code> <code>VisitProps</code> &amp; { <code>dataset?</code>: {[<code>name</code>: <code>string</code>]: <code>undefined</code> | <code>string</code>; }; }"},{"location":"reference/types.requests/#returns_4","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>undefined</code> | <code>void</code> | <code>VisitMeta</code>&gt;</p>"}]}