import {
  ChannelNameWithParams,
  Consumer,
  Subscription,
} from '@rails/actioncable'
import { useState, useEffect, useRef, createContext, useContext } from 'react'
import { ApplicationRemote, FragmentPath } from '../types'
import { useSuperglue } from '.'
import { debounce, DebouncedFunc } from 'lodash'
import { lastRequestIds } from '../utils'
import {
  streamPrepend,
  streamAppend,
  streamSave,
  handleStreamMessage,
} from '../action_creators/stream'

/**
 * Channel configuration for stream sources
 * @public
 */
export type StreamSourceProps = string | ChannelNameWithParams

export type StreamMessage =
  | {
      action: 'handleStreamMessage'
      data: JSONMappable
      fragmentIds: string[]
      handler: 'append' | 'prepend' | 'save'
      options: Record<string, string>
      fragments: FragmentPath[]
    }
  | {
      action: 'handleStreamMessage'
      handler: 'refresh'
      requestId: string
      options: Record<string, string>
    }

import { SuperglueStore, JSONMappable } from '../types'

/**
 * Actions for handling stream operations like append, prepend, save and refresh
 * @public
 */
export class StreamActions {
  public attributePrefix: string
  public remote: DebouncedFunc<ApplicationRemote>
  private store: SuperglueStore

  constructor({
    remote,
    store,
  }: {
    remote: ApplicationRemote
    store: SuperglueStore
  }) {
    this.store = store
    this.remote = debounce(remote, 300)
  }

  refresh(pageKey: string) {
    this.remote(pageKey)
  }

  prepend(
    fragments: string[],
    data: JSONMappable,
    options: { saveAs?: string } = {}
  ) {
    this.store.dispatch(streamPrepend(fragments, data, options))
  }

  save(fragment: string, data: JSONMappable) {
    this.store.dispatch(streamSave(fragment, data))
  }

  append(
    fragments: string[],
    data: JSONMappable,
    options: { saveAs?: string } = {}
  ) {
    this.store.dispatch(streamAppend(fragments, data, options))
  }

  handle(rawMessage: string, currentPageKey: string) {
    const message = JSON.parse(rawMessage) as StreamMessage
    const { superglue } = this.store.getState()
    const nextPageKey = superglue.currentPageKey

    if (message.action === 'handleStreamMessage') {
      if (
        message.handler === 'refresh' &&
        currentPageKey === nextPageKey &&
        !lastRequestIds.has(message.requestId)
      ) {
        this.refresh(currentPageKey)
      }

      if (message.handler !== 'refresh') {
        this.store.dispatch(handleStreamMessage(rawMessage))
      }
    }
  }
}

export const CableContext = createContext<{
  cable: Consumer | null
  streamActions: StreamActions | null
}>({
  cable: null,
  streamActions: null,
})

/**
 * Creates a subscription to an ActionCable channel for real-time streaming
 * updates.
 *
 * This hook manages the lifecycle of an ActionCable subscription, automatically
 * connecting when the cable is available and cleaning up on unmount. Stream
 * messages are processed through StreamActions to update the Redux store.
 *
 * Typically used with channel configuration generated by the Rails helper
 * `stream_from_props` helper in your `props` templates.
 *
 *  * @example
 * Using the helper:
 *
 * ```ruby
 * # app/views/chat_rooms/show.json.props
 * json.chatChannel stream_from_props("messages")
 * ```
 * ```tsx
 * const content = useContent()
 * const { connected } = useStreamSource(content.chatChannel)
 * ```
 *
 * @example
 * Basic channel subscription:
 * ```tsx
 * const { connected } = useStreamSource('ChatChannel')
 * ```
 *
 * @example
 * Channel with parameters:
 * ```tsx
 * const { connected } = useStreamSource({
 *   channel: 'ChatChannel',
 *   room_id: roomId
 * })
 * ```
 *
 * @example
 * Using connection status:
 * ```tsx
 * const { connected, subscription } = useStreamSource('NotificationsChannel')
 *
 * return (
 *   <div>
 *     {connected ? 'Connected' : 'Connecting...'}
 *     {subscription && <span>Subscription active</span>}
 *   </div>
 * )
 * ```
 *
 * @param channel - Channel configuration as string or ChannelNameWithParams object,
 *                  typically generated by Rails `stream_from_props` helper
 * @returns Object containing connection status and subscription instance
 *
 * @public
 */
export function useStreamSource(channel: StreamSourceProps): {
  /** Whether the ActionCable subscription is currently connected */
  connected: boolean
  /** The active ActionCable subscription instance, null if not connected */
  subscription: Subscription | null
} {
  const { cable, streamActions } = useContext(CableContext)
  const [connected, setConnected] = useState(false)
  const { currentPageKey } = useSuperglue()
  const subscriptionRef = useRef<Subscription | null>(null)

  useEffect(() => {
    if (cable) {
      const subscription = cable.subscriptions.create(channel, {
        received: (message) => {
          streamActions?.handle(message, currentPageKey)
        },
        connected: () => {
          setConnected(true)
        },
        disconnected: () => setConnected(false),
      })

      subscriptionRef.current = subscription

      return () => subscription.unsubscribe()
    } else {
      subscriptionRef.current = null
      setConnected(false)

      return () => {}
    }
  }, [cable, channel, currentPageKey])

  return {
    connected,
    subscription: subscriptionRef.current,
  }
}
