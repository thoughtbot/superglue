{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Superglue and friends thoughtfully pairs Rails and React. Its built with a laser focus on The Rails Way and aims to provide a simple developer experience on par with Hotwire, Stimulus, and Turbo. Confidently use Rails routes, controllers, views as you normally would in a multi-page application and integrate with React's vast ecosystem.</p>"},{"location":"#who-is-it-for","title":"Who is it for?","text":"<p>Superglue is built from the ground up for</p> <ul> <li> <p>The Rails developer: For those of us who want to harness the full power   of ALL of Rails --controllers, server-side routing, views, form helpers,   and more \u2014 to create seamless, interactive React applications without the   hassle of APIs and client side routing.</p> </li> <li> <p>Teams fighting complexity: Its not easy pivoting from complexity.   Superglue empowers teams to take small steps back without giving up the   effort invested in React components.</p> </li> <li> <p>Startups moving fast: Founders looking to hit the ground running by   combining the speed of Rails development with React's vast ecosystem of   prebuilt UI libraries.</p> </li> <li> <p>Javascript fatigue: Anyone tired of JS complexity and just want to get   work done.</p> </li> </ul>"},{"location":"#how-does-it-work","title":"How does it work?","text":""},{"location":"#its-rails","title":"It\u2019s Rails","text":"<p>Superglue leans on Rails' ability to respond to different mime types on the same route and divides the usual <code>foobar.html.erb</code> into three familiar templates.</p> <ul> <li><code>foobar.json.props</code> A presenter written in a jbuilder-like template that   builds your page props.</li> <li><code>foobar.(jsx|tsx)</code> Your page component that receives the props from above.</li> <li><code>foobar.html.erb</code> Injects your page props into Redux when the browser loads   it.</li> </ul> <p>Shape your <code>props</code> to roughly match your component structure. For example:</p> <pre><code>json.header do\n  json.username @user.username\n  json.linkToProfile url_for(@user)\nend\n\njson.rightDrawer do\n  json.cart(partial: 'cart') do\n  end\n  json.dailySpecials(partial: 'specials') do\n  end\nend\n\njson.body do\n  json.productFilter do\n    form_props(url: \"/\", method: \"GET\") do |f|\n      f.select(:category, [\"lifestyle\", \"programming\", \"spiritual\"])\n      f.submit\n    end\n  end\n\n  json.products do\n    json.array! @products do |product|\n      json.title product.title\n      json.urlToProduct url_for(product)\n    end\n  end\nend\n\njson.footer do\n  json.copyrightYear \"2023\"\nend\n</code></pre> <p>Familiar Rails conveniences include form_props (a fork of <code>form_with</code> made for React), flash messages integrated as a Redux slice, and Unobtrusive Javascript helpers.</p>"},{"location":"#its-react","title":"It\u2019s React","text":"<p>But there are no APIs! The above is injected as a script tag in the DOM so everything loads in the initial request. Its added to your Redux state and passed to the page component in a hook, for example:</p> <pre><code>import React from 'react';\nimport { useSelector } from 'react-redux';\nimport { Drawer, Header, Footer, ProductList, ProductFilter } from './components';\nimport { useContent } from '@thoughtbot/superglue'\n\nexport default function FooBar() {\n  const {\n    header,\n    products = [],\n    productFilter,\n    rightDrawer,\n    footer\n  } = useContent()\n\n  const flash = useSelector((state) =&gt; state.flash);\n\n  return (\n    &lt;&gt;\n      &lt;p id=\"notice\"&gt;{flash &amp;&amp; flash.notice}&lt;/p&gt;\n      &lt;Header {...header}&gt;\n        &lt;Drawer {...rightDrawer} /&gt;\n      &lt;/Header&gt;\n\n      &lt;ProductList {...products}&gt;\n        &lt;ProductFilter {...productFilter} /&gt;\n      &lt;/ProductList&gt;\n\n      &lt;Footer {...footer} /&gt;\n    &lt;/&gt;\n  );\n}\n</code></pre>"},{"location":"#its-turbolinks","title":"It\u2019s Turbolinks","text":"<p>Superglue drew inspiration fromthe original Turbolinks, but instead of sending your <code>foobar.html.erb</code> over the wire and swapping the <code>&lt;body&gt;</code>, it sends <code>foobar.json.props</code> over the wire to your React and Redux app and swaps the page component.</p> <p>This behavior is opt-in. Superglue provides UJS helpers that you can use with your React components to SPA transition to the next page.</p> <pre><code>&lt;a href=\u201d/next_page\u201d data-sg-visit&gt; Next Page &lt;/a&gt;\n</code></pre>"},{"location":"#the-return-of-ujs","title":"The return of UJS","text":"<p>Superglue\u2019s secret sauce is that your <code>foobar.json.props</code> is diggable; making any part of your page dynamic by using a query string. It\u2019s a simpler approach to Turbo Frames and Turbo Stream.</p> <p>Need to reload a part of the page? Just add a query parameter and combine with the UJS helper attribute <code>data-sg-remote</code>:</p> <pre><code>&lt;Header {...header}&gt;\n  &lt;Drawer {...rightDrawer} /&gt;\n\n  &lt;a data-sg-remote href=\"/some_current_page?props_at=data.rightDrawer.dailySpecials\"&gt;\n    Reload Daily Specials\n  &lt;/a&gt;\n&lt;/Header&gt;\n</code></pre> <p>The above will traverse <code>foobar.json.props</code>, grab <code>dailySpecials</code> while skipping other nodes, and immutably graft it to your Redux store.</p> <p>This works well for modals, chat, streaming, and more!</p>"},{"location":"#one-stop-shop","title":"One-stop shop","text":"<p>We know first hand how complex React can be, but we don't shy away from complexity. We want to make things better for everyone and to that end, we have a supporting cast of tooling under one shop to bring ease and consistancy to your team.</p> <ul> <li> <p>Superglue JS</p> <p>The javascript library thoughfully pairing Rails and React.</p> <p> SuperglueJs</p> </li> <li> <p>Superglue Rails</p> <p>Integration helpers, and generators for installation and scaffolding.</p> <p> superglue_rails</p> </li> <li> <p>PropsTemplate</p> <p>A very fast JSON builder. The secret sauce that give UJS superpowers.</p> <p> props_template</p> </li> <li> <p>Humid</p> <p>Server Side Rendering using MiniRacer and V8 isolates.</p> <p> Humid</p> </li> <li> <p>FormProps</p> <p>A <code>form_with</code> FormBuilder that lets you use Rails forms with React.</p> <p> form_props</p> </li> <li> <p>CandyWrapper</p> <p>Lightweight wrapper components around popular React UI libraries made to work with FormProps.</p> <p> candy_wrapper</p> </li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>You've installed Superglue and now you're ready to configure your app.</p>"},{"location":"configuration/#application_visitjs","title":"<code>application_visit.js</code>","text":"<p>Tip</p> <p>If you want a progress bar, this is the first thing you'll want to configure after installation.</p> <p>This file contains the factory that builds the remote and visit function that will be passed to your page components and used by the data-sg-visit and data-sg-remote UJS attributes.</p> <p>This file is meant for you to customize. For example, you'll likely want to add a progress bar, control how visits work, or flash when the internet is down.</p>"},{"location":"configuration/#page_to_page_mappingjs","title":"<code>page_to_page_mapping.js</code>","text":"<p>Info</p> <p>Stop by the tutorial to learn how to work with this file.</p> <p>Vite Users This step can be entirely optional if you're using Vite. See the recipe for more information.</p> <p>This file exports a mapping between a <code>componentIdentifier</code> to an imported page component. This gets used in your <code>application.js</code> so that superglue knows which component to render with which identifier.</p> <p>For example:</p> <pre><code>const pageIdentifierToPageComponent = {\n  'posts/edit': PostsEdit,\n  'posts/new': PostsNew,\n  'posts/show': PostsShow,\n  'posts/index': PostsIndex,\n}\n</code></pre>"},{"location":"configuration/#applicationjs","title":"<code>application.js</code>","text":"<p>This is the entry point of your application and uses Superglue's [Application] component. There's nothing to do here, but if you need finer control of how redux is setup, you can build your own Application using the source as inspiration.</p> <ul> <li> See complete reference      for <code>Application</code></li> </ul>"},{"location":"configuration/#flashjs","title":"<code>flash.js</code>","text":"<p>The installation generator will add a <code>flash.js</code> slice to <code>app/javascript/slices</code> and will work with the Rails <code>flash</code>. You can modify this however you like, out of the box:</p> <ul> <li>When using <code>data-sg-visit</code>, all data in the flash slice will be cleared before the request.</li> <li>When using <code>data-sg-visit</code> or <code>data-sg-remote</code>, the recieved flash     will be merged with the current flash. You can change this behavior     by modifying the flash slice.</li> </ul> <p>Hint</p> <p>If you're curious how this works, in your layout, <code>application.json.props</code>, the flash is serialized using <code>flash.to_h</code></p> <p>To use in your page components, simply use a selector.</p> <pre><code>import { useSelector } from 'react-redux'\n\n...\n\nconst flash = useSelector((state) =&gt; state.flash)\n</code></pre> <p>then use the flash as you would normally in a controller</p> <pre><code>def create\n  flash[:success] = \"Post was saved!\"\nend\n</code></pre>"},{"location":"cross-cutting-concerns/","title":"Cross cutting concerns","text":""},{"location":"cross-cutting-concerns/#layouts","title":"Layouts","text":"<p>If you have state that is shared between pages, simply put it in your layout. For example. In the generated <code>application.json.props</code></p> <pre><code>path = request.format.json? ? param_to_dig_path(params[:props_at]) : nil\n\njson.data(dig: path) do\n  json.temperature \"HOT HOT HOT\"\n  yield json\nend\n</code></pre> <p>In the above, every page that gets rendered will have <code>temperature</code> as part of the page response. </p>"},{"location":"cross-cutting-concerns/#partials","title":"Partials","text":"<p>We can also use partials to extract crosscutting concerns. For example, a shared header:</p> <pre><code>app/\n|-- controllers/\n|-- views/\n|   |-- shared/\n|   |   |-- _header.json.props\n|   |-- posts/\n|   |   |-- index.js\n|   |   |-- index.json.props\n|   |-- comments/\n|   |   |-- index.js\n|   |   |-- index.json.props\n</code></pre> <p>By design this results in duplicate JSON nodes across our <code>pages</code> slice:</p> <pre><code>{\n  pages: {\n    \"/posts\": {\n      data: {\n        header: {\n          email: \"foo@foo.com\"\n        }\n      }\n    },\n    \"/comments\": {\n      data: {\n        header: {\n          email: \"foo@foo.com\"\n        }\n      }\n    },\n  }\n}\n</code></pre>"},{"location":"cross-cutting-concerns/#advanced-functionality","title":"Advanced functionality","text":"<p>For most cases where you don't have to mutate your store, using layouts or partials would be good enough. Its a fine tradeoff for simplicity.</p> <p>Sometimes we have global concerns that we'd like to keep updated. This can be for across pages when navigating or if we'd like to perform client-side updates. For example, if we're showing a shopping cart quantity on the header, we want to keep that updated as we navigate back, and when updating line items locally.</p> <p>For this, Superglue has fragments and Redux slices.</p> <p>Hint</p> <p>You may not need to use fragments and Redux slices. For some apps, the only slices you'll ever need is the generated <code>flash.js</code> slice that comes with the install step.</p>"},{"location":"cross-cutting-concerns/#fragments","title":"Fragments","text":"<p>A fragment in Superglue is any props_template block with given name:</p> <pre><code>  json.body do\n    json.cart(fragment: \"shoppingCart\"]) do\n    end\n  end\n</code></pre> <p>Now whenever we encounter a fragment from a new <code>visit</code> or update a fragment using <code>remote</code>, Superglue will dispatch an <code>updateFragment</code> action.</p> <ul> <li> See reference      for <code>updateFragments</code></li> </ul> <p>That's not a very useful thing by itself, but when combined with Redux toolkit createSlice and useSelector, it offers a way to easily build global concerns.</p>"},{"location":"cross-cutting-concerns/#slices","title":"Slices","text":"<p>Whenever a fragment is received or updated, a <code>UPDATE_FRAGMENTS</code> action is dispatched with the value. You can return that value as your state to keep your slice updated as the user navigates.</p> <p>For example:</p> <pre><code>import { createSlice } from '@reduxjs/toolkit'\nimport { updateFragment } from '@thoughtbot/superglue'\n\nexport const cartSlice = createSlice({\n  name: 'cart',\n  extraReducers: (builder) =&gt; {\n    builder.addCase(updateFragments, (state, action) =&gt; {\n      const { value, name } = action.payload;\n\n      if (name === \"cart\") {\n        return value\n      } else {\n        return state;\n      }\n    })\n  }\n})\n</code></pre> <p>Then somewhere in a component you can useSelector:</p> <pre><code>  import { useSelector } from 'react-redux'\n\n  ...\n\n  const cart = useSelector((state) =&gt; state.cart)\n</code></pre> <p>And as this is just a normal Redux slice, you can also add custom reducers to the mix for client-side updates.</p>"},{"location":"cross-cutting-concerns/#initialstate","title":"initialState","text":"<p>You can render your slice's initial state in the slices <code>key</code> of the page object, it'll be merged with the <code>initialState</code> passed to your <code>buildStore</code> function in your application.js</p>"},{"location":"cross-cutting-concerns/#other-actions","title":"Other actions","text":"<p>Aside from <code>UPDATE_FRAGMENTS</code>, superglue comes with other actions that get dispatched during lifecycle events that you can make use of. The <code>flashSlice</code> that was generated with the installation is a good example of this.</p> <p>To higlight a few:</p> <p><code>BEFORE_FETCH</code> - Action created before a before a fetch is called.</p> <pre><code>{\n  type: \"@@superglue/BEFORE_FETCH\",\n  payload: [..array args that are passed to fetch]\n}\n</code></pre> <p><code>BEFORE_VISIT</code> - Same as above, but called only for a <code>visit</code> action.</p> <pre><code>{\n  type: \"@@superglue/BEFORE_VISIT\",\n  payload: [..array args that are passed to fetch]\n}\n</code></pre> <p><code>BEFORE_REMOTE</code> - Same as above, but called only a <code>remote</code> action.</p> <pre><code>{\n  type: \"@@superglue/BEFORE_REMOTE\",\n  payload: [..array args that are passed to fetch]\n}\n</code></pre> <p><code>SAVE_RESPONSE</code> - Whenever a page response is received.</p> <pre><code>{\n  type: \"@@superglue/SAVE_RESPONSE\",\n  payload: {\n    pageKey: \"/posts\",\n    page: {...the page response},\n  },\n}\n</code></pre>"},{"location":"deferments/","title":"Deferments","text":"<p>Sometimes you may want to load parts of your page later, like a slow sidebar, a graph that takes extra time to load, or tab content that shouldn't appear immediately. These scenarios are perfect use cases for Deferments.</p> <p>Deferments are a low effort way to load content later, both automatically and manually. Better yet, most of the work takes place in Rails land in your views.</p>"},{"location":"deferments/#defer-auto","title":"<code>defer: :auto</code>","text":"<p>This option make it easy to defer content in a single setting.</p> views/posts/index.json.propsviews/layouts/application.json.props <pre><code>  json.metrics(defer: [:auto, placeholder: {totalVisitors: 0}]) do\n    sleep 10 # expensive operation\n    json.totalVisitors 30\n  end\n</code></pre> <pre><code>  json.data do\n    yield\n  end\n</code></pre> <p>And that's it! </p>"},{"location":"deferments/#behind-the-scenes","title":"Behind the scenes","text":"<p>When a user lands on a page Superglue will receive</p> <pre><code>{\n  data: {\n    metrics: {\n      totalVisitors: 0\n    }\n  },\n  defers:[\n    {url: '/dashboard?props_at=data.metrics', type: \"auto\"}\n  ],\n  ...other\n}\n</code></pre> <p>Your page components will receive <code>{metrics: {totalVisitors: 0}}</code> and render. Superglue will then make a remote request:</p> <pre><code>remote(\"/dashboard?props_at=data.metrics\")\n</code></pre> <p>10 seconds later the response succeeds with <code>{total_visitors: 30}</code>. Superglue then immutably grafts that payload into the <code>/dashboard</code> page at the path <code>data.metrics</code>. The page state would look like the following:</p> <pre><code>{\n  data: {\n    metrics: {\n      totalVisitors: 30\n    }\n  },\n  defers:[...others],\n  ...other\n}\n</code></pre> <p>Your page component finally recieves the new props and rerenders. For more control, you may provide a <code>success_action</code> or <code>fail_action</code>, and Superglue will dispatch these actions when the promise resolves successfully or fails.</p> <pre><code>json.metrics(defer: [:auto, placeholder: {totalVisitors: 0}, success_action: \"SUCCESS\", fail_action: \"FAIL\"]) do\n  sleep 10 # expensive operation\n  json.totalVisitors 30\nend\n</code></pre>"},{"location":"deferments/#defer-manual","title":"<code>defer: :manual</code>","text":"<p>When you want control over when deferred content loads, e.g., tabbed content, use <code>defer: :manual</code> to stop the content from loading</p> <pre><code>json.metrics(defer: [:manual, placeholder: {totalVisitors: 0}]) do\n  sleep 10 # expensive operation\n  json.totalVisitors 30\nend\n</code></pre> <p>and manually use <code>remote</code></p> <pre><code>remote(\"/dashboard?props_at=data.metrics\")\n</code></pre>"},{"location":"demo/","title":"Demo Application","text":"<p>We have a non-trivial demo application built using Superglue and the original Rails and StimulusJS version built by Sean Doyle The intent is to help you compare and contrast both approaches and showcase how enjoyable and Rails-like Superglue/React/Redux can be.</p> <p></p> <p>We recommend going over the meticulously verbose commit history on Sean's version and comparing that with the Superglue version.</p>"},{"location":"digging/","title":"Digging","text":"<p>Beyond full page navigation, Superglue can make selective updates to parts of the page without a full load through digging. You may recognize digging from earlier docs:</p> <pre><code>/some_current_page?props_at=data.rightDrawer.dailySpecials\n</code></pre> <p>By simply adding a <code>props_at</code> parameter to your requests, you can selectively fetch parts of the page without incurring the cost of loading unneeded content. This is great for functionality like modals, tabs, etc.</p>"},{"location":"digging/#the-props_at-param","title":"The <code>props_at</code> param","text":"<p>The <code>props_at</code> param is a keypath to the content in your PropsTemplate. As a simplified example, imagine this page with no layouts:</p> <pre><code>path = param_to_dig_path(params[:props_at])\njson.data(dig: path) do\n  json.header do\n    json.search do\n      # Results is a leaf node\n      json.results Post.search(params[:some_search_str])\n    end\n  end\n\n  json.content do\n    json.barChart do\n       ...bar chart data\n    end\n\n    ...\n  end\n\n  ...\nend\n</code></pre> <p>To fetch the <code>json.search</code> node, we would need to walk to <code>data</code> then <code>header</code> then <code>search</code>. Translating that to a url with a <code>props_at</code> param:</p> <pre><code>/dashboard?props_at=data.header.search&amp;some_search_str=haircuts\n</code></pre> <p>Digging is normally combined with using data-sg-remote or remote to update content in async fashion.</p> <p>Info</p> <p><code>props_at</code> can be used with <code>data-sg-visit</code></p>"},{"location":"digging/#collections","title":"Collections","text":"<p>There are two ways to query collections. Looking at the following example:</p> <pre><code>path = param_to_dig_path(params[:props_at])\njson.data(dig: path) do\n  json.posts do\n    json.array! @posts do |post|\n      json.details do\n        json.title post.title\n      end\n    end\n  end\nend\n</code></pre>"},{"location":"digging/#index-based-selection","title":"Index-based selection","text":"<p>You may use an index-based key to fetch an item in a list like so:</p> <pre><code>remote('/dashboard?props_at=data.posts.0.details')\n</code></pre> <p>To enable this functionality, you are required to implement <code>member_at(index)</code> on the passed collection.</p> <p>?&gt; PropsTemplate includes a <code>Array</code> extension which delegates to <code>at</code>. If you've used the Superglue generators, it will be included in an initializer.</p> <p>While traversing by index works fine, it can lead the wrong post being updated if your Redux state has changed by the time the request comes back.</p>"},{"location":"digging/#attribute-based-selection","title":"Attribute-based selection","text":"<p>Attribute-based keys for collections look like this:</p> <pre><code>remote('/dashboard?props_at=data.posts.some_id=1.details')\n</code></pre> <p>Notice that we're now referencing the collection member by <code>some_id=1</code> instead of index. This will fetch the node from the backend and graft it correctly in Redux.</p> <p>To enable this, you are required to implement <code>member_by(attribute, value)</code> on the passed collection AND use the option <code>:key</code> in <code>json.array!</code>. For example:</p> <pre><code>path = param_to_dig_path(params[:props_at])\njson.data(dig: params[:props_at]) do\n  json.posts do\n    json.array! @posts, key: :some_id do |post|\n      json.details do\n        json.title post.title\n      end\n\n      # The following will be auto appended by the key: option\n      # json.some_id post.some_id\n    end\n  end\nend\n</code></pre>"},{"location":"digging/#partials","title":"Partials","text":"<p>You can even query into partials.</p> <pre><code>remote('/dashboard?props_at=data.posts.some_id=1.details')\n</code></pre> <pre><code>json.data(dig: params[:props_at]) do\n  json.posts(partial: 'list_of_posts')do\n  end\nend\n</code></pre> <pre><code># list_of_posts.json.props\njson.array! @posts , key: :some_id do |post|\n  json.details do\n    json.title post.title\n  end\n\n  # The following will be auto appended by the key: option\n  # json.some_id post.some_id\nend\n</code></pre> <p>Info</p> <p>When querying, Superglue will disable caching and deferment until the target node is reached.</p> <p>With digging, many modern SPA functionality can be achieved by just a keypath and a few lines of code.</p>"},{"location":"installation/","title":"Installation","text":"<p>Prerequisites</p> <p>To get started with Superglue, you'll need</p> <ul> <li>A javascript bundler. We'll assume esbuild with js-bundling, but you can also use vite.</li> <li><code>yarn</code></li> </ul> <p>Add the following to your Gemfile</p> <pre><code># Gemfile\ngem 'superglue'\n</code></pre> <p>Run bundle and the installation generator:</p> <pre><code>bundle\nrails g superglue:install\n</code></pre> <p>If you prefer typescript</p> <pre><code>rails g superglue:install --typescript\n</code></pre> <p>The above will generate the following files:</p> <pre><code>.\n\u2514\u2500 app/\n   \u2514\u2500 javascript/\n      \u251c\u2500 slices/\n      \u2502  \u251c\u2500 flash.js\n      |  \u2514\u2500 pages.js\n      \u251c\u2500 actions.js\n      \u251c\u2500 application.js\n      \u251c\u2500 application_visit.js\n      \u251c\u2500 page_to_page_mapping.js\n      \u2514\u2500 store.js\n</code></pre>"},{"location":"installation/#redux-toolkit","title":"Redux Toolkit","text":"<p>If you've ever encountered Redux then the files above may seem familiar to you. Superglue works as a complete and fully functional Redux Toolkit application. For the most part, all the functionality you would need resides in these files and you'll make minimum edits, but they are made available if you ever need greater control over state management.</p>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>We recommend getting familiar with the following files:</p> <ul> <li><code>application_visit.js</code> - Add custom functionality to Superglue navigation, e.g, progress bars.</li> <li><code>page_to_page_mapping.js</code> - Pairs your <code>props</code> files with your page components.</li> <li><code>flash.js</code> - Seamlessly, integrates with the Rails flash.</li> </ul> <p>For more information, visit the configuration section.</p>"},{"location":"installation/#scaffold","title":"Scaffold","text":"<p>If you'd like to dive right in, you can start with a scaffold:</p> <pre><code>rails g superglue:scaffold post body:string\n</code></pre> <p>If you prefer typescript</p> <pre><code>rails g superglue:scaffold post body:string --typescript\n</code></pre> <p>or proceed with a tutorial</p>"},{"location":"navigation-context/","title":"NavigationContext","text":"<p>In addition to <code>visit</code> and <code>remote</code>, the <code>NavigationContext</code> provides a few other methods and properties that are best decribed in the context of <code>navigateTo</code>.</p> <pre><code>import { NavigationContext } from '@thoughtbot/superglue'\n\nconst {\n  navigateTo,\n  visit,\n  remote,\n  pageKey,\n  search\n} = useContext(NavigationContext)\n</code></pre> <ul> <li> See complete reference      for <code>NavigationContext</code></li> </ul>"},{"location":"navigation-context/#navigateto","title":"<code>navigateTo</code>","text":"<p>Fundamentally, <code>visit</code> is responsible for <code>fetch</code>ing a page, saving it, and lastly use <code>navigateTo</code> to load the page, update the url, and swap the page component. The NavigationContext exposes <code>navigateTo</code> for you to use use independently. For example:</p> <pre><code>navigateTo('/posts')\n</code></pre> <p>Note</p> <p>The page must exist in the store, or <code>navigateTo</code> will throw a error. Use copyPage to prepopulate before navigating.</p> <p><code>navigateTo</code> is especially useful for optimistic navigation like local facted search and works best when combined with <code>search</code> and <code>pageKey</code> from the same NavigationContext, and the copyPage action.</p> <p>In this example, we'll assume we're on pageKey \"/posts\":</p> <pre><code>import { copyPage, NavigationContext } from '@thoughtbot/superglue'\nimport { myAppDispatch } from '@myJavascript/store'\n\n// In your component somewhere\nconst {\n  navigateTo,\n  pageKey,\n  search\n} = useContext(NavigationContext)\n\nconst nextPageKey = pageKey + \"?active=true\"\ndispatch(copyPage({from: pageKey, to: nextPageKey}))\n\n// On a click handler\nnavigateTo(nextPageKey, { action: 'push'})\n\n// later after navigation.\nconsole.log(search) // would return {active: \"true\"}\n</code></pre> <p>With the above, we're able to make use of the URL search param as a source of state. And by using <code>navigateTo</code>, we're able to filter local results while updating the URL.</p> <ul> <li> See complete reference      for <code>navigateTo</code></li> </ul>"},{"location":"page-response/","title":"The <code>page</code> response","text":"<p>Superglue expects your JSON responses to contain the following attributes. If you used Superglue's generators, this would be all set for you in <code>application.json.props</code>.</p> <pre><code>{\n  data: {\n    ...\n  },\n  componentIdentifier,\n  defers,\n  assets,\n  csrfToken,\n  action,\n  path,\n  renderedAt,\n  fragments,\n  restoreStrategy,\n  slices\n}\n</code></pre>"},{"location":"page-response/#data","title":"<code>data</code>","text":"<p>Your page's content. This can be accessed using the </p>"},{"location":"page-response/#componentidentifier","title":"<code>componentIdentifier</code>","text":"<p>A <code>string</code> to instruct Superglue which component to render. The generated <code>application.json.props</code> will set this to the <code>active_template_virtual_path</code> (added by props_template), but you can customize this to fit your needs.</p> <pre><code># application.json.props\njson.componentIdentifier active_template_virtual_path\n</code></pre> <p>You can control which <code>componentIdentifier</code> will render which component in the <code>page_to_page_mapping.js</code>.</p> <ul> <li> See reference   for page_to_page_mapping.js</li> </ul>"},{"location":"page-response/#assets","title":"<code>assets</code>","text":"<p>An <code>array</code> of asset fingerprint <code>string</code>s. Used by Superglue to detect the need to refresh the browser due to new assets. You can control the refresh behavior in <code>application_visit.js</code>.</p>"},{"location":"page-response/#csrftoken","title":"<code>csrfToken</code>","text":"<p>The authenticity token that Superglue will use for non-GET request made by using <code>visit</code> or <code>remote</code> thunks. This includes forms that have the <code>data-sg-visit</code> or <code>data-sg-remote</code> attribute.</p>"},{"location":"page-response/#action-and-path","title":"<code>action</code> and <code>path</code>","text":"<p>Only included when <code>props_at</code> is part of the request parameters. <code>action</code> is always set to <code>graft</code> and <code>path</code> is the camelCase keypath to the requested node. Superglue uses these attributes to immutably graft a node from the server-side to the client-side.</p>"},{"location":"page-response/#renderedat","title":"<code>renderedAt</code>","text":"<p>An UNIX timestamp representing the time the response was rendered.</p>"},{"location":"page-response/#fragments","title":"<code>fragments</code>","text":"<p>An <code>array</code> of fragments. In <code>application.json.props</code> this is set to <code>json.fragments!</code>.</p>"},{"location":"page-response/#restorestrategy","title":"<code>restoreStrategy</code>","text":"<p>By specifying the restore strategy used (<code>fromCacheOnly</code>, <code>revisitOnly</code>, or <code>fromCacheAndRevisitInBackground</code>), you can control what superglue does when encountering the page again when pressing the back or forward browser navigation buttons.</p> <ul> <li><code>fromCacheAndRevisitInBackground</code> will transition to the cached page, then   issue a visit in the background, redirecting and replacing history if needed.   This is the option set in <code>application.json.props</code> when using the generators.</li> <li><code>revisitOnly</code> will always issue a visit request in the background before</li> <li><code>fromCacheOnly</code> will only restore the page from cache   transitioning</li> </ul>"},{"location":"page-response/#slices","title":"<code>slices</code>","text":"<p>An object merged with the <code>initialState</code> when implementing <code>buildStore</code> inside of <code>application.js</code>. You can use this as the initial state for redux slices. Take advantage of the <code>SAVE_RESPONSE</code> to continually update your slice everytime superglue recieves a new page request.</p>"},{"location":"rails-utils/","title":"Rails utils","text":""},{"location":"rails-utils/#rendering-defaults","title":"Rendering defaults","text":"<p>Superglue typically requires 3 templates.</p> <pre><code>app/views/\n  posts/\n    index.html.erb # duplicated\n    index.jsx\n    index.json.props\n  users/\n    index.html.erb # duplicated\n    index.jsx\n    index.json.props\n</code></pre> <p>Use <code>use_jsx_rendering_defaults</code> and <code>superglue_template</code> for cleaner directories.</p> <pre><code>class PostsController &lt; ApplicationController\n  before_action :use_jsx_rendering_defaults\n  superglue_template \"application/superglue\" #defaults to application/superglue\nend\n</code></pre> <p>Warning</p> <p>The <code>file</code>, <code>partial</code>, <code>body</code>, <code>plain</code>, <code>html</code>, <code>inline</code> will not work with <code>render</code> when using <code>before_action :use_jsx_rendering_defaults</code> callback. Make use of <code>:only</code> and <code>:except</code> to narrow down its usage.</p> <p>Which will allow you to deduplicate the files:</p> <pre><code>app/views\n  application/\n    superglue.html.erb\n  posts/\n    index.jsx\n    index.json.props\n  users/\n    index.jsx\n    index.json.props\n</code></pre> <p>and omit <code>props</code> files for cases when there is no content.</p> <pre><code>app/views\n  application/\n    superglue.html.erb\n  about/\n    index.jsx\n</code></pre>"},{"location":"rails-utils/#redirect_back_with_props_at","title":"<code>redirect_back_with_props_at</code>","text":"<p>A helper to help retain the <code>props_at</code> parameter as part of the redirect <code>location</code>. This helper has the same method signature as Rails own <code>redirect_back</code>.</p> <pre><code>def create\n  redirect_back_with_props_at fallback_url: '/'\nend\n</code></pre>"},{"location":"rails-utils/#setting-the-content-location","title":"Setting the content location","text":"<p>You can override the URL Superglue uses to display on the address bar and store your response directly from the server using <code>content-location</code>. This is optional. For example:</p> <pre><code>def create\n  @post = Post.new(post_params)\n\n  if @post.save\n    redirect_to @post, notice: 'Post was successfully created.'\n  else\n    response.set_header(\"content-location\", new_post_path)\n    render :new\n  end\nend\n</code></pre>"},{"location":"redux-state-shape/","title":"The store shape","text":"<p>Superglue occupies 2 nodes in your Redux state tree:</p> <pre><code>{\n  superglue: {\n    csrfToken,\n    currentPageKey,\n    pathname,\n    search,\n    hash,\n  },\n  pages: {\n    '/dashboard': { ..page received from `/dashboard`.. },\n    '/posts?foo=123': {... page received from `/posts?foo=123` },\n  }\n}\n</code></pre>"},{"location":"redux-state-shape/#superglue","title":"<code>superglue</code>","text":"<p>The <code>superglue</code> node contains information about your application that you may find useful. You may read from this store, but do not write.</p>"},{"location":"redux-state-shape/#pages","title":"<code>pages</code>","text":"<p>The <code>pages</code> node is where rendered pages live. It's a hash where the keys are the pathname + query of your url, known throughout the documentation as <code>pageKey</code>, and the values are received JSON responses.</p> <p>The <code>pageKey</code> does not include the location hash of your URL. This is by design, Superglue ignores the location hash and falls back to browser defaults. So while you can visit <code>/posts#foo</code> and <code>/posts</code> in the browser, Superglue will store both as <code>/posts</code>.</p>"},{"location":"redux-state-shape/#architecture-motivation","title":"Architecture motivation","text":"<p>There's less guesswork. Business logic is complex and diverse across industry verticals, but the presentational aspects remain largely unchanged. There will always be a header, a footer, a menu, a body with a list of items, etc.</p> <p>Superglue shapes its store with this observation in mind so that any developer can look at a running application, easily guess the shape of the store, and make close-to-correct assumptions on how to update the store without looking at any code.</p> <p>It's extremely productive with PropsTemplate. A keypath in your url like so <code>remote(/dashboard?props_at=data.content.barChart)</code> is enough to query your content on the server-side, respond with a node, and graft it at the same location in your redux state.</p>"},{"location":"requests/","title":"Requests","text":"<p>If you prefer to navigate using Javascript, or need more functionality than what UJS offers, Superglue comes with two functions built around <code>fetch</code>, <code>visit</code> and <code>remote</code>. These are wrapped with your own implementation in application_visit.js and can be accessed via the NavigationContext.</p> <p>Tip</p> <p>Superglue does not come with a <code>&lt;Link&gt;</code> component. Instead we encourage you to build one that is unique to your projects needs using the functions provided by the NavigationContext.</p> <pre><code>import { NavigationContext } from '@thoughtbot/superglue';\n\nconst { remote, visit } = useContext(NavigationContext)\n</code></pre>"},{"location":"requests/#visit","title":"visit","text":"<p><code>visit</code> is designed to mimic browser navigation for clicks and form submissions without the impact of a full page reload. There can be only one visit at a time and when successful <code>visit</code> will swap out the current page component for the next one.</p> <p>At glance it looks like this:</p> <pre><code>sequenceDiagram\n    autonumber\n    Browser -&gt;&gt; Superglue: Click request to `/posts/new` intercepted\n    activate Superglue\n    Superglue --&gt;&gt; Server: Re-request with format JSON `/posts/new.json`\n    activate Server\n    Server --&gt;&gt; Superglue: `/posts/new.json` response\n    Superglue --&gt;&gt; Superglue: Save response and swap page components\n    deactivate Server\n    Superglue --&gt;&gt; Browser: Update browser history, scroll position\n    deactivate Superglue</code></pre> <p>Hint</p> <p>Its possible to modify the visit payload before it saves to the store. See the beforeSave callback.</p> <ul> <li> See complete reference      for <code>visit</code></li> </ul>"},{"location":"requests/#remote","title":"remote","text":"<p>Use <code>remote</code> when you want to asynchronously update parts of a page or save a page to the store without swapping the page component or change the browser history. Unlike visit, you can fire off as many async <code>remote</code> requests as you want.</p> <p>Hint</p> <p>Its possible to modify the remote payload before it saves to the store. See the beforeSave callback.</p> <p>At glance it looks like this:</p> <pre><code>sequenceDiagram\n  alt target default current page\n    autonumber\n    Browser -&gt;&gt; Superglue: Click request to `/posts/new` intercepted\n    activate Superglue\n    Superglue --&gt;&gt; Server: Re-request with format JSON `/posts/new.json`\n    activate Server\n    Server --&gt;&gt; Superglue: `/posts/new.json` response\n    Superglue --&gt;&gt; Superglue: Save response\n    Superglue --&gt;&gt; Browser: User on current page sees update\n    deactivate Server\n    deactivate Superglue\n  end</code></pre> <p>By default, <code>remote</code> derives a <code>pagekey</code> from the response to save the page. You can override this behavior and expliclity pass a <code>pageKey</code> option to target a different page in the store. If the user is not viewing the target page, they will not see an update.</p> <p>Warning</p> <p>The componentIdentifier from the page response MUST match the target page, otherwise remote will throw a <code>MismatchedComponentError</code> error. You can override this by using the <code>force: true</code> option. See the docs for details.</p> <pre><code>sequenceDiagram\n  alt target another page in the store\n    autonumber\n    Browser -&gt;&gt; Superglue: Click request to `/posts/new` intercepted\n    activate Superglue\n    Superglue --&gt;&gt; Server: Re-request with format JSON `/posts/new.json`\n    activate Server\n    Server --&gt;&gt; Superglue: `/posts/new.json` response\n    Superglue --&gt;&gt; Superglue: Save response or update target page\n    Note right of Browser: User does not see an update to the current page\n    deactivate Server\n    deactivate Superglue\n  end</code></pre> <ul> <li> See complete reference      for <code>remote</code></li> </ul> <ul> <li> See note      for differences between <code>remote</code> and <code>data-sg-remote</code></li> </ul> <p>Customizations</p> <p>You can modify the behavior of <code>visit</code> and <code>remote</code> functions globally from <code>application_visit.js</code>. If you need a global customization, e.g, progress bars, you can add them there.</p>"},{"location":"tutorial/","title":"Tutorial","text":""},{"location":"tutorial/#hello-world","title":"Hello World","text":"<p>For this tutorial, you will be building a \"Hello World\" page. It's one page, but we'll add complexity as we progress to highlight the power of Superglue.</p> <p>Let's build a new rails project:</p> <pre><code>rails new tutorial -j esbuild --skip-hotwire\n</code></pre> <p>Tip</p> <p>We're using esbuild here, but you can also use vite</p> <p>then follow the installation instructions to setup Superglue.</p>"},{"location":"tutorial/#start-with-the-usual","title":"Start with the usual","text":"<p>Let's begin by adding a route and a controller to an app.</p> <code>routes.rb</code><code>greets_controller.rb</code> <p>in <code>app/config/routes.rb</code></p> <pre><code>resource :greet, only: :show\n</code></pre> <p>in <code>app/controllers/greets_controller.rb</code></p> <p>Tip</p> <p><code>use_jsx_rendering_defaults</code> enables Rails to look for <code>.jsx</code> files and pairs with <code>.props</code> files. For example:</p> <pre><code>app/views\n  application/\n    superglue.html.erb\n  about/\n    index.jsx\n  users/\n    index.jsx\n    index.json.props\n</code></pre> <pre><code>class GreetsController &lt; ApplicationController\n  before_action :use_jsx_rendering_defaults\n\n  def show\n  end\nend\n</code></pre>"},{"location":"tutorial/#add-the-views","title":"Add the views","text":"<p>Next, let's add the following views.</p> <ul> <li><code>app/views/greets/show.json.props</code></li> <li><code>app/views/greets/show.jsx</code></li> </ul> <p>The Superglue installation generator also adds an <code>application/superglue.html.erb</code>, which will be used as the default HTML template for every controller action.</p> <p>Click the tabs below to see the contents:</p> 1. <code>show.json.props</code>2. <code>show.jsx</code>3. <code>application/superglue.html.erb</code> <p>If you've used Jbuidler, this should look familiar. Here, we're using props_template, a Jbuilder inspired templating DSL built for Superglue.</p> <p>Info</p> <p>Shape the page to how you would visually organize your components. Superglue encourages you to shape <code>json</code> responses to include both data AND presentation.</p> <pre><code>json.body do\n  json.greet \"Hello world\"\nend\n\njson.footer \"Made with hearts\"\n</code></pre> <p>This is the page component that will receive the result of <code>show.json.props</code>.</p> <pre><code>import React from 'react'\nimport { useContent } from '@thoughtbot/superglue';\n\nexport default function GreetsShow() {\n  const {\n    body,\n    footer\n  } = useContent()\n\n  const {greet} = body\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;{greet}&lt;/h1&gt;\n      &lt;span&gt;{footer}&lt;/span&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre> <pre><code>&lt;script type=\"text/javascript\"&gt;\n  window.SUPERGLUE_INITIAL_PAGE_STATE=&lt;%= render_props %&gt;;&lt;%# erblint:disable ErbSafety %&gt;\n&lt;/script&gt;\n\n&lt;div id=\"app\"&gt;&lt;/div&gt;\n</code></pre> <p>This file renders <code>show.json.props</code> and injects it globally as the initial state to be picked up by Superglue on the browser.</p>"},{"location":"tutorial/#connect-the-dots","title":"Connect the dots","text":"<p>The JSON payload that gets injected contains a <code>componentIdentifier</code>.  We're going to use the <code>componentIdentifier</code> to tie <code>show.json.props</code> to <code>show.jsx</code> so Superglue knows which component to render with which response by modifying <code>app/javascript/page_to_page_mapping.js</code>.</p> <p>Info</p> <p>If you do not know what the <code>componentIdentifier</code> of a page is, you can always go to the <code>json</code> version of the page on your browser to see what gets rendered. In our case: http://localhost:3000/greet.json</p> <p>Vite Users This step can be entirely optional if you're using Vite. See the recipe for more information.</p> 1. Example <code>greet.json</code>2. <code>page_to_page_mapping.js</code> <p>The layout for <code>show.json.props</code> is located at <code>app/views/layouts/application.json.props</code>. It conforms to Superglue's payload response and uses the <code>active_template_virtual_path</code> as the <code>componentIdentifier</code>.</p> <pre><code>{\n  data: {\n    body: {\n      greet: \"Hello world\"\n    }\n    footer: \"Made with hearts\"\n  },\n  componentIdentifier: \"greet/show\",\n  ...\n}\n</code></pre> <pre><code>import GreetsShow from '../views/greets/show'\n\nexport const pageIdentifierToPageComponent = {\n  'greets/show': GreetsShow,\n};\n</code></pre>"},{"location":"tutorial/#finish","title":"Finish","text":"<p>Run <code>bin/dev</code> and go to http://localhost:3000/greet.</p>"},{"location":"tutorial/#productivity","title":"Productivity","text":"<p>That was quite an amount of steps to get to a Hello World. For simple functionality it's not immediately obvious where Superglue fits, but for medium complexity and beyond, Superglue shines where it can be clunky for tools like Turbo, Hotwire and friends.</p> <p>Let's add some complexity to the previous sample.</p> <p>Sidequest</p> <p>But first, A quick dive into props_template and how digging works. Click on the tabs to see what happens when <code>@path</code> changes for the example below.</p> <pre><code>json.data(dig: @path) do\n  json.body do\n    json.chart do\n      sleep 10\n      json.header \"Sales\"\n    end\n\n    json.user do\n      json.name \"John\"\n    end\n  end\n\n  json.footer do\n    json.year \"2003\"\n  end\nend\n\njson.componentIdentifier \"someId\"\n</code></pre> <code>data</code><code>data.body</code><code>data.body.user</code><code>data.footer</code> <p>When <code>@path = ['data']</code>. There's a 10-second sleep, and the output will be:</p> <pre><code>{\n  data: {\n    body: {\n      chart: {\n        header: \"Sales\"\n      },\n      user: {\n        name: \"John\"\n      }\n    },\n    footer: {\n      year: \"2003\"\n    }\n  },\n  componentIdentifier: \"someId\"\n}\n</code></pre> <p>When <code>@path = ['data', 'body']</code>. There's a 10-second sleep, and the output will be:</p> <pre><code>{\n  data: {\n    chart: {\n      header: \"Sales\"\n    },\n    user: {\n      name: \"John\"\n    }\n  },\n  componentIdentifier: \"someId\"\n}\n</code></pre> <p>When <code>@path = ['data', 'body', 'user']</code>, there is no wait, and the <code>json</code> will be:</p> <pre><code>{\n  data: {\n    name: \"john\"\n  },\n  componentIdentifier: \"someId\"\n}\n</code></pre> <p>When <code>@path = ['data', 'year']</code>, there is no wait, and the <code>json</code> will be:</p> <pre><code>{\n  data: {\n    year: \"2003\"\n  },\n  componentIdentifier: \"someId\"\n}\n</code></pre>"},{"location":"tutorial/#continuing-where-we-last-left-off","title":"Continuing where we last left off","text":"<p>Let's add a 5-second sleep to <code>show.json.props</code> so every user is waiting for 5 seconds for every page load.</p> <p><code>show.json.props</code></p> <pre><code>json.body do\n  sleep 5\n  json.greet \"Hello world\"\nend\n\njson.footer \"Made with hearts\"\n</code></pre> <p>How should we improve the user experience?</p>"},{"location":"tutorial/#load-the-content-later-manual-deferment","title":"Load the content later (Manual deferment)","text":"<p>What if we add a link on the page that would load the greeting async? Sounds like a good start, lets do that.</p> <p>First, we'll use <code>defer: :manual</code> to tell props_template to skip over the block.</p> <code>show.json.props</code>output<code>show.jsx</code> <pre><code>json.body(defer: :manual) do\n  sleep 5\n  json.greet \"Hello world\"\nend\n\njson.footer \"Made with hearts\"\n</code></pre> <p>Adding <code>defer: :manual</code> will replace the contents with an empty object.</p> <pre><code>{\n  data: {\n    body: {},\n    footer: \"Made with hearts\"\n  },\n  componentIdentifier: \"greet/show\",\n  ...\n}\n</code></pre> <p>We'll also have to handle the case when there is no greeting.</p> <p>Info</p> <p>We'll improve on this approach. The <code>defer</code> option can specify a fallback.</p> <pre><code>import React from 'react'\nimport { useContent } from '@thoughtbot/superglue'\n\nexport default function GreetsShow() {\n  const {\n    body,\n    footer,\n  } = useContent()\n  const {greet} = body\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;{greet || \"Waiting for greet\"}&lt;/h1&gt;\n      &lt;span&gt;{footer}&lt;/span&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"tutorial/#add-a-link","title":"Add a link","text":"<p>Now when the user lands on the page, we're no longer waiting 5 seconds. Lets add a link that will dig for the missing content to replace \"Waiting for greet\".</p> <code>show.json.props</code><code>show.jsx</code> <p>Add a URL for the <code>href</code> link with the <code>props_at</code> param. This is used on the <code>application.json.props</code> layout that instructs <code>props_template</code> to dig.</p> <pre><code>json.body(defer: :manual) do\n  sleep 5\n  json.greet \"Hello world\"\nend\n\njson.loadGreetPath greet_path(props_at: \"data.body\")\n\njson.footer \"Made with hearts\"\n</code></pre> <p>Superglue embraces Unobtrusive Javascript. Add a <code>data-sg-remote</code> to any link, and Superglue will take care of making the fetch call.</p> <p>Tip</p> <p>Clicking on a link won't show a progress indicator. In practice, the first thing you want to do with a new Superglue project is add a progress bar.</p> <pre><code>import React from 'react'\nimport { useContent } from '@thoughtbot/superglue'\n\nexport default function GreetsShow() {\n  const {\n    body,\n    footer,\n    loadGreetPath\n  } = useContent()\n\n  const {greet} = body\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;{greet || \"Waiting for greet\"}&lt;/h1&gt;\n      &lt;a href={loadGreetPath} data-sg-remote&gt;Greet!&lt;/a&gt;\n      &lt;span&gt;{footer}&lt;/span&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"tutorial/#finish_1","title":"Finish","text":"<p>And that's it. Now you have a button that will load content in an async fashion, but how does it all work? Let's take a look at <code>loadGreetPath</code></p> <pre><code>/greet?props_at=data.greet\n</code></pre> <p>The shape of <code>show.json.props</code> is exactly the same as what is stored in the redux store on <code>pages[\"/greet\"]</code>. With a single keypath on <code>props_at</code> we grabbed the content at <code>data.greet</code> from <code>show.json.props</code> AND stored it on <code>data.greet</code> on <code>pages[\"/greet\"]</code>.</p> <p>Now that's productive!</p> <p>Tip</p> <p>This <code>show.jsx</code> alternative does the same thing, but we're using the <code>remote</code> function directly.</p> <pre><code>import React, { useContext } from 'react'\nimport { useContent, Navigationcontext } from '@thoughtbot/superglue'\n\nexport default function GreetsShow() {\n  const {\n    body,\n    footer,\n    loadGreetPath\n  } = useContent()\n  const {greet} = body\n\n  const { remote } = useContext(NavigationContext)\n  const handleClick = (e) =&gt; {\n    e.preventDefault()\n    remote(loadGreetPath)\n  }\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;{greet || \"Waiting for greet\"}&lt;/h1&gt;\n      &lt;a href={loadGreetPath} onClick={handleClick}&gt;Greet!&lt;/a&gt;\n      &lt;span&gt;{footer}&lt;/span&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"tutorial/#improvements","title":"Improvements","text":"<p>In practice, there's a far simpler solution: <code>defer: :auto</code>, which would do all of the above without a button.</p> <code>show.json.props</code><code>show.jsx</code> <p>The only change needed would be to use the <code>:auto</code> option with a placeholder. The response would tell Superglue to:</p> <ol> <li>Save the page (with the placeholder)</li> <li>Look for any deferred nodes</li> <li>Automatically create a remote request for the missing node</li> </ol> <pre><code>json.body(defer: [:auto, placeholder: { greet: \"Waiting for Greet\"}]) do\n  sleep 5\n  json.greet \"Hello world\"\nend\n\njson.footer \"Made with hearts\"\n</code></pre> <p>No changes to the original <code>show.jsx</code> component. We don't even have to create a conditional, the initial page response will contain a placeholder.</p> <pre><code>import React from 'react'\nimport { useContent } from '@thoughtbot/superglue'\n\nexport default function GreetsShow() {\n  const {\n    body,\n    footer\n  } = useContent()\n  const {greet} = body\n\n  return (\n    &lt;&gt;\n      &lt;h1&gt;{greet}&lt;/h1&gt;\n      &lt;span&gt;{footer}&lt;/span&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"ujs/","title":"The return of Rails UJS","text":"<p>Unobtrusive Javascript is an easy way to added single page app like features to HTML links and form tags. Its taken a backseat since the introduction of Hotwire, but Superglue puts UJS back in the forefront and packs it with functionality that makes building SPA-like functionality easy and consistent.</p> <p>Want to reload a shopping cart?</p> <pre><code>&lt;a href=\"/props_at=data.sideBar.shoppingCart\" data-sg-remote&gt;Reload the cart&lt;/a&gt;\n</code></pre> <p>Or maybe load a modal efficiently when the next page has one?</p> <pre><code>&lt;a href=\"/posts/new?props_at=data.modal\"&gt;Create Post&lt;/a&gt;\n</code></pre> <p>With Superglue, there is just one concept. No need for the complexity of Stimulus controllers, Turbo Streams, or Turbo Frames.</p>"},{"location":"ujs/#navigating-with-ujs","title":"Navigating with UJS","text":"<p>Superglue operates like a multipage application. In other to transition to the next page without reloading you'll need to use UJS attributes <code>data-sg-remote</code> or <code>data-sg-visit</code>.</p>"},{"location":"ujs/#data-sg-visit","title":"<code>data-sg-visit</code>","text":"<p>Use <code>data-sg-visit</code> when you want to navigate to the next page and update the address bar without reloading.</p> <pre><code>&lt;a href='/posts/new' data-sg-visit /&gt;\n</code></pre> <p>In the above example, when the link is clicked, Superglue will intercept the click, make a request for <code>/posts/new.json</code>, swap your page component, and pass the payload.</p> <p>Note</p> <p>You are not able to specify the HTTP method used in a UJS link.</p> <p>This is intentional. If you want to create a link that can support <code>POST</code>, <code>PUT</code>, <code>DELETE</code> methods, create a form component that looks like a link and use props generated from form_props</p> <p>You can also use <code>data-sg-visit</code> on forms:</p> <pre><code>&lt;form action='/some_url' data-sg-visit /&gt;\n</code></pre>"},{"location":"ujs/#data-sg-remote","title":"<code>data-sg-remote</code>","text":"<p>Use <code>data-sg-remote</code> when you want to update parts of the current page without reloading the screen.</p> <p>Differences from <code>remote</code></p> <p>The only difference between <code>data-sg-remote</code> and <code>remote</code>, is that <code>data-sg-remote</code> passes the current page as the target <code>pageKey</code> of <code>remote</code>.</p> <p><code>remote</code>, normally would work like a background <code>visit</code> that doesn't change the url and will use the URL of the response to save the payload.</p> <p>But most of the time, if you're using <code>data-sg-remote</code> on a page, you want to dig for <code>props</code> and attach that somewhere in the current page. For convienence, we've modified the call so that we set the <code>pageKey</code> for you.</p> <p>Combine this with props_template's [digging] to selectively load content.</p> <pre><code>&lt;a href='/posts?page_num=2&amp;props_at=data.body.postsList' data-sg-remote/&gt;\n  Next Page\n&lt;/a&gt;\n</code></pre> <p>You can also use <code>data-sg-remote</code> on forms.</p> <pre><code>&lt;form action=\"/posts\" method=\"GET\" data-sg-remote&gt;\n  &lt;input type=\"search\" .... /&gt;\n  ....\n&lt;/form&gt;\n</code></pre>"},{"location":"ujs/#expanding-ujs","title":"Expanding UJS","text":"<p>The dataset of the element enabled with <code>data-sg-visit</code> or <code>data-sg-remote</code> is passed to your application_visit.js. You can add your own options to control the behavior of the UJS helpers. For example, if you want to selectively show a progress bar on some links.</p>"},{"location":"ujs/#data-sg-replace","title":"<code>data-sg-replace</code>","text":"<p>Included in application_visit.js as an expanded option is <code>data-sg-replace</code>. It pairs with <code>data-sg-visit</code> to replace history instead of pushing when a user clicks on a form or a link. This can be useful when working with data tables with a large number of click-to-filter options that push history.</p>"},{"location":"recipes/infinite-scroll/","title":"Infinite scroll","text":"<p>In this recipe, we'll add infinite scroll to our application. Superglue doesn't have an infinite scroll component, but it has tools that make it easy to work with React's ecosystem.</p> <p>Lets begin by adding <code>react-infinite-scroll-hook</code></p> <pre><code>yarn add react-infinite-scroll-hook\n</code></pre> <p>And continue off from our pagination recipe.</p> <p>Tip</p> <p>We'll use the <code>beforeSave</code> callback to modify the payload before superglue saves it to the store. This callback is an option for both <code>visit</code> and <code>remote</code> functions. See the beforeSave reference for more details.</p> <pre><code>// app/views/posts/index.js\n\nimport React from 'react'\n- import {useContent} from '@thoughtbot/superglue'\n+ import {useContent, NavigationContext} from '@thoughtbot/superglue'\nimport PostList from './PostList'\nimport Header from './Header'\n+ import useInfiniteScroll from 'react-infinite-scroll-hook';\n\nexport default PostIndex = () =&gt; {\n  const {\n    posts,\n    header,\n    pathToNextPage,\n    pathToPrevPage\n  } = useContent()\n\n+ const { remote, pageKey } = useContext(NavigationContext)\n+ const { loading, setLoading } = useState(false)\n+ const hasNextPage = !!pathToNextPage\n+\n+ const beforeSave = (prevPage, receivedPage) =&gt; {\n+   const prevPosts = prevPage.data.posts\n+   const receivedPosts = receivedPage.data.posts\n+   receivedPage.data.posts = prevPosts + receivedPosts\n+\n+   return receivedPage\n+ }\n+\n+ const loadMore = () =&gt; {\n+   setLoading(true)\n+   remote(pathToNextPage, {pageKey, beforeSave})\n+     .then(() =&gt; setLoading(false))\n+ }\n+\n+ const [sentryRef] = useInfiniteScroll({\n+   loading,\n+   hasNextPage,\n+   onLoadMore: loadMore,\n+ });\n\n  return (\n    &lt;&gt;\n      &lt;Header {...header}/&gt;\n      &lt;div&gt;\n        {\n          posts.list.map(({id, body}) =&gt; (\n            &lt;p key={id}&gt;{body}&lt;/p&gt;\n          ))\n        }\n+       {(loading || hasNextPage) &amp;&amp; (\n+         &lt;p ref={sentryRef}&gt;\n+           loading\n+         &lt;/p&gt;\n+       )}\n      &lt;/div&gt;\n-     {pathToPrevPage &amp;&amp; &lt;a href={pathToPrevPage} data-sg-visit&gt;Prev Page&lt;/a&gt;}\n-     {pathToNextPage &amp;&amp; &lt;a href={pathToNextPage} data-sg-visit&gt;Next Page&lt;/a&gt;}\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/modals/","title":"Modals","text":"<p>Modals are easy. Lets imagine a scenario where we have two urls:</p> <ol> <li><code>/posts</code></li> <li><code>/posts/new</code></li> </ol> <p>When a user visits <code>/posts/new</code> from <code>/posts</code>, we want a modal to appear overlaying the existing list of posts. The overlay should work if a user chooses instead to directly visit <code>/posts/new</code>.</p>"},{"location":"recipes/modals/#the-setup","title":"The setup","text":"<p>Both urls render a list of posts. Lets set up the controller and the <code>page_to_page_mapping.js</code> the same way.</p> <code>posts_controller.rb</code><code>page_to_page_mapping.js</code> <p>Same template different action</p> <p>Notice that we're rendering the <code>index</code> for the <code>new</code> action. While the content is the same, the <code>componentIdentifier</code> is different as that has been setup to use the controller and action name.</p> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\nend\n\ndef new\n  @posts = Post.all\n  render :index\nend\n</code></pre> <p>Info</p> <p>Similarly, we tie the <code>componentIdentifier</code> to the same page component.</p> <p>Vite Users This step can be entirely optional if you're using Vite. See the recipe for more information.</p> <pre><code>import PostIndex from '../views/posts/index'\n\nexport const pageIdentifierToPageComponent = {\n  'posts/index': PostIndex,\n  'posts/new': PostIndex,\n};\n</code></pre>"},{"location":"recipes/modals/#add-a-link-to-postsnew","title":"Add a link to <code>/posts/new</code>","text":"<p>Imagine a list of posts, lets add a button somewhere on the index page to direct the user to <code>/posts/new</code>. As seen previously, both <code>/posts</code> and <code>/posts/new</code> render the same thing.</p> <code>posts/index.json.props</code><code>posts/index.js</code> <pre><code># app/views/posts/index.json.props\n\n...\n\njson.newPostPath new_post_path\n</code></pre> <pre><code>import { useContent } from '@thoughtbot/superglue'\n\nexport default PostIndex = () =&gt; {\n  const { newPostPath, ...rest } = useContent()\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n      &gt;\n      New Post\n    &lt;/a&gt;\n    ...\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#the-modal","title":"The modal","text":"<p>The link appears and we're able to navigate to <code>/posts/new</code>, but <code>/posts/new</code> is missing a modal. Not surprising as both routes are rendering the same content.</p> <p>Lets add a modal.</p> <code>posts/index.json.props</code><code>index.js</code><code>Modal.js</code> <p>Info</p> <p>For simplicity, we'll use a \"Hello World\" as the modal contents</p> <pre><code># app/views/posts/index.json\n\n...\n\njson.newPostPath new_post_path\n\n+ json.createPostModal do\n+   json.greeting \"Hello World\"\n+ end\n</code></pre> <pre><code>+ import Modal from './Modal'\n\nexport default PostIndex = ({\n  newPostPath,\n  createPostModal\n  ...rest\n}) =&gt; {\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n    &gt;\n      New Post\n    &lt;/a&gt;\n+   &lt;Modal {...createPostModal} /&gt;\n    ...\n  )\n}\n</code></pre> <p>Info</p> <p>This is a simplified modal, in practice you'll use this with <code>&lt;Dialog&gt;</code> or other modal library.</p> <pre><code>import Modal from './Modal'\n\nexport default Modal = ({\n  greeting\n}) =&gt; {\n  return (\n    &lt;div className=\"my-modal\"&gt;{greeting}&lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#too-many-modals","title":"Too many modals","text":"<p>Unfortunately, now BOTH routes have modals! Lets fix that by adding a conditional render.</p> <code>index.json.props</code><code>posts_controller.rb</code><code>Modal.js</code> <pre><code># app/views/posts/index.json.props\n\n...\n\njson.newPostPath new_post_path\n\njson.createPostModal do\n  json.greeting \"Hello World\"\n+ json.showModal @show_modal\nend\n</code></pre> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\n+ @show_modal = false\nend\n\ndef new\n  @posts = Post.all\n+ @show_modal = true\n  render :index\nend\n</code></pre> <pre><code>import Modal from './Modal'\n\nexport default Modal = ({\n  greeting,\n+  showModal\n}) =&gt; {\n  return (\n-   &lt;div className=\"my-modal\"&gt;{greeting}&lt;/div&gt;\n+   {showModal &amp;&amp; &lt;div className=\"my-modal\"&gt;{greeting}&lt;/div&gt;}\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#finish","title":"Finish!","text":"<p>Awesome! We have modals! Unfortunately, clicking <code>&lt;a href={newPostPath}&gt;New Post&lt;/a&gt;</code> will cause a new page load. We can remove the page load by adding <code>data-sg-visit</code> to the link. With <code>data-sg-visit</code>, Superglue will navigate to the next page without reloading the page, just like Turbo.</p>"},{"location":"recipes/modals/#postsindexjs","title":"<code>posts/index.js</code>","text":"<pre><code>import Modal from './Modal'\nimport { useContent } from '@thoughtbot/superglue'\n\nexport default PostIndex = () =&gt; {\n  const {\n    newPostPath,\n    createPostModal,\n    ...rest\n  } = useContent()\n\n  return (\n    ...\n    &lt;a\n      href={newPostPath}\n+     data-sg-visit\n    &gt;\n      New Post\n    &lt;/a&gt;\n    &lt;Modal {...createPostModal} /&gt;\n    ...\n  )\n}\n</code></pre>"},{"location":"recipes/modals/#optimization","title":"Optimization","text":"<p>With the above, a click on New Post while on <code>/posts</code> will</p> <ol> <li>Fetch <code>/posts/new</code> with <code>format=json</code></li> <li>Save the page to the store</li> <li>Swap the page components</li> <li>Change the url</li> </ol> <p>Unfortunately, step 1 is still a full page load. Commonly, we just want to load the modal without loading the entire page.</p> <p>Lets fix that!</p>"},{"location":"recipes/modals/#indexjson","title":"<code>index.json</code>","text":"<p>Recall how digging for content works. We'll add a <code>props_at</code> that digs for the modal on <code>/posts/new</code> while skipping other content on that page.</p> <pre><code># app/views/posts/index.json\n\n...\n\n- json.newPostPath new_post_path\n+ json.newPostPath new_post_path(props_at: `data.createPostModal`)\n\njson.createPostModal do\n  json.greeting \"Hello World\"\n  json.showModal @show_modal\nend\n</code></pre> <p>With that change, the sequence becomes:</p> <ol> <li>Copy the state in <code>/posts</code> to <code>/posts/new</code> in the store.</li> <li>Fetch <code>/posts/new?props_at=data.createPostModal</code></li> <li>Graft the result to the store at <code>/posts/new</code></li> <li>Swap the page components</li> <li>Change the url</li> </ol>"},{"location":"recipes/progress-bar/","title":"Progress Bars","text":"<p>Superglue does not come with a progress bar as it can be a personalized choice on how the indicator functions and looks. Instead we have <code>application_visit.js</code> where you can add the functionality however you like.</p> <p>In this recipe, we'll add a simple progress bar that will show when <code>visit</code> and <code>remote</code> gets used. You can choose to implement it for only <code>visit</code> instead.</p> <pre><code>yarn add request-stripe\n</code></pre> <p>And make the following edits to <code>application_visit.js</code></p> <pre><code>import { visit, remote } from '@thoughtbot/superglue/action_creators'\n+ import { requestStripe } from 'request-stripe';\n\nexport function buildVisitAndRemote(ref, store) {\n  const appRemote = (path, {dataset, options} = {}) =&gt; {\n    /**\n     * You can make use of `dataset` to add custom UJS options.\n     * If you are implementing a progress bar, you can selectively\n     * hide it for some links. For example:\n     *\n     * ```\n     * &lt;a href=\"/posts?props_at=data.header\" data-sg-remote data-sg-hide-progress&gt;\n     *   Click me\n     * &lt;/a&gt;\n     * ```\n     *\n     * This would be available as `sgHideProgress` on the dataset\n     */\n+   const done = requestStripe()\n    return store.dispatch(remote(path, options))\n+       .finally(() =&gt; done())\n  }\n\n  const appVisit = (path, {dataset, ...options} = {}) =&gt; {\n+   const done = requestStripe()\n    return store\n      .dispatch(visit(path, options))\n      .then((meta) =&gt; {\n        if (meta.needsRefresh) {\n          window.location = meta.url\n          return\n        }\n\n        ref.current.navigateTo(meta.pageKey, {\n          action: meta.navigationAction,\n        })\n\n        return meta\n      })\n      .finally(() =&gt; {\n+       done()\n      })\n      .catch((err) =&gt; {\n        const response = err.response\n\n        if (!response) {\n          console.error(err)\n          return\n        }\n\n        if (response.ok) {\n          window.location = response.url\n        } else {\n          if (response.status &gt;= 400 &amp;&amp; response.status &lt; 500) {\n            window.location = '/400.html'\n            return\n          }\n\n          if (response.status &gt;= 500) {\n            window.location = '/500.html'\n            return\n          }\n        }\n      })\n  }\n\n  return { visit: appVisit, remote: appRemote }\n}\n</code></pre>"},{"location":"recipes/shopping-cart/","title":"Shopping cart","text":"<p>In this recipe, we'll look at how to build a global shopping cart state. One that can be used in a header for a count of all quantity, a shopping cart panel, optimistic updates, etc. Here's how to achieve that:</p> <p>Render the cart in your props across all pages in your <code>application.json.props</code> and mark it as a fragment.</p> <pre><code>json.data do\n  json.cart partial: ['cart', fragment: true] do\n  end\n\n  yield\nend\n</code></pre> <p>Add a slice</p> <pre><code>import { createSlice, createAction } from '@reduxjs/toolkit'\nimport { updateFragments } from '@thoughtbot/superglue'\n\nexport const cartSlice = createSlice({\n  name: 'cart',\n  initialState: {},\n  reducers: {\n    addToCart: (state, action) =&gt; {\n      ....logic to add something to the cart ...\n    }\n  },\n  extraReducers: (builder) =&gt; {\n    builder.addCase(updateFragments, (state, action) =&gt; {\n     // Update the slice with the latest and greatest.\n      return action.value\n    })\n  }\n})\n</code></pre> <p>With <code>fragment</code> enabled, the above will populate the slice whenever a page is received, while allowing you the flexibility to make local edits using the custom <code>addToCart</code> reducer.</p> <p>You can use this cart slice as you normally would with Redux selectors</p> <pre><code>  // For the cart component\n  const cart = useSelector(state =&gt; state.cart)\n\n  // For a header quantity component\n  const cartCount = cart.lineItems.reduce((memo, line) =&gt; memo + line.qty, 0)\n</code></pre> <p>For updates to the backend, add a ujs attribute to a normal form.</p> <pre><code>  &lt;form action='/add_to_cart?props_at=data.header.cart' method='POST' data-sg-remote={true}&gt;\n</code></pre> <pre><code>def create\n  ... add to cart logic here...\n\n  # This helper will retain the `props_at` param when redirecting, which allows the\n  # partial rendering of the `show` page.\n  redirect_back_with_props_at fallback_url: '/'\nend\n</code></pre> <p>The above will <code>POST</code>, and get redirected back to the original page while fetching only the cart to update. This will be picked up by <code>extraReducers</code> and update the entire cart state.</p>"},{"location":"recipes/spa-pagination/","title":"SPA (Single Page Application) Pagination","text":"<p>In this recipe, we'll be adding pagination that works without reloading the page.</p>"},{"location":"recipes/spa-pagination/#starting-point","title":"Starting point","text":"<p>Lets pretend that we're already able to see a list of posts.</p> <code>posts_controller.rb</code><code>index.json.props</code><code>index.js</code> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\nend\n</code></pre> <p>Info</p> <p>In this example, we have a <code>sleep</code> that we will optimize for later</p> <pre><code># app/views/posts/index.json.props\n\njson.header do\n  json.name \"bob\"\n  sleep 2\nend\n\njson.posts do\n  json.list do\n    json.array! @posts do |post|\n      json.id post.id\n      json.body post.body\n      json.editPostPath edit_post_path(post)\n    end\n  end\nend\n</code></pre> <p>Info</p> <p>Let's assume <code>Header</code> is a simple component that exist.</p> <pre><code>// app/views/posts/index.js\n\nimport React from 'react'\nimport {useContent} from '@thoughtbot/superglue'\nimport Header from './Header'\n\nexport default PostIndex = () =&gt; {\n  const {\n    posts,\n    header\n  } = useContent()\n\n  return (\n    &lt;&gt;\n      &lt;Header {...header}/&gt;\n      &lt;div&gt;\n        {\n          posts.list.map(({id, body}) =&gt; (\n            &lt;p key={id}&gt;{body}&lt;/p&gt;\n          ))\n        }\n      &lt;/div&gt;\n      &lt;PostList items={posts}&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/spa-pagination/#add-gems","title":"Add gems","text":"<p>Lets also add Kaminari to your gem file</p> <pre><code>gem 'kaminari'\n</code></pre> <p>and <code>bundle</code></p>"},{"location":"recipes/spa-pagination/#add-pagination","title":"Add pagination","text":"<p>The changes here are almost same with the <code>.erb</code> counterpart. We're using <code>path_to_next_page</code> and <code>path_to_prev_page</code> which come with Kaminari, both methods return <code>nil</code> if there are no subsequent pages.</p> <p>Info</p> <p>Some helpers like <code>paginate</code> output HTML instead of JSON, but we can still use more primitives methods.</p> <code>posts_controller.rb</code><code>index.json.props</code><code>index.js</code> <pre><code># app/controllers/posts_controller.rb\n\ndef index\n  @posts = Post.all\n+   .page(params[:page_num])\n+   .per(10)\n+   .order(created_at: :desc)\nend\n</code></pre> <pre><code># app/views/posts/index.json.props\n\njson.posts do\n  json.list do\n    json.array! @posts do |post|\n      json.id post.id\n      json.body post.body\n      json.editPostPath edit_post_path(post)\n    end\n  end\n+\n+ json.pathToNextPage path_to_next_page(@posts)\n+ json.pathToPrevPage path_to_prev_page(@posts)\nend\n</code></pre> <pre><code>// app/views/posts/index.js\n\nimport React from 'react'\nimport {useContent} from '@thoughtbot/superglue'\nimport Header from './Header'\n\nexport default PostIndex = () =&gt; {\n  const {\n    posts,\n    header,\n+   pathToNextPage,\n+   pathToPrevPage\n  } = useContent()\n\n  return (\n    &lt;&gt;\n      &lt;Header {...header}/&gt;\n      &lt;div&gt;\n        {\n          posts.list.map(({id, body}) =&gt; (\n            &lt;p key={id}&gt;{body}&lt;/p&gt;\n          ))\n        }\n      &lt;/div&gt;\n+     {pathToPrevPage &amp;&amp; &lt;a href={pathToPrevPage}&gt;Prev Page&lt;/a&gt;}\n+     {pathToNextPage &amp;&amp; &lt;a href={pathToNextPage}&gt;Next Page&lt;/a&gt;}\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/spa-pagination/#smooth-navigation","title":"Smooth navigation","text":"<p>The above adds pagination, but each click on Next Page is a new page load.</p> <p>Lets navigate without a reload. In this example, we're using the UJS helper <code>data-sg-visit</code>, which would set the current page's state to the response without changing the URL.</p> <p><code>index.js</code></p> <pre><code>// app/views/posts/index.js\n\nimport React from 'react'\nimport {useContent} from '@thoughtbot/superglue'\nimport PostList from './PostList'\nimport Header from './Header'\n\nexport default PostIndex = () =&gt; {\n  const {\n    posts,\n    header,\n    pathToNextPage,\n    pathToPrevPage\n  } = useContent()\n\n  return (\n    &lt;&gt;\n      &lt;Header {...header}/&gt;\n      &lt;div&gt;\n        {\n          posts.list.map(({id, body}) =&gt; (\n            &lt;p key={id}&gt;{body}&lt;/p&gt;\n          ))\n        }\n      &lt;/div&gt;\n-     {pathToPrevPage &amp;&amp; &lt;a href={pathToPrevPage}&gt;Prev Page&lt;/a&gt;}\n+     {pathToPrevPage &amp;&amp; &lt;a href={pathToPrevPage} data-sg-visit&gt;Prev Page&lt;/a&gt;}\n-     {pathToNextPage &amp;&amp; &lt;a href={pathToNextPage}&gt;Next Page&lt;/a&gt;}\n+     {pathToNextPage &amp;&amp; &lt;a href={pathToNextPage} data-sg-visit&gt;Next Page&lt;/a&gt;}\n    &lt;/&gt;\n  )\n}\n</code></pre>"},{"location":"recipes/spa-pagination/#optimize","title":"Optimize!","text":"<p>Lets skip <code>data.header</code> when navigating and dig for <code>data.posts</code>. For the user, only the posts lists change, but the header stays the same.</p> <p>Info</p> <p>In effect, this achieves the same functionality as Turbo Frames, but Superglue leans more on Unobtrusive Javascript for better ergonomics.</p> <p><code>index.json.props</code></p> <p>Recall how digging for content works. We'll add a <code>props_at</code> that digs for the <code>json.posts</code> while skipping other content on that page.</p> <pre><code># app/views/posts/index.json.props\n\njson.header do\n  ...\nend\n\njson.posts do\n  json.list do\n    json.array! @posts do |post|\n      json.id post.id\n      json.body post.body\n      json.editPostPath edit_post_path(post)\n    end\n  end\n\n- json.pathToNextPage path_to_next_page(@posts)\n+ json.pathToNextPage path_to_next_page(@posts, props_at: 'data.posts')\n- json.pathToPrevPage path_to_prev_page(@posts)\n+ json.pathToPrevPage path_to_prev_page(@posts, props_at: 'data.posts')\nend\n</code></pre> <ul> <li> Interested in infinite-scroll?      for <code>visit</code></li> </ul>"},{"location":"recipes/ssr/","title":"Server-Side Rendering","text":"<p>Superglue's generators does not include Server Side Rendering, but we can add support using Humid, a SSR library built for Superglue.</p> <p>Follow the instructions. Then, if you're using esbuild, create a <code>app/javascript/server_rendering.js</code>:</p> <pre><code>import React from 'react';\nimport { Application } from '@thoughtbot/superglue';\nimport { buildVisitAndRemote } from './application_visit';\nimport { pageIdentifierToPageComponent } from './page_to_page_mapping';\nimport { store } from './store'\nimport { renderToString } from 'react-dom/server';\n\nrequire(\"source-map-support\").install({\n  retrieveSourceMap: filename =&gt; {\n    return {\n      url: filename,\n      map: readSourceMap(filename)\n    };\n  }\n});\n\nsetHumidRenderer((json, baseUrl, path) =&gt; {\n  const initialState = JSON.parse(json)\n  return renderToString(\n    &lt;Application\n      className=\"full-height\"\n      // The base url prefixed to all calls made by the `visit`\n      // and `remote` thunks.\n      baseUrl={baseUrl}\n      // The global var SUPERGLUE_INITIAL_PAGE_STATE is set by your erb\n      // template, e.g., application/superglue.html.erb\n      initialPage={initialState}\n      // The initial path of the page, e.g., /foobar\n      path={path}\n      // Callback used to setup visit and remote\n      buildVisitAndRemote={buildVisitAndRemote}\n      // Callback used to setup the store\n      store={store}\n      // Mapping between the page identifier to page component\n      mapping={pageIdentifierToPageComponent}\n    /&gt;,\n    {\n      concurrentFeatures: false,\n    }\n  )\n})\n</code></pre> <p>Next</p> <pre><code>yarn add esbuild-plugin-polyfill-node text-encoding whatwg-url\n</code></pre> <p>and add a esbuild build file.</p> <pre><code>import * as esbuild from 'esbuild'\nimport { polyfillNode } from \"esbuild-plugin-polyfill-node\";\n\n\nawait esbuild.build({\n  entryPoints: ['app/javascript/server_rendering.js'],\n  bundle: true,\n  platform: \"browser\",\n  define: {\n    \"process.env.NODE_ENV\": '\"production\"'\n  },\n  sourcemap: true,\n  outfile: 'app/assets/builds/server_rendering.js',\n  logLevel: \"info\",\n  loader: {\n    \".js\": \"jsx\",\n    \".svg\": \"dataurl\"\n  },\n  inject: [\"./shim.js\"],\n  plugins: [\n    polyfillNode({\n      globals: false\n    }),\n  ]\n})\n</code></pre> <p>Add a <code>shim.js</code> for the above. We'll need this for the v8 environment that mini-racer runs on.</p> <pre><code>export {TextEncoder, TextDecoder} from 'text-encoding'\nexport { URL, URLSearchParams } from 'whatwg-url'\n\nexport function MessageChannel() {\n  this.port1 = {\n    postMessage: function (message) {\n      console.log('Message sent from port1:', message);\n    },\n  };\n\n  this.port2 = {\n    addEventListener: function (event, handler) {\n      console.log(`Event listener added for ${event} on port2`);\n      this._eventHandler = handler;\n    },\n    removeEventListener: function (event) {\n      console.log(`Event listener removed for ${event} on port2`);\n      this._eventHandler = null;\n    },\n    simulateMessage: function (data) {\n      if (this._eventHandler) {\n        this._eventHandler({ data });\n      }\n    },\n  };\n}\n\nexport const navigator = {language: \"en-us\"}\n</code></pre> <p>Add a line to your <code>package.json</code> like so:</p> <pre><code>   \"scripts\": {\n+    \"build:ssr\": \"node ./build-ssr.mjs\"\n</code></pre> <p>Use <code>Humid.render</code> in all your <code>html</code> templates, e.g., <code>index.html.erb</code> or <code>superglue.html.erb</code>:</p> <pre><code>  &lt;script type=\"text/javascript\"&gt;\n-   window.SUPERGLUE_INITIAL_PAGE_STATE=&lt;%= render_props %&gt;;&lt;%# erblint:disable ErbSafety %&gt;\n+   &lt;% initial_state = render_props %&gt;\n+   window.SUPERGLUE_INITIAL_PAGE_STATE=&lt;%= initial_state %&gt;;&lt;%# erblint:disable ErbSafety %&gt;\n  &lt;/script&gt;\n- &lt;div id=\"app\"&gt;&lt;/div&gt;\n+ &lt;div id=\"app\"&gt;&lt;%= Humid.render(initial_state, request.scheme + '://' + request.host_with_port, request.fullpath).html_safe %&gt;&lt;/div&gt;\n</code></pre> <p>!&gt; Do not render spacing inside of <code>&lt;div id=\"app\"&gt;</code>. If you do, React will not hydrate properly and warn <code>Hydration failed because the initial UI does not match what was rendered on the server</code></p> <p>Change your <code>application.js</code> to use <code>hydrateRoot</code>:</p> <pre><code>- import { createRoot } from 'react-dom/client';\n+ import { hydrateRoot } from 'react-dom/client';\n</code></pre> <p>and change the rest of <code>application.js</code> accordingly. For example:</p> <pre><code>import React from 'react';\nimport { Application, VisitResponse } from '@thoughtbot/superglue';\nimport { hydrateRoot } from 'react-dom/client';\nimport { buildVisitAndRemote } from './application_visit';\nimport { pageIdentifierToPageComponent } from './page_to_page_mapping';\nimport { store } from './store'\n\nif (typeof window !== \"undefined\") {\n  document.addEventListener(\"DOMContentLoaded\", function () {\n    const appEl = document.getElementById(\"app\");\n    const location = window.location;\n\n    if (appEl) {\n      hydrateRoot(appEl,\n        &lt;Application\n          className=\"full-height\"\n          // The base url prefixed to all calls made by the `visit`\n          // and `remote` thunks.\n          baseUrl={location.origin}\n          // The global var SUPERGLUE_INITIAL_PAGE_STATE is set by your erb\n          // template, e.g., index.html.erb\n          initialPage={window.SUPERGLUE_INITIAL_PAGE_STATE}\n          // The initial path of the page, e.g., /foobar\n          path={location.pathname + location.search + location.hash}\n          // Callback used to setup visit and remote\n          buildVisitAndRemote={buildVisitAndRemote}\n          // Callback used to setup the store\n          store={store}\n          // Mapping between the page identifier to page component\n          mapping={pageIdentifierToPageComponent}\n        /&gt;\n      );\n    }\n  });\n}\n</code></pre> <p>and add build script your <code>package.json</code> to build both the client and server js bundles. For example:</p> <pre><code>   \"build\": \"yarn run build:web &amp;&amp; yarn run build:ssr\",\n   \"build:web\": \"esbuild app/javascript/application.js --bundle --sourcemap --outdir=app/assets/builds --loader:.js=jsx --loader:.svg=dataurl --public-path=/assets\",\n   \"build:ssr\": \"node ./build-ssr.mjs\",\n</code></pre>"},{"location":"recipes/turbo/","title":"Replicating Turbo behavior","text":"<p>With <code>data-sg-visit</code>, Superglue will always wait for a response before a navigation transition. Turbo's behavior is to transition first if possible while waiting for the response. To replicate this behavior:</p> <p>In your <code>application_visit.js</code> file:</p> <pre><code>+ import { urlToPageKey } from '@thoughtbot/superglue'\n\nconst appVisit = (...args) =&gt; {\n\n  const pageKey = urlToPageKey(args[0])\n+ // attempt to navigate first\n+ ref.current?.navigateTo(pageKey)\n\n  return store\n    .dispatch(visit(...args))\n    ....\n</code></pre> <p>This is different from restore strategy which controls what happens when the browser's <code>history</code> object pops.</p>"},{"location":"recipes/vite/","title":"Usage with vite","text":"<p>While you can use any js bundler you want with Superglue. Vite has conveniences that make working with Superglue easier.</p> <p>To get started, go ahead and follow the instructions to install vite_rails</p> <p>Next move your <code>app/javascript/entrypoints/application.jsx</code> file to <code>app/javascript/entrypoints/application.jsx</code> and update the references.</p> <p>Info</p> <p>When using Superglue's installation generator, a <code>app/javascript/application.jsx</code> gets generated. <code>vite_rails</code> expects this to be put in an <code>entrypoints</code> folder. If you're installing <code>vite_rails</code> after superglue's installation, the is set by <code>vite_rails</code> to be <code>app/javascript/entrypoints</code>.</p> <p>Migrate your <code>@views</code>, <code>@javascript</code> aliases to <code>vite.config.mts</code></p> <pre><code>import { defineConfig } from \"vite\";\nimport path from \"path\";\n\nimport RubyPlugin from \"vite-plugin-ruby\";\n\nexport default defineConfig({\n  resolve: {\n    alias: {\n      \"@views\": path.resolve(__dirname, \"app/views\"),\n      \"@javascript\": path.resolve(__dirname, \"app/javascript\"),\n    },\n  },\n  plugins: [RubyPlugin()],\n});\n</code></pre> <p>Make sure you're using <code>vite_javascript_tag</code> in your layout, <code>application.html.erb</code>.</p> <pre><code>&lt;%= vite_javascript_tag 'application.jsx' %&gt;\n</code></pre> <p>And finally, one of the more manual process of using superglue is the manual build of your <code>page_to_page_mapping.js</code> file. We can improve the developer experience by  removing that step by using this snippet:</p> <pre><code>const pageIdentifierToPageComponent = {}\nconst pages = import.meta.glob('../views/**/*.jsx', {eager: true})\n\nfor (const key in pages) {\n  if (pages.hasOwnProperty(key)) {\n    const identifier = key.replace(\"../views/\", \"\").split('.')[0];\n    pageIdentifierToPageComponent[identifier] = pages[key].default;\n  }\n}\n\nexport { pageIdentifierToPageComponent }\n</code></pre>"},{"location":"reference/","title":"Superglue","text":""},{"location":"reference/#references","title":"References","text":""},{"location":"reference/#usesuperglue","title":"useSuperglue","text":"<p>Re-exports useSuperglue</p> <p></p>"},{"location":"reference/#usecontent","title":"useContent","text":"<p>Re-exports useContent</p> <p></p>"},{"location":"reference/#navigationprovider","title":"NavigationProvider","text":"<p>Re-exports NavigationProvider</p> <p></p>"},{"location":"reference/#navigationcontext","title":"NavigationContext","text":"<p>Re-exports NavigationContext</p> <p></p>"},{"location":"reference/#supergluereducer","title":"superglueReducer","text":"<p>Re-exports superglue</p> <p></p>"},{"location":"reference/#pagereducer","title":"pageReducer","text":"<p>Re-exports pages</p> <p></p>"},{"location":"reference/#fetchargs","title":"FetchArgs","text":"<p>Re-exports FetchArgs</p> <p></p>"},{"location":"reference/#graftingsuccessaction","title":"GraftingSuccessAction","text":"<p>Re-exports GraftingSuccessAction</p> <p></p>"},{"location":"reference/#graftingerroraction","title":"GraftingErrorAction","text":"<p>Re-exports GraftingErrorAction</p> <p></p>"},{"location":"reference/#pagekey","title":"PageKey","text":"<p>Re-exports PageKey</p> <p></p>"},{"location":"reference/#restorestrategy","title":"RestoreStrategy","text":"<p>Re-exports RestoreStrategy</p> <p></p>"},{"location":"reference/#navigationaction","title":"NavigationAction","text":"<p>Re-exports NavigationAction</p> <p></p>"},{"location":"reference/#componentidentifier","title":"ComponentIdentifier","text":"<p>Re-exports ComponentIdentifier</p> <p></p>"},{"location":"reference/#keypath","title":"Keypath","text":"<p>Re-exports Keypath</p> <p></p>"},{"location":"reference/#jsonprimitive","title":"JSONPrimitive","text":"<p>Re-exports JSONPrimitive</p> <p></p>"},{"location":"reference/#jsonobject","title":"JSONObject","text":"<p>Re-exports JSONObject</p> <p></p>"},{"location":"reference/#jsonmappable","title":"JSONMappable","text":"<p>Re-exports JSONMappable</p> <p></p>"},{"location":"reference/#jsonkeyable","title":"JSONKeyable","text":"<p>Re-exports JSONKeyable</p> <p></p>"},{"location":"reference/#jsonvalue","title":"JSONValue","text":"<p>Re-exports JSONValue</p> <p></p>"},{"location":"reference/#parsedresponse","title":"ParsedResponse","text":"<p>Re-exports ParsedResponse</p> <p></p>"},{"location":"reference/#defer","title":"Defer","text":"<p>Re-exports Defer</p> <p></p>"},{"location":"reference/#visitresponse","title":"VisitResponse","text":"<p>Re-exports VisitResponse</p> <p></p>"},{"location":"reference/#page","title":"Page","text":"<p>Re-exports Page</p> <p></p>"},{"location":"reference/#graftresponse","title":"GraftResponse","text":"<p>Re-exports GraftResponse</p> <p></p>"},{"location":"reference/#pageresponse","title":"PageResponse","text":"<p>Re-exports PageResponse</p> <p></p>"},{"location":"reference/#fragment","title":"Fragment","text":"<p>Re-exports Fragment</p> <p></p>"},{"location":"reference/#allpages","title":"AllPages","text":"<p>Re-exports AllPages</p> <p></p>"},{"location":"reference/#supergluestate","title":"SuperglueState","text":"<p>Re-exports SuperglueState</p> <p></p>"},{"location":"reference/#rootstate","title":"RootState","text":"<p>Re-exports RootState</p> <p></p>"},{"location":"reference/#meta","title":"Meta","text":"<p>Re-exports Meta</p> <p></p>"},{"location":"reference/#visitmeta","title":"VisitMeta","text":"<p>Re-exports VisitMeta</p> <p></p>"},{"location":"reference/#visitcreator","title":"VisitCreator","text":"<p>Re-exports VisitCreator</p> <p></p>"},{"location":"reference/#remotecreator","title":"RemoteCreator","text":"<p>Re-exports RemoteCreator</p> <p></p>"},{"location":"reference/#dispatch","title":"Dispatch","text":"<p>Re-exports Dispatch</p> <p></p>"},{"location":"reference/#supergluestore","title":"SuperglueStore","text":"<p>Re-exports SuperglueStore</p> <p></p>"},{"location":"reference/#handlers","title":"Handlers","text":"<p>Re-exports Handlers</p> <p></p>"},{"location":"reference/#ujshandlers","title":"UJSHandlers","text":"<p>Re-exports UJSHandlers</p> <p></p>"},{"location":"reference/#historystate","title":"HistoryState","text":"<p>Re-exports HistoryState</p> <p></p>"},{"location":"reference/#saveandprocesspagethunk","title":"SaveAndProcessPageThunk","text":"<p>Re-exports SaveAndProcessPageThunk</p> <p></p>"},{"location":"reference/#metathunk","title":"MetaThunk","text":"<p>Re-exports MetaThunk</p> <p></p>"},{"location":"reference/#visitmetathunk","title":"VisitMetaThunk","text":"<p>Re-exports VisitMetaThunk</p> <p></p>"},{"location":"reference/#defermentthunk","title":"DefermentThunk","text":"<p>Re-exports DefermentThunk</p> <p></p>"},{"location":"reference/#basicrequestinit","title":"BasicRequestInit","text":"<p>Re-exports BasicRequestInit</p> <p></p>"},{"location":"reference/#navigateto","title":"NavigateTo","text":"<p>Re-exports NavigateTo</p> <p></p>"},{"location":"reference/#navigationcontextprops","title":"NavigationContextProps","text":"<p>Re-exports NavigationContextProps</p> <p></p>"},{"location":"reference/#navigationproviderprops","title":"NavigationProviderProps","text":"<p>Re-exports NavigationProviderProps</p> <p></p>"},{"location":"reference/#buildstore","title":"BuildStore","text":"<p>Re-exports BuildStore</p> <p></p>"},{"location":"reference/#buildvisitandremote","title":"BuildVisitAndRemote","text":"<p>Re-exports BuildVisitAndRemote</p> <p></p>"},{"location":"reference/#setupprops","title":"SetupProps","text":"<p>Re-exports SetupProps</p> <p></p>"},{"location":"reference/#applicationprops","title":"ApplicationProps","text":"<p>Re-exports ApplicationProps</p> <p></p>"},{"location":"reference/#visit","title":"Visit","text":"<p>Re-exports Visit</p> <p></p>"},{"location":"reference/#visitprops","title":"VisitProps","text":"<p>Re-exports VisitProps</p> <p></p>"},{"location":"reference/#remote","title":"Remote","text":"<p>Re-exports Remote</p> <p></p>"},{"location":"reference/#remoteprops","title":"RemoteProps","text":"<p>Re-exports RemoteProps</p> <p></p>"},{"location":"reference/#beforesave","title":"BeforeSave","text":"<p>Re-exports BeforeSave</p> <p></p>"},{"location":"reference/#applicationremote","title":"ApplicationRemote","text":"<p>Re-exports ApplicationRemote</p> <p></p>"},{"location":"reference/#applicationvisit","title":"ApplicationVisit","text":"<p>Re-exports ApplicationVisit</p>"},{"location":"reference/#variables","title":"Variables","text":""},{"location":"reference/#grafting_error","title":"GRAFTING_ERROR","text":"<p><code>const</code> GRAFTING_ERROR: <code>\"@@superglue/GRAFTING_ERROR\"</code> = <code>'@@superglue/GRAFTING_ERROR'</code></p>"},{"location":"reference/#defined-in","title":"Defined in","text":"<p>lib/actions.ts:12</p> <p></p>"},{"location":"reference/#grafting_success","title":"GRAFTING_SUCCESS","text":"<p><code>const</code> GRAFTING_SUCCESS: <code>\"@@superglue/GRAFTING_SUCCESS\"</code> = <code>'@@superglue/GRAFTING_SUCCESS'</code></p>"},{"location":"reference/#defined-in_1","title":"Defined in","text":"<p>lib/actions.ts:13</p> <p></p>"},{"location":"reference/#rootreducer","title":"rootReducer","text":"<p><code>const</code> rootReducer: {<code>superglue</code>: <code>superglueReducer</code>;<code>pages</code>: <code>pageReducer</code>; }</p>"},{"location":"reference/#type-declaration","title":"Type declaration","text":"Name Type Default value Defined in <code>superglue</code> (<code>state</code>: <code>SuperglueState</code>, <code>action</code>: <code>Action</code>) =&gt; <code>SuperglueState</code> superglueReducer lib/reducers/index.ts:236 <code>pages</code> (<code>state</code>: <code>AllPages</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllPages</code> pageReducer lib/reducers/index.ts:237"},{"location":"reference/#defined-in_2","title":"Defined in","text":"<p>lib/reducers/index.ts:235</p>"},{"location":"reference/#functions","title":"Functions","text":""},{"location":"reference/#saveandprocesspage","title":"saveAndProcessPage()","text":"<p>saveAndProcessPage(<code>pageKey</code>: <code>string</code>, <code>page</code>: <code>VisitResponse</code> | <code>GraftResponse</code>): <code>SaveAndProcessPageThunk</code></p> <p>Save and process a rendered view from PropsTemplate. This is the primitive function that <code>visit</code> and <code>remote</code> calls when it receives a page.</p> <p>If you render a page outside the normal request response cycle, e.g, websocket, you can use this function to save the payload.</p>"},{"location":"reference/#parameters","title":"Parameters","text":"Parameter Type <code>pageKey</code> <code>string</code> <code>page</code> <code>VisitResponse</code> | <code>GraftResponse</code>"},{"location":"reference/#returns","title":"Returns","text":"<p><code>SaveAndProcessPageThunk</code></p>"},{"location":"reference/#defined-in_3","title":"Defined in","text":"<p>lib/action_creators/index.ts:74</p> <p></p>"},{"location":"reference/#saveresponse","title":"saveResponse()","text":"<p>saveResponse(...<code>args</code>: [{<code>pageKey</code>: <code>string</code>;<code>page</code>: <code>VisitResponse</code>; }]): {}</p> <p>Calling this redux#ActionCreator with <code>Args</code> will return an Action with a payload of type <code>P</code> and (depending on the <code>PrepareAction</code> method used) a <code>meta</code>- and <code>error</code> property of types <code>M</code> and <code>E</code> respectively.</p>"},{"location":"reference/#parameters_1","title":"Parameters","text":"Parameter Type ...<code>args</code> [{<code>pageKey</code>: <code>string</code>;<code>page</code>: <code>VisitResponse</code>; }]"},{"location":"reference/#returns_1","title":"Returns","text":"<p>{}</p>"},{"location":"reference/#defined-in_4","title":"Defined in","text":"<p>lib/actions.ts:15</p> <p></p>"},{"location":"reference/#updatefragments","title":"updateFragments()","text":"<p>updateFragments(<code>payload</code>: {<code>name</code>: <code>string</code>;<code>path</code>: <code>string</code>;<code>pageKey</code>: <code>string</code>;<code>value</code>: <code>JSONMappable</code>;<code>previousValue</code>: <code>JSONMappable</code>; }): {}</p> <p>A redux action called whenever a fragment is received from <code>visit</code> or updated using <code>remote</code>. Its a useful action to use for cross cutting concerns like a shared header or a shopping cart. For example:</p> <pre><code>import { updateFragments } from '@thoughtbot/superglue'\n\nexport const exampleSlice = createSlice({\n name: 'Example',\n initialState: {},\n extraReducers: (builder) =&gt; {\n   builder.addCase(updateFragments, (state, action) =&gt; {\n     // Update the slice using the latest and greatest.\n     return action.value\n</code></pre>"},{"location":"reference/#parameters_2","title":"Parameters","text":"Parameter Type <code>payload</code> <code>object</code> <code>payload.name</code> <code>string</code> <code>payload.path</code> <code>string</code> <code>payload.pageKey</code> <code>string</code> <code>payload.value</code> <code>JSONMappable</code> <code>payload.previousValue</code>? <code>JSONMappable</code>"},{"location":"reference/#returns_2","title":"Returns","text":"<p>{}</p>"},{"location":"reference/#defined-in_5","title":"Defined in","text":"<p>lib/actions.ts:64</p> <p></p>"},{"location":"reference/#copypage","title":"copyPage()","text":"<p>copyPage(<code>payload</code>: {<code>from</code>: <code>string</code>;<code>to</code>: <code>string</code>; }): {}</p> <p>A redux action you can dispatch to copy a page from one pageKey to another. Its a very useful way to create optimistic updates with a URL change. For example:</p> <pre><code>import { copyPage, remote } from '@thoughtbot/superglue'\n\ndispatch(copyPage({ from: originalKey, to: targetKey}))\n\n... make edits to target page and finally\n\nnavigateTo(targetKey)\n</code></pre>"},{"location":"reference/#parameters_3","title":"Parameters","text":"Parameter Type <code>payload</code> <code>object</code> <code>payload.from</code> <code>string</code> <code>payload.to</code> <code>string</code>"},{"location":"reference/#returns_3","title":"Returns","text":"<p>{}</p>"},{"location":"reference/#defined-in_6","title":"Defined in","text":"<p>lib/actions.ts:86</p> <p></p>"},{"location":"reference/#removepage","title":"removePage()","text":"<p>removePage(<code>payload</code>: {<code>pageKey</code>: <code>string</code>; }): {}</p> <p>A redux action you can dispatch to remove a page from your store.</p> <pre><code>import { removePage } from '@thoughtbot/superglue'\n\ndispatch(removePage({ pageKey: '/delete_me_please\"}))\n</code></pre>"},{"location":"reference/#parameters_4","title":"Parameters","text":"Parameter Type <code>payload</code> <code>object</code> <code>payload.pageKey</code> <code>string</code>"},{"location":"reference/#returns_4","title":"Returns","text":"<p>{}</p>"},{"location":"reference/#defined-in_7","title":"Defined in","text":"<p>lib/actions.ts:99</p> <p></p>"},{"location":"reference/#beforefetch","title":"beforeFetch()","text":"<p>beforeFetch(<code>payload</code>: {<code>fetchArgs</code>: <code>FetchArgs</code>; }): {}</p> <p>A redux action called before a <code>fetch</code> takes place. It will fire in <code>remote</code> and <code>visit</code>. You can hook into this event in your redux slices like this:</p> <pre><code>import { beforeFetch } from '@thoughtbot/superglue'\n\nexport const exampleSlice = createSlice({\n name: 'Example',\n initialState: {},\n extraReducers: (builder) =&gt; {\n   builder.addCase(beforeFetch, (state, action) =&gt; {\n</code></pre>"},{"location":"reference/#parameters_5","title":"Parameters","text":"Parameter Type <code>payload</code> <code>object</code> <code>payload.fetchArgs</code> <code>FetchArgs</code>"},{"location":"reference/#returns_5","title":"Returns","text":"<p>{}</p>"},{"location":"reference/#defined-in_8","title":"Defined in","text":"<p>lib/actions.ts:117</p> <p></p>"},{"location":"reference/#beforevisit","title":"beforeVisit()","text":"<p>beforeVisit(<code>payload</code>: {<code>currentPageKey</code>: <code>string</code>;<code>fetchArgs</code>: <code>FetchArgs</code>; }): {}</p> <p>A redux action called before a <code>visit</code> takes place. You can hook into this event in your redux slices like this:</p> <pre><code>import { beforeVisit } from '@thoughtbot/superglue'\n\nexport const exampleSlice = createSlice({\n name: 'Example',\n initialState: {},\n extraReducers: (builder) =&gt; {\n   builder.addCase(beforeVisit, (state, action) =&gt; {\n</code></pre>"},{"location":"reference/#parameters_6","title":"Parameters","text":"Parameter Type <code>payload</code> <code>object</code> <code>payload.currentPageKey</code> <code>string</code> <code>payload.fetchArgs</code> <code>FetchArgs</code>"},{"location":"reference/#returns_6","title":"Returns","text":"<p>{}</p>"},{"location":"reference/#defined-in_9","title":"Defined in","text":"<p>lib/actions.ts:135</p> <p></p>"},{"location":"reference/#beforeremote","title":"beforeRemote()","text":"<p>beforeRemote(<code>payload</code>: {<code>currentPageKey</code>: <code>string</code>;<code>fetchArgs</code>: <code>FetchArgs</code>; }): {}</p> <p>A redux action called before <code>remote</code> takes place. You can hook into this event in your redux slices like this:</p> <pre><code>import { beforeRemote } from '@thoughtbot/superglue'\n\nexport const exampleSlice = createSlice({\n name: 'Example',\n initialState: {},\n extraReducers: (builder) =&gt; {\n   builder.addCase(beforeRemote, (state, action) =&gt; {\n</code></pre>"},{"location":"reference/#parameters_7","title":"Parameters","text":"Parameter Type <code>payload</code> <code>object</code> <code>payload.currentPageKey</code> <code>string</code> <code>payload.fetchArgs</code> <code>FetchArgs</code>"},{"location":"reference/#returns_7","title":"Returns","text":"<p>{}</p>"},{"location":"reference/#defined-in_10","title":"Defined in","text":"<p>lib/actions.ts:154</p> <p></p>"},{"location":"reference/#preparestore","title":"prepareStore()","text":"<p>prepareStore(<code>store</code>: <code>SuperglueStore</code>, <code>initialPage</code>: <code>VisitResponse</code>, <code>path</code>: <code>string</code>): <code>void</code></p>"},{"location":"reference/#parameters_8","title":"Parameters","text":"Parameter Type <code>store</code> <code>SuperglueStore</code> <code>initialPage</code> <code>VisitResponse</code> <code>path</code> <code>string</code>"},{"location":"reference/#returns_8","title":"Returns","text":"<p><code>void</code></p>"},{"location":"reference/#defined-in_11","title":"Defined in","text":"<p>lib/index.tsx:51</p> <p></p>"},{"location":"reference/#setup","title":"setup()","text":"<p>setup(<code>__namedParameters</code>: <code>SetupProps</code>): {<code>visit</code>: <code>ApplicationVisit</code>;<code>remote</code>: <code>ApplicationRemote</code>;<code>nextHistory</code>: <code>History</code>;<code>initialPageKey</code>: <code>string</code>;<code>ujs</code>: <code>handlers</code>; }</p> <p>This is the setup function that the Application calls. Use this function if you like to build your own Application component.</p>"},{"location":"reference/#parameters_9","title":"Parameters","text":"Parameter Type <code>__namedParameters</code> <code>SetupProps</code>"},{"location":"reference/#returns_9","title":"Returns","text":"<p>{<code>visit</code>: <code>ApplicationVisit</code>;<code>remote</code>: <code>ApplicationRemote</code>;<code>nextHistory</code>: <code>History</code>;<code>initialPageKey</code>: <code>string</code>;<code>ujs</code>: <code>handlers</code>; }</p> Name Type Default value Defined in <code>visit</code> <code>ApplicationVisit</code> - lib/index.tsx:99 <code>remote</code> <code>ApplicationRemote</code> - lib/index.tsx:100 <code>nextHistory</code> <code>History</code> - lib/index.tsx:101 <code>initialPageKey</code> <code>string</code> - lib/index.tsx:102 <code>ujs</code> <code>Handlers</code> handlers lib/index.tsx:103"},{"location":"reference/#defined-in_12","title":"Defined in","text":"<p>lib/index.tsx:73</p> <p></p>"},{"location":"reference/#application","title":"Application()","text":"<p>Application(<code>__namedParameters</code>: <code>ApplicationProps</code>): <code>Element</code></p> <p>The entry point to your superglue application. It sets up the redux Provider, redux state and the Navigation component.</p> <p>This is a simple component, you can override this by copying the source code and use the exported methods used by this component (<code>start</code> and <code>ujsHandler</code>).</p>"},{"location":"reference/#parameters_10","title":"Parameters","text":"Parameter Type <code>__namedParameters</code> <code>ApplicationProps</code>"},{"location":"reference/#returns_10","title":"Returns","text":"<p><code>Element</code></p>"},{"location":"reference/#defined-in_13","title":"Defined in","text":"<p>lib/index.tsx:114</p> <p></p>"},{"location":"reference/#getin","title":"getIn()","text":"<p>getIn(<code>node</code>: <code>JSONMappable</code>, <code>path</code>: <code>string</code>): <code>JSONValue</code></p> <p>Retrieves data from a JSON object using a Keypath</p>"},{"location":"reference/#parameters_11","title":"Parameters","text":"Parameter Type Description <code>node</code> <code>JSONMappable</code> <code>path</code> <code>string</code>"},{"location":"reference/#returns_11","title":"Returns","text":"<p><code>JSONValue</code></p>"},{"location":"reference/#defined-in_14","title":"Defined in","text":"<p>lib/utils/immutability.ts:22</p> <p></p>"},{"location":"reference/#urltopagekey","title":"urlToPageKey()","text":"<p>urlToPageKey(<code>url</code>: <code>string</code>): <code>PageKey</code></p> <p>Converts a url to a PageKey.</p>"},{"location":"reference/#parameters_12","title":"Parameters","text":"Parameter Type Description <code>url</code> <code>string</code>"},{"location":"reference/#returns_12","title":"Returns","text":"<p><code>PageKey</code></p>"},{"location":"reference/#defined-in_15","title":"Defined in","text":"<p>lib/utils/url.ts:64</p>"},{"location":"reference/components.Navigation/","title":"Navigation","text":""},{"location":"reference/components.Navigation/#functions","title":"Functions","text":""},{"location":"reference/components.Navigation/#navigationcontext","title":"NavigationContext()","text":"<p>NavigationContext(<code>props</code>: <code>ProviderProps</code>\\&lt;<code>NavigationContextProps</code>&gt;): <code>ReactNode</code></p>"},{"location":"reference/components.Navigation/#parameters","title":"Parameters","text":"Parameter Type <code>props</code> <code>ProviderProps</code>\\&lt;<code>NavigationContextProps</code>&gt;"},{"location":"reference/components.Navigation/#returns","title":"Returns","text":"<p><code>ReactNode</code></p>"},{"location":"reference/components.Navigation/#defined-in","title":"Defined in","text":"<p>lib/components/Navigation.tsx:23</p> <p></p>"},{"location":"reference/components.Navigation/#navigationprovider","title":"NavigationProvider()","text":"<p>NavigationProvider(<code>props</code>: <code>NavigationProviderProps</code> &amp; <code>RefAttributes</code>\\&lt;{<code>navigateTo</code>: <code>null</code> | <code>NavigateTo</code>; }&gt;): <code>ReactNode</code></p>"},{"location":"reference/components.Navigation/#parameters_1","title":"Parameters","text":"Parameter Type <code>props</code> <code>NavigationProviderProps</code> &amp; <code>RefAttributes</code>\\&lt;{<code>navigateTo</code>: <code>null</code> | <code>NavigateTo</code>; }&gt;"},{"location":"reference/components.Navigation/#returns_1","title":"Returns","text":"<p><code>ReactNode</code></p>"},{"location":"reference/components.Navigation/#defined-in_1","title":"Defined in","text":"<p>lib/components/Navigation.tsx:47</p>"},{"location":"reference/hooks/","title":"Hooks","text":""},{"location":"reference/hooks/#functions","title":"Functions","text":""},{"location":"reference/hooks/#usesuperglue","title":"useSuperglue()","text":"<p>useSuperglue(): <code>SuperglueState</code></p> <p>A lightweight hook that grabs the superglue state from the store.</p>"},{"location":"reference/hooks/#returns","title":"Returns","text":"<p><code>SuperglueState</code></p>"},{"location":"reference/hooks/#defined-in","title":"Defined in","text":"<p>lib/hooks/index.ts:7</p> <p></p>"},{"location":"reference/hooks/#usecontent","title":"useContent()","text":"<p>useContent\\&lt;<code>T</code>&gt;(): <code>T</code></p> <p>A lightweight hook that grabs the current page's content from the store.</p>"},{"location":"reference/hooks/#type-parameters","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/hooks/#returns_1","title":"Returns","text":"<p><code>T</code></p>"},{"location":"reference/hooks/#defined-in_1","title":"Defined in","text":"<p>lib/hooks/index.ts:14</p>"},{"location":"reference/types.actions/","title":"Actions","text":""},{"location":"reference/types.actions/#interfaces","title":"Interfaces","text":""},{"location":"reference/types.actions/#graftingsuccessaction","title":"GraftingSuccessAction","text":""},{"location":"reference/types.actions/#extends","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types.actions/#properties","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>string</code> <code>Action.type</code> lib/types/actions.ts:12 <code>payload</code> {<code>pageKey</code>: <code>string</code>;<code>keyPath</code>: <code>string</code>; } - lib/types/actions.ts:13 <code>payload.pageKey</code> <code>string</code> - lib/types/actions.ts:14 <code>payload.keyPath</code> <code>string</code> - lib/types/actions.ts:15"},{"location":"reference/types.actions/#graftingerroraction","title":"GraftingErrorAction","text":""},{"location":"reference/types.actions/#extends_1","title":"Extends","text":"<ul> <li><code>Action</code></li> </ul>"},{"location":"reference/types.actions/#properties_1","title":"Properties","text":"Property Type Overrides Defined in <code>type</code> <code>string</code> <code>Action.type</code> lib/types/actions.ts:20 <code>payload</code> {<code>pageKey</code>: <code>string</code>;<code>url</code>: <code>string</code>;<code>err</code>: <code>unknown</code>;<code>keyPath</code>: <code>string</code>; } - lib/types/actions.ts:21 <code>payload.pageKey</code> <code>string</code> - lib/types/actions.ts:22 <code>payload.url</code> <code>string</code> - lib/types/actions.ts:23 <code>payload.err</code> <code>unknown</code> - lib/types/actions.ts:24 <code>payload.keyPath</code> <code>string</code> - lib/types/actions.ts:25"},{"location":"reference/types.actions/#type-aliases","title":"Type Aliases","text":""},{"location":"reference/types.actions/#fetchargs","title":"FetchArgs","text":"<p>FetchArgs: [<code>string</code>, <code>BasicRequestInit</code>]</p> <p>Tuple of Fetch arguments that Superglue passes to Fetch.</p>"},{"location":"reference/types.actions/#defined-in","title":"Defined in","text":"<p>lib/types/actions.ts:7</p>"},{"location":"reference/types/","title":"Types","text":""},{"location":"reference/types/#references","title":"References","text":""},{"location":"reference/types/#fetchargs","title":"FetchArgs","text":"<p>Re-exports FetchArgs</p> <p></p>"},{"location":"reference/types/#graftingsuccessaction","title":"GraftingSuccessAction","text":"<p>Re-exports GraftingSuccessAction</p> <p></p>"},{"location":"reference/types/#graftingerroraction","title":"GraftingErrorAction","text":"<p>Re-exports GraftingErrorAction</p> <p></p>"},{"location":"reference/types/#visit","title":"Visit","text":"<p>Re-exports Visit</p> <p></p>"},{"location":"reference/types/#visitprops","title":"VisitProps","text":"<p>Re-exports VisitProps</p> <p></p>"},{"location":"reference/types/#remote","title":"Remote","text":"<p>Re-exports Remote</p> <p></p>"},{"location":"reference/types/#remoteprops","title":"RemoteProps","text":"<p>Re-exports RemoteProps</p> <p></p>"},{"location":"reference/types/#beforesave","title":"BeforeSave","text":"<p>Re-exports BeforeSave</p> <p></p>"},{"location":"reference/types/#applicationremote","title":"ApplicationRemote","text":"<p>Re-exports ApplicationRemote</p> <p></p>"},{"location":"reference/types/#applicationvisit","title":"ApplicationVisit","text":"<p>Re-exports ApplicationVisit</p>"},{"location":"reference/types/#interfaces","title":"Interfaces","text":""},{"location":"reference/types/#parsedresponse","title":"ParsedResponse","text":""},{"location":"reference/types/#properties","title":"Properties","text":"Property Type Defined in <code>rsp</code> <code>Response</code> lib/types/index.ts:111 <code>json</code> <code>PageResponse</code> lib/types/index.ts:112"},{"location":"reference/types/#defer","title":"Defer","text":"<p>Defer is a node in the page response thats been intentionally filled with empty or placeholder data for the purposes of fetching it later.</p> <p>You would typically use it with props_template for parts of a page that you know would be slower to load.</p>"},{"location":"reference/types/#properties_1","title":"Properties","text":"Property Type Description Defined in <code>url</code> <code>string</code> A url with props_at keypath in the query parameter to indicate how to dig for the data, and where to place the data. lib/types/index.ts:137 <code>type</code> <code>\"auto\"</code> | <code>\"manual\"</code> When set to <code>auto</code> Superglue will automatically make the request using the <code>url</code>. When set to <code>manual</code>, Superglue does nothing, and you would need to manually use <code>remote</code> with the <code>url</code> to fetch the missing data. lib/types/index.ts:138 <code>path</code> <code>string</code> A keypath indicates how to dig for the data and where to place the data. lib/types/index.ts:139 <code>successAction</code> <code>string</code> a user defined action for Superglue to dispatch when auto deferement is successful lib/types/index.ts:140 <code>failAction</code> <code>string</code> a user defined action for Superglue to dispatch when auto deferement failed lib/types/index.ts:141"},{"location":"reference/types/#graftresponset","title":"GraftResponse\\&lt;T&gt;","text":"<p>The GraftResponse is a protocol, a shape that is responsible for partial updates using props_template's digging functionality in Superglue. Its meant to be implemented by the server and if you are using superglue_rails, the generators would have generated a props_template layout and view that would shape the graft responses for you.</p>"},{"location":"reference/types/#type-parameters","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#properties_2","title":"Properties","text":"Property Type Description Defined in <code>data</code> <code>T</code> - lib/types/index.ts:151 <code>componentIdentifier</code> <code>string</code> - lib/types/index.ts:152 <code>assets</code> <code>string</code>[] - lib/types/index.ts:153 <code>csrfToken?</code> <code>string</code> - lib/types/index.ts:154 <code>fragments</code> <code>Fragment</code>[] - lib/types/index.ts:155 <code>defers</code> <code>Defer</code>[] - lib/types/index.ts:156 <code>slices</code> <code>JSONObject</code> - lib/types/index.ts:157 <code>renderedAt</code> <code>number</code> - lib/types/index.ts:159 <code>restoreStrategy</code> <code>RestoreStrategy</code> - lib/types/index.ts:160 <code>action</code> <code>\"graft\"</code> - lib/types/index.ts:182 <code>path</code> <code>string</code> Used by superglue to replace the data at that location. lib/types/index.ts:183"},{"location":"reference/types/#fragment","title":"Fragment","text":"<p>A Fragment identifies a cross cutting concern, like a shared header or footer.</p>"},{"location":"reference/types/#properties_3","title":"Properties","text":"Property Type Description Defined in <code>type</code> <code>string</code> A user supplied string identifying a fragment. This is usually created using props_template lib/types/index.ts:201 <code>path</code> <code>string</code> A Keypath specifying the location of the fragment lib/types/index.ts:202"},{"location":"reference/types/#supergluestate","title":"SuperglueState","text":"<p>A read only state that contains meta information about the current page.</p>"},{"location":"reference/types/#properties_4","title":"Properties","text":"Property Type Description Defined in <code>currentPageKey</code> <code>string</code> The PageKey (url pathname + search) of the current page. This can be pass to Remote. lib/types/index.ts:217 <code>search</code> <code>Record</code>\\&lt;<code>string</code>, <code>undefined</code> | <code>string</code>&gt; The query string object of the current url. lib/types/index.ts:219 <code>csrfToken?</code> <code>string</code> The Rails csrfToken that you can use for forms. lib/types/index.ts:221 <code>assets</code> <code>string</code>[] The tracked asset digests. lib/types/index.ts:223"},{"location":"reference/types/#rootstatet","title":"RootState\\&lt;T&gt;","text":"<p>The root state for a Superglue application. It occupies 2 keys in your app.</p>"},{"location":"reference/types/#type-parameters_1","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#indexable","title":"Indexable","text":"<p>[<code>name</code>: <code>string</code>]: <code>unknown</code></p>"},{"location":"reference/types/#properties_5","title":"Properties","text":"Property Type Description Defined in <code>superglue</code> <code>SuperglueState</code> Contains readonly metadata about the current page lib/types/index.ts:232 <code>pages</code> <code>AllPages</code>\\&lt;<code>T</code>&gt; Every PageResponse that superglue recieves is stored here. lib/types/index.ts:234"},{"location":"reference/types/#meta","title":"Meta","text":"<p>Meta is passed to the Promise when visit or remote resolves and contains additional information for navigation.</p>"},{"location":"reference/types/#extended-by","title":"Extended by","text":"<ul> <li><code>VisitMeta</code></li> </ul>"},{"location":"reference/types/#properties_6","title":"Properties","text":"Property Type Description Defined in <code>pageKey</code> <code>string</code> The URL of the response converted to a pageKey. Superglue uses this to persist the VisitResponse to store, when that happens. lib/types/index.ts:248 <code>page</code> <code>VisitResponse</code>\\&lt;<code>JSONMappable</code>&gt; The VisitResponse of the page lib/types/index.ts:250 <code>redirected</code> <code>boolean</code> Indicates if response was redirected lib/types/index.ts:252 <code>rsp</code> <code>Response</code> The original response object lib/types/index.ts:254 <code>fetchArgs</code> <code>FetchArgs</code> The original args passed to fetch. lib/types/index.ts:256 <code>componentIdentifier</code> <code>string</code> The ComponentIdentifier extracted from the response. lib/types/index.ts:258 <code>needsRefresh</code> <code>boolean</code> <code>true</code> when assets locally are detected to be out of date lib/types/index.ts:260"},{"location":"reference/types/#visitmeta","title":"VisitMeta","text":"<p>Meta is passed to the Promise when visit or remote resolves and contains additional information for navigation.</p>"},{"location":"reference/types/#extends","title":"Extends","text":"<ul> <li><code>Meta</code></li> </ul>"},{"location":"reference/types/#properties_7","title":"Properties","text":"Property Type Description Inherited from Defined in <code>pageKey</code> <code>string</code> The URL of the response converted to a pageKey. Superglue uses this to persist the VisitResponse to store, when that happens. <code>Meta</code>.<code>pageKey</code> lib/types/index.ts:248 <code>page</code> <code>VisitResponse</code>\\&lt;<code>JSONMappable</code>&gt; The VisitResponse of the page <code>Meta</code>.<code>page</code> lib/types/index.ts:250 <code>redirected</code> <code>boolean</code> Indicates if response was redirected <code>Meta</code>.<code>redirected</code> lib/types/index.ts:252 <code>rsp</code> <code>Response</code> The original response object <code>Meta</code>.<code>rsp</code> lib/types/index.ts:254 <code>fetchArgs</code> <code>FetchArgs</code> The original args passed to fetch. <code>Meta</code>.<code>fetchArgs</code> lib/types/index.ts:256 <code>componentIdentifier</code> <code>string</code> The ComponentIdentifier extracted from the response. <code>Meta</code>.<code>componentIdentifier</code> lib/types/index.ts:258 <code>needsRefresh</code> <code>boolean</code> <code>true</code> when assets locally are detected to be out of date <code>Meta</code>.<code>needsRefresh</code> lib/types/index.ts:260 <code>navigationAction</code> <code>NavigationAction</code> The NavigationAction. This can be used for navigation. - lib/types/index.ts:265"},{"location":"reference/types/#handlers","title":"Handlers","text":""},{"location":"reference/types/#properties_8","title":"Properties","text":"Property Type Defined in <code>onClick</code> (<code>event</code>: <code>MouseEvent</code>\\&lt;<code>HTMLDivElement</code>, <code>MouseEvent</code>&gt;) =&gt; <code>void</code> lib/types/index.ts:309 <code>onSubmit</code> (<code>event</code>: <code>FormEvent</code>\\&lt;<code>HTMLDivElement</code>&gt;) =&gt; <code>void</code> lib/types/index.ts:310"},{"location":"reference/types/#historystate","title":"HistoryState","text":"<p>The state that is saved to history.state. Superglue stores information about the current page so that it can restore the page state when navigating back</p>"},{"location":"reference/types/#properties_9","title":"Properties","text":"Property Type Description Defined in <code>superglue</code> <code>true</code> Is always <code>true</code> so superglue can differentiate pages that have superglue enabled or not lib/types/index.ts:332 <code>pageKey</code> <code>string</code> The page key in SuperglueState to restore from lib/types/index.ts:334 <code>posX</code> <code>number</code> The scroll position X of the page lib/types/index.ts:336 <code>posY</code> <code>number</code> The scroll position Y of the page lib/types/index.ts:338"},{"location":"reference/types/#basicrequestinit","title":"BasicRequestInit","text":"<p>A variation of RequestInit except the headers must be a regular object</p>"},{"location":"reference/types/#extends_1","title":"Extends","text":"<ul> <li><code>RequestInit</code></li> </ul>"},{"location":"reference/types/#properties_10","title":"Properties","text":"Property Type Description Overrides Defined in <code>headers?</code> {} A Headers object, an object literal, or an array of two-item arrays to set request's headers. <code>RequestInit.headers</code> lib/types/index.ts:365"},{"location":"reference/types/#navigationcontextprops","title":"NavigationContextProps","text":"<p>Superglue comes with a Navigation component that provides a context with access to Visit, Remote and other useful tooling.</p> <p>You can also use this to build your own <code>&lt;Link&gt;</code> component.</p>"},{"location":"reference/types/#properties_11","title":"Properties","text":"Property Type Description Defined in <code>navigateTo</code> <code>NavigateTo</code> - lib/types/index.ts:414 <code>visit</code> <code>ApplicationVisit</code> - lib/types/index.ts:415 <code>remote</code> <code>ApplicationRemote</code> - lib/types/index.ts:416 <code>pageKey</code> <code>string</code> The pagekey that's being used to render the current page component. Useful when used in combination with Remote to create requests that target the current page. lib/types/index.ts:417 <code>search</code> <code>Record</code>\\&lt;<code>string</code>, <code>undefined</code> | <code>string</code>&gt; The current pageKey (current url) query params as an object. lib/types/index.ts:418"},{"location":"reference/types/#navigationproviderprops","title":"NavigationProviderProps","text":"<p>This is the navigation component that gets used by ApplicationProps. The component takes a mapping of page components and swaps them when navigating and passes NavigateTo to all page components.</p>"},{"location":"reference/types/#properties_12","title":"Properties","text":"Property Type Description Defined in <code>history</code> <code>History</code> - lib/types/index.ts:431 <code>visit</code> <code>ApplicationVisit</code> - lib/types/index.ts:432 <code>remote</code> <code>ApplicationRemote</code> - lib/types/index.ts:433 <code>mapping</code> <code>Record</code>\\&lt;<code>string</code>, <code>ComponentType</code>\\&lt;{}&gt;&gt; - lib/types/index.ts:434 <code>initialPageKey</code> <code>string</code> The PageKey that's to be used when first rendering. Used to determine the initial page component to show. lib/types/index.ts:435"},{"location":"reference/types/#buildstore","title":"BuildStore()","text":"<p>Provide this callback to ApplicationProps returning a Redux store for Superglue to use. This would be setup and generated for you in <code>store.js</code>. We recommend using using Redux toolkit's <code>configureStore</code> to build the store.</p> <p>BuildStore(<code>initialState</code>: <code>RootState</code>\\&lt;<code>JSONMappable</code>&gt;, <code>reducer</code>: {<code>superglue</code>: <code>superglueReducer</code>;<code>pages</code>: <code>pageReducer</code>; }): <code>SuperglueStore</code></p> <p>Provide this callback to ApplicationProps returning a Redux store for Superglue to use. This would be setup and generated for you in <code>store.js</code>. We recommend using using Redux toolkit's <code>configureStore</code> to build the store.</p>"},{"location":"reference/types/#parameters","title":"Parameters","text":"Parameter Type Description <code>initialState</code> <code>RootState</code>\\&lt;<code>JSONMappable</code>&gt; A preconfigured intial state to pass to your store. <code>reducer</code> <code>object</code> A preconfigured reducer <code>reducer.superglue</code> (<code>state</code>: <code>SuperglueState</code>, <code>action</code>: <code>Action</code>) =&gt; <code>SuperglueState</code> - <code>reducer.pages</code> (<code>state</code>: <code>AllPages</code>, <code>action</code>: <code>Action</code>) =&gt; <code>AllPages</code> -"},{"location":"reference/types/#returns","title":"Returns","text":"<p><code>SuperglueStore</code></p>"},{"location":"reference/types/#defined-in","title":"Defined in","text":"<p>lib/types/index.ts:447</p> <p></p>"},{"location":"reference/types/#buildvisitandremote","title":"BuildVisitAndRemote()","text":"<p>Provide this callback to ApplicationProps returning a visit and remote function. These functions will be used by Superglue to power its UJS attributes and passed to your page components and NavigationContextProps. You may customize this functionality to your liking, e.g, adding a progress bar.</p> <p>BuildVisitAndRemote(<code>navigatorRef</code>: <code>RefObject</code>\\&lt;<code>null</code> | {<code>navigateTo</code>: <code>NavigateTo</code>; }&gt;, <code>store</code>: <code>SuperglueStore</code>): {<code>visit</code>: <code>ApplicationVisit</code>;<code>remote</code>: <code>ApplicationRemote</code>; }</p> <p>Provide this callback to ApplicationProps returning a visit and remote function. These functions will be used by Superglue to power its UJS attributes and passed to your page components and NavigationContextProps. You may customize this functionality to your liking, e.g, adding a progress bar.</p>"},{"location":"reference/types/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>navigatorRef</code> <code>RefObject</code>\\&lt;<code>null</code> | {<code>navigateTo</code>: <code>NavigateTo</code>; }&gt; <code>store</code> <code>SuperglueStore</code>"},{"location":"reference/types/#returns_1","title":"Returns","text":"<p>{<code>visit</code>: <code>ApplicationVisit</code>;<code>remote</code>: <code>ApplicationRemote</code>; }</p> Name Type Defined in <code>visit</code> <code>ApplicationVisit</code> lib/types/index.ts:467 <code>remote</code> <code>ApplicationRemote</code> lib/types/index.ts:468"},{"location":"reference/types/#defined-in_1","title":"Defined in","text":"<p>lib/types/index.ts:463</p> <p></p>"},{"location":"reference/types/#setupprops","title":"SetupProps","text":""},{"location":"reference/types/#properties_13","title":"Properties","text":"Property Type Description Defined in <code>initialPage</code> <code>VisitResponse</code>\\&lt;<code>JSONMappable</code>&gt; The global var SUPERGLUE_INITIAL_PAGE_STATE is set by your erb template, e.g., index.html.erb lib/types/index.ts:477 <code>baseUrl</code> <code>string</code> The base url prefixed to all calls made by <code>visit</code> and <code>remote</code>. lib/types/index.ts:482 <code>path</code> <code>string</code> The path of the current page. It should equal to the <code>location.pathname</code> + <code>location.search</code> + <code>location.hash</code> lib/types/index.ts:487 <code>store</code> <code>SuperglueStore</code> The exported store from store.js. If you used the generators it would contain slices for superglue, pages, and the flash. lib/types/index.ts:492 <code>buildVisitAndRemote</code> <code>BuildVisitAndRemote</code> A factory function that will return a <code>visit</code> and <code>remote</code> function. All of Superglue and UJS will use these functions. You should customize the function, for example, to add a progress bar. lib/types/index.ts:499 <code>history?</code> <code>History</code> An optional history object https://github.com/remix-run/history. If none is provided Superglue will create one for you. lib/types/index.ts:504 <code>navigatorRef</code> <code>RefObject</code>\\&lt;<code>null</code> | {<code>navigateTo</code>: <code>NavigateTo</code>; }&gt; A ref object created from the Application component that will be passed to buildVisitAndRemote lib/types/index.ts:508"},{"location":"reference/types/#applicationprops","title":"ApplicationProps","text":"<p>Props for the <code>Application</code> component</p>"},{"location":"reference/types/#extends_2","title":"Extends","text":"<ul> <li><code>ComponentPropsWithoutRef</code>\\&lt;<code>\"div\"</code>&gt;</li> </ul>"},{"location":"reference/types/#properties_14","title":"Properties","text":"Property Type Description Defined in <code>initialPage</code> <code>VisitResponse</code>\\&lt;<code>JSONMappable</code>&gt; The global var SUPERGLUE_INITIAL_PAGE_STATE is set by your erb template, e.g., index.html.erb lib/types/index.ts:522 <code>baseUrl</code> <code>string</code> The base url prefixed to all calls made by <code>visit</code> and <code>remote</code>. lib/types/index.ts:527 <code>path</code> <code>string</code> The path of the current page. It should equal to the <code>location.pathname</code> + <code>location.search</code> + <code>location.hash</code> lib/types/index.ts:532 <code>buildVisitAndRemote</code> <code>BuildVisitAndRemote</code> A factory function that will return a <code>visit</code> and <code>remote</code> function. All of Superglue and UJS will use these functions. You should customize the function, for example, to add a progress bar. lib/types/index.ts:539 <code>mapping</code> <code>Record</code>\\&lt;<code>string</code>, <code>ComponentType</code>\\&lt;{}&gt;&gt; A mapping between your page props and page component. This is setup for you in page_to_page_mapping. lib/types/index.ts:544 <code>history?</code> <code>History</code> An optional history object https://github.com/remix-run/history. If none is provided Superglue will create one for you. lib/types/index.ts:549 <code>store</code> <code>SuperglueStore</code> The exported store from store.js. If you used the generators it would contain slices for superglue, pages, and the flash. lib/types/index.ts:554"},{"location":"reference/types/#type-aliases","title":"Type Aliases","text":""},{"location":"reference/types/#pagekey","title":"PageKey","text":"<p>PageKey: <code>string</code></p> <p>A PageKey is a combination of a parsed URL's pathname + query string. No hash.</p> <p>*</p>"},{"location":"reference/types/#example","title":"Example","text":"<pre><code>/posts?foobar=123\n</code></pre>"},{"location":"reference/types/#defined-in_2","title":"Defined in","text":"<p>lib/types/index.ts:22</p> <p></p>"},{"location":"reference/types/#restorestrategy","title":"RestoreStrategy","text":"<p>RestoreStrategy: <code>\"fromCacheOnly\"</code> | <code>\"revisitOnly\"</code> | <code>\"fromCacheAndRevisitInBackground\"</code></p> <p>Defines the behavior when navigating to a page that is already stored on the client. For example, when navigating back.</p> <p>When the page already exists in the store: - <code>fromCacheOnly</code> - Use the cached page that exists on the store, only. - <code>revisitOnly</code> - Ignore the cache and make a request for the latest page. If the response was 200, the NavigationAction would be <code>none</code> as we don't want to push into history. If the response was redirected, the NavigationAction would be set to <code>replace</code>. - <code>fromCacheAndRevisitInBackground</code> - Use the cache version of the page so    superglue can optimistically navigate to it, then make an additional request    for the latest version.</p>"},{"location":"reference/types/#defined-in_3","title":"Defined in","text":"<p>lib/types/index.ts:38</p> <p></p>"},{"location":"reference/types/#navigationaction","title":"NavigationAction","text":"<p>NavigationAction: <code>\"push\"</code> | <code>\"replace\"</code> | <code>\"none\"</code></p> <p>A NavigationAction is used to tell Superglue to history.push, history.replace or do nothing.</p>"},{"location":"reference/types/#defined-in_4","title":"Defined in","text":"<p>lib/types/index.ts:47</p> <p></p>"},{"location":"reference/types/#componentidentifier","title":"ComponentIdentifier","text":"<p>ComponentIdentifier: <code>string</code></p> <p>An identifier that Superglue will uses to determine which page component to render with your page response.</p>"},{"location":"reference/types/#defined-in_5","title":"Defined in","text":"<p>lib/types/index.ts:53</p> <p></p>"},{"location":"reference/types/#keypath","title":"Keypath","text":"<p>Keypath: <code>string</code></p> <p>A keypath is a string representing the location of a piece of data. Superglue uses the keypath to dig for or update data.</p>"},{"location":"reference/types/#examples","title":"Examples","text":"<p>Object access <pre><code>data.header.avatar\n</code></pre></p> <p>Array access <pre><code>data.body.posts.0.title\n</code></pre></p> <p>Array with lookahead <pre><code>data.body.posts.post_id=foobar.title\n</code></pre></p>"},{"location":"reference/types/#defined-in_6","title":"Defined in","text":"<p>lib/types/index.ts:77</p> <p></p>"},{"location":"reference/types/#jsonprimitive","title":"JSONPrimitive","text":"<p>JSONPrimitive: <code>string</code> | <code>number</code> | <code>boolean</code> | <code>null</code> | <code>undefined</code></p> <p>A JSON Primitive value</p>"},{"location":"reference/types/#defined-in_7","title":"Defined in","text":"<p>lib/types/index.ts:84</p> <p></p>"},{"location":"reference/types/#jsonobject","title":"JSONObject","text":"<p>JSONObject: {}</p> <p>A JSON Object</p>"},{"location":"reference/types/#index-signature","title":"Index Signature","text":"<p>[<code>key</code>: <code>string</code>]: <code>JSONValue</code></p>"},{"location":"reference/types/#defined-in_8","title":"Defined in","text":"<p>lib/types/index.ts:89</p> <p></p>"},{"location":"reference/types/#jsonmappable","title":"JSONMappable","text":"<p>JSONMappable: <code>JSONValue</code>[] | <code>JSONObject</code></p> <p>A JSON Object or an array of values</p>"},{"location":"reference/types/#defined-in_9","title":"Defined in","text":"<p>lib/types/index.ts:96</p> <p></p>"},{"location":"reference/types/#jsonkeyable","title":"JSONKeyable","text":"<p>JSONKeyable: <code>JSONObject</code>[] | <code>JSONObject</code></p> <p>A array of JSON key value objects or a JSON Object</p>"},{"location":"reference/types/#defined-in_10","title":"Defined in","text":"<p>lib/types/index.ts:101</p> <p></p>"},{"location":"reference/types/#jsonvalue","title":"JSONValue","text":"<p>JSONValue: <code>JSONPrimitive</code> | <code>JSONMappable</code></p> <p>A primitive or a mappable object</p>"},{"location":"reference/types/#defined-in_11","title":"Defined in","text":"<p>lib/types/index.ts:106</p> <p></p>"},{"location":"reference/types/#visitresponset","title":"VisitResponse\\&lt;T&gt;","text":"<p>VisitResponse\\&lt;<code>T</code>&gt;: {<code>data</code>: <code>T</code>;<code>componentIdentifier</code>: <code>ComponentIdentifier</code>;<code>assets</code>: <code>string</code>[];<code>csrfToken</code>: <code>string</code>;<code>fragments</code>: <code>Fragment</code>[];<code>defers</code>: <code>Defer</code>[];<code>slices</code>: <code>JSONObject</code>;<code>renderedAt</code>: <code>number</code>;<code>restoreStrategy</code>: <code>RestoreStrategy</code>; }</p> <p>The VisitResponse is a protocol, a shape that is responsible for full page visits in Superglue. Its meant to be implemented by the server and if you are using superglue_rails, the generators would have generated a props_template layout and view that would shape the visit responses for you.</p>"},{"location":"reference/types/#type-parameters_2","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#type-declaration","title":"Type declaration","text":"Name Type Defined in <code>data</code> <code>T</code> lib/types/index.ts:151 <code>componentIdentifier</code> <code>ComponentIdentifier</code> lib/types/index.ts:152 <code>assets</code> <code>string</code>[] lib/types/index.ts:153 <code>csrfToken</code>? <code>string</code> lib/types/index.ts:154 <code>fragments</code> <code>Fragment</code>[] lib/types/index.ts:155 <code>defers</code> <code>Defer</code>[] lib/types/index.ts:156 <code>slices</code> <code>JSONObject</code> lib/types/index.ts:157 <code>renderedAt</code> <code>number</code> lib/types/index.ts:159 <code>restoreStrategy</code> <code>RestoreStrategy</code> lib/types/index.ts:160"},{"location":"reference/types/#defined-in_12","title":"Defined in","text":"<p>lib/types/index.ts:150</p> <p></p>"},{"location":"reference/types/#paget","title":"Page\\&lt;T&gt;","text":"<p>Page\\&lt;<code>T</code>&gt;: <code>VisitResponse</code>\\&lt;<code>T</code>&gt; &amp; {<code>savedAt</code>: <code>number</code>; }</p> <p>A Page is a VisitResponse that's been saved to the store</p>"},{"location":"reference/types/#type-declaration_1","title":"Type declaration","text":"Name Type Defined in <code>savedAt</code> <code>number</code> lib/types/index.ts:167"},{"location":"reference/types/#type-parameters_3","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#defined-in_13","title":"Defined in","text":"<p>lib/types/index.ts:166</p> <p></p>"},{"location":"reference/types/#pageresponse","title":"PageResponse","text":"<p>PageResponse: <code>GraftResponse</code> | <code>VisitResponse</code></p> <p>A PageResponse can be either a GraftResponse or a VisitResponse. Its meant to be implemented by the server and if you are using superglue_rails, the generators will handle both cases.</p>"},{"location":"reference/types/#defined-in_14","title":"Defined in","text":"<p>lib/types/index.ts:191</p> <p></p>"},{"location":"reference/types/#allpagest","title":"AllPages\\&lt;T&gt;","text":"<p>AllPages\\&lt;<code>T</code>&gt;: <code>Record</code>\\&lt;<code>PageKey</code>, <code>Page</code>\\&lt;<code>T</code>&gt;&gt;</p> <p>The store where all page responses are stored indexed by PageKey. You are encouraged to mutate the Pages in this store.</p>"},{"location":"reference/types/#type-parameters_4","title":"Type Parameters","text":"Type Parameter Default type <code>T</code> <code>JSONMappable</code>"},{"location":"reference/types/#defined-in_15","title":"Defined in","text":"<p>lib/types/index.ts:209</p> <p></p>"},{"location":"reference/types/#visitcreator","title":"VisitCreator()","text":"<p>VisitCreator: (<code>input</code>: <code>string</code> | <code>PageKey</code>, <code>options</code>: <code>VisitProps</code>) =&gt; <code>VisitMetaThunk</code></p> <p>VisitCreator is a Redux action creator that returns a thunk. Use this to build the Visit function. Typically its already generated in <code>application_visit.js</code></p>"},{"location":"reference/types/#parameters_2","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> | <code>PageKey</code> <code>options</code> <code>VisitProps</code>"},{"location":"reference/types/#returns_2","title":"Returns","text":"<p><code>VisitMetaThunk</code></p>"},{"location":"reference/types/#defined-in_16","title":"Defined in","text":"<p>lib/types/index.ts:274</p> <p></p>"},{"location":"reference/types/#remotecreator","title":"RemoteCreator()","text":"<p>RemoteCreator: (<code>input</code>: <code>string</code> | <code>PageKey</code>, <code>options</code>: <code>RemoteProps</code>) =&gt; <code>MetaThunk</code></p> <p>RemoteCreator is a Redux action creator that returns a thunk. Use this to build the Remote function. Typically its already generated in <code>application_visit.js</code></p>"},{"location":"reference/types/#parameters_3","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> | <code>PageKey</code> <code>options</code> <code>RemoteProps</code>"},{"location":"reference/types/#returns_3","title":"Returns","text":"<p><code>MetaThunk</code></p>"},{"location":"reference/types/#defined-in_17","title":"Defined in","text":"<p>lib/types/index.ts:283</p> <p></p>"},{"location":"reference/types/#dispatch","title":"Dispatch","text":"<p>Dispatch: <code>ThunkDispatch</code>\\&lt;<code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p>"},{"location":"reference/types/#defined-in_18","title":"Defined in","text":"<p>lib/types/index.ts:288</p> <p></p>"},{"location":"reference/types/#supergluestore","title":"SuperglueStore","text":"<p>SuperglueStore: <code>EnhancedStore</code>\\&lt;<code>RootState</code>, <code>Action</code>, <code>Tuple</code>\\&lt;[<code>StoreEnhancer</code>\\&lt;{<code>dispatch</code>: <code>Dispatch</code>; }&gt;, <code>StoreEnhancer</code>]&gt;&gt;</p> <p>A Store created with Redux Toolkit's <code>configureStore</code> setup with reducers from Superglue. If you are using superglue_rails this would have been generated for you in <code>store.js</code> and setup correctly in application.js</p>"},{"location":"reference/types/#defined-in_19","title":"Defined in","text":"<p>lib/types/index.ts:295</p> <p></p>"},{"location":"reference/types/#ujshandlers","title":"UJSHandlers()","text":"<p>UJSHandlers: (<code>{   ujsAttributePrefix,   visit,   remote,   store, }</code>: {<code>ujsAttributePrefix</code>: <code>string</code>;<code>visit</code>: <code>ApplicationVisit</code>;<code>remote</code>: <code>ApplicationRemote</code>;<code>store</code>: <code>SuperglueStore</code>; }) =&gt; <code>Handlers</code></p>"},{"location":"reference/types/#parameters_4","title":"Parameters","text":"Parameter Type <code>{ ujsAttributePrefix, visit, remote, store, }</code> <code>object</code> <code>{ ujsAttributePrefix, visit, remote, store, }.ujsAttributePrefix</code> <code>string</code> <code>{ ujsAttributePrefix, visit, remote, store, }.visit</code> <code>ApplicationVisit</code> <code>{ ujsAttributePrefix, visit, remote, store, }.remote</code> <code>ApplicationRemote</code> <code>{ ujsAttributePrefix, visit, remote, store, }.store</code> <code>SuperglueStore</code>"},{"location":"reference/types/#returns_4","title":"Returns","text":"<p><code>Handlers</code></p>"},{"location":"reference/types/#defined-in_20","title":"Defined in","text":"<p>lib/types/index.ts:313</p> <p></p>"},{"location":"reference/types/#saveandprocesspagethunk","title":"SaveAndProcessPageThunk","text":"<p>SaveAndProcessPageThunk: <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>void</code>&gt;, <code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p>"},{"location":"reference/types/#defined-in_21","title":"Defined in","text":"<p>lib/types/index.ts:341</p> <p></p>"},{"location":"reference/types/#metathunk","title":"MetaThunk","text":"<p>MetaThunk: <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>Meta</code>&gt;, <code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p>"},{"location":"reference/types/#defined-in_22","title":"Defined in","text":"<p>lib/types/index.ts:348</p> <p></p>"},{"location":"reference/types/#visitmetathunk","title":"VisitMetaThunk","text":"<p>VisitMetaThunk: <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>VisitMeta</code>&gt;, <code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p>"},{"location":"reference/types/#defined-in_23","title":"Defined in","text":"<p>lib/types/index.ts:349</p> <p></p>"},{"location":"reference/types/#defermentthunk","title":"DefermentThunk","text":"<p>DefermentThunk: <code>ThunkAction</code>\\&lt;<code>Promise</code>\\&lt;<code>void</code>[]&gt;, <code>RootState</code>, <code>undefined</code>, <code>Action</code>&gt;</p>"},{"location":"reference/types/#defined-in_24","title":"Defined in","text":"<p>lib/types/index.ts:356</p> <p></p>"},{"location":"reference/types/#navigateto","title":"NavigateTo()","text":"<p>NavigateTo: (<code>path</code>: <code>Keypath</code>, <code>options</code>: {<code>action</code>: <code>NavigationAction</code>; }) =&gt; <code>boolean</code></p> <p>Passed to every page component and also available as part of a NavigationContext:</p> <pre><code>import { NavigationContext } from '@thoughtbot/superglue';\n\nconst { navigateTo } = useContext(NavigationContext)\n</code></pre> <p>Manually navigate using pages that exists in the store and restores scroll position. <code>navigateTo</code> is what Visit in your <code>application_visit.js</code> ultimately calls.</p> <p>If there is an existing page in your store <code>navigateTo</code> will restore the props, render the correct component, and return <code>true</code>. Otherwise, it will return <code>false</code>. This is useful if you want to restore an existing page before making a call to <code>visit</code> or <code>remote</code>.</p>"},{"location":"reference/types/#parameters_5","title":"Parameters","text":"Parameter Type Description <code>path</code> <code>Keypath</code> <code>options</code> <code>object</code> - <code>options.action</code> <code>NavigationAction</code> when <code>none</code>, <code>navigateTo</code> will immediately return <code>false</code>"},{"location":"reference/types/#returns_5","title":"Returns","text":"<p><code>boolean</code></p> <p><code>true</code> if the navigation was a success, <code>false</code> if the page was not found in the store.</p>"},{"location":"reference/types/#defined-in_25","title":"Defined in","text":"<p>lib/types/index.ts:394</p>"},{"location":"reference/types.requests/","title":"Requests","text":""},{"location":"reference/types.requests/#interfaces","title":"Interfaces","text":""},{"location":"reference/types.requests/#visit","title":"Visit()","text":"<p>Visit(<code>input</code>: <code>string</code>, <code>options</code>: <code>VisitProps</code>): <code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p>Use visit to make single page transitions from one page. The function is a wrapper around fetch and made to mimic a link click or a form submision. When used, a <code>json</code> request will be made for the next page, then Superglue saves the response, swap the page component, and change the browser history.</p> <p>Note</p> <p>There can be only one <code>visit</code> at a time. If another <code>visit</code> is called from elsewhere, the previous visit would be aborted.</p> <p>You must provide the implentation and pass it back to Superglue in <code>application.js</code>. Superglue will then pass it to your page components and use it for UJS navigation. This is usually generated for you in <code>application_visit.js</code> where you can customize its behavior globally.</p>"},{"location":"reference/types.requests/#parameters","title":"Parameters","text":"Parameter Type Description <code>input</code> <code>string</code> The first argument to Fetch <code>options</code> <code>VisitProps</code>"},{"location":"reference/types.requests/#returns","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>Meta</code>&gt;</p>"},{"location":"reference/types.requests/#defined-in","title":"Defined in","text":"<p>lib/types/requests.ts:22</p> <p></p>"},{"location":"reference/types.requests/#visitprops","title":"VisitProps","text":"<p>Options for Visit</p>"},{"location":"reference/types.requests/#extends","title":"Extends","text":"<ul> <li><code>Omit</code>\\&lt;<code>BaseProps</code>, <code>\"signal\"</code>&gt;</li> </ul>"},{"location":"reference/types.requests/#properties","title":"Properties","text":"Property Type Description Inherited from Defined in <code>placeholderKey?</code> <code>string</code> Defaults to the currentPageKey. When present, Superglue will use the page state located at that pageKey and optimistally navigates to it as the next page's state while the requests resolves. - lib/types/requests.ts:36 <code>revisit?</code> <code>boolean</code> When <code>true</code> and the request method is a GET, changes the <code>suggestionAction</code> of the Meta object to <code>none</code> so that Superglue does nothing to window.history. When the GET response was redirected, changes <code>navigationAction</code> to <code>replace</code> - lib/types/requests.ts:43 <code>method?</code> <code>string</code> The HTTP method <code>Omit.method</code> lib/types/requests.ts:68 <code>body?</code> <code>BodyInit</code> The HTTP body <code>Omit.body</code> lib/types/requests.ts:70 <code>headers?</code> {} The HTTP headers <code>Omit.headers</code> lib/types/requests.ts:72 <code>beforeSave?</code> <code>BeforeSave</code> - <code>Omit.beforeSave</code> lib/types/requests.ts:75"},{"location":"reference/types.requests/#remote","title":"Remote()","text":"<p>Remote(<code>input</code>: <code>string</code>, <code>options</code>: <code>RemoteProps</code>): <code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p>Remote is is wrapper around fetch. Its used to make a request and mutate the store. Remote does not navigate, and it does not change the browser history. There can be multiple Remote requests running concurrently.</p> <p>This function is to be wrapped by a deverloper as a ApplicationRemote and returned to superglue.  This is usually generated as <code>application_visit.js</code> where you can make minimum edits to affect its global usage.</p>"},{"location":"reference/types.requests/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>input</code> <code>string</code> The first argument to Fetch <code>options</code> <code>RemoteProps</code> The fetch RequestInit with additional options"},{"location":"reference/types.requests/#returns_1","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>Meta</code>&gt;</p>"},{"location":"reference/types.requests/#defined-in_1","title":"Defined in","text":"<p>lib/types/requests.ts:60</p> <p></p>"},{"location":"reference/types.requests/#remoteprops","title":"RemoteProps","text":"<p>Options for Visit</p>"},{"location":"reference/types.requests/#extends_1","title":"Extends","text":"<ul> <li><code>BaseProps</code></li> </ul>"},{"location":"reference/types.requests/#properties_1","title":"Properties","text":"Property Type Description Inherited from Defined in <code>method?</code> <code>string</code> The HTTP method <code>BaseProps.method</code> lib/types/requests.ts:68 <code>body?</code> <code>BodyInit</code> The HTTP body <code>BaseProps.body</code> lib/types/requests.ts:70 <code>headers?</code> {} The HTTP headers <code>BaseProps.headers</code> lib/types/requests.ts:72 <code>beforeSave?</code> <code>BeforeSave</code> - <code>BaseProps.beforeSave</code> lib/types/requests.ts:75 <code>pageKey?</code> <code>string</code> Specifies where to store the remote payload, if not provided Remote will derive a key from the response's url. - lib/types/requests.ts:86 <code>force?</code> <code>boolean</code> By default, remote Remote disallows grafting a page response using props_at if the target pageKey provided has a different componentIdentifier. Setting <code>force: true</code> will ignore this limitation. This can be useful if you are absolutely sure that the page your grafting onto has a compatible shape with the response received with using props_at. A good example of this is a shared global header. - lib/types/requests.ts:96"},{"location":"reference/types.requests/#beforesave","title":"BeforeSave()","text":"<p>BeforeSave(<code>prevPage</code>: <code>VisitResponse</code>, <code>receivedPage</code>: <code>VisitResponse</code>): <code>VisitResponse</code></p> <p>A callback that will be fire in between recieving a payload and saving a payload. Use this callback to modify the payload before it gets saved. Its useful for appending, prepending, shuffeling, etc. recieved data to existing data.</p> <pre><code>const beforeSave = (prevPage, nextPage) =&gt; {\n  nextPage.data.messages = [\n    prevPage.data.messages,\n    ... nextPage.data.messages\n  ]\n\n  return nextPage\n}\n\nremote(\"/posts\", {beforeSave})\n</code></pre>"},{"location":"reference/types.requests/#parameters_2","title":"Parameters","text":"Parameter Type <code>prevPage</code> <code>VisitResponse</code> <code>receivedPage</code> <code>VisitResponse</code>"},{"location":"reference/types.requests/#returns_2","title":"Returns","text":"<p><code>VisitResponse</code></p>"},{"location":"reference/types.requests/#defined-in_2","title":"Defined in","text":"<p>lib/types/requests.ts:119</p> <p></p>"},{"location":"reference/types.requests/#applicationremote","title":"ApplicationRemote()","text":"<p>ApplicationRemote(<code>input</code>: <code>string</code>, <code>options</code>: <code>RemoteProps</code> &amp; {<code>dataset</code>: {}; }): <code>Promise</code>\\&lt;<code>Meta</code>&gt;</p> <p>ApplicationRemote is the developer provided wrapper around Remote.</p> <p>It contains custom functionality, but is bound by the interface that Superglue uses to make a <code>remote</code> call. See Remote for more details.</p> <p>The only difference between the two interfaces is ApplicationRemote will also be passed a dataset as an option. This is because Superglue UJS uses ApplicationRemote and will pass the dataset of the HTML element where UJS is enabled on.</p>"},{"location":"reference/types.requests/#parameters_3","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> <code>options</code> <code>RemoteProps</code> &amp; {<code>dataset</code>: {}; }"},{"location":"reference/types.requests/#returns_3","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>Meta</code>&gt;</p>"},{"location":"reference/types.requests/#defined-in_3","title":"Defined in","text":"<p>lib/types/requests.ts:134</p> <p></p>"},{"location":"reference/types.requests/#applicationvisit","title":"ApplicationVisit()","text":"<p>ApplicationVisit(<code>input</code>: <code>string</code>, <code>options</code>: <code>VisitProps</code> &amp; {<code>dataset</code>: {}; }): <code>Promise</code>\\&lt;<code>undefined</code> | <code>void</code> | <code>VisitMeta</code>&gt;</p> <p>ApplicationVisit is the developer provided wrapper around Remote.</p> <p>It contains custom functionality, but is bound by the interface that Superglue uses to make a <code>visit</code> call. See Remote for more details.</p> <p>The only difference between the two interfaces is ApplicationVisit will also be passed a dataset as an option. This is because Superglue UJS uses ApplicationVisit and will pass the dataset of the HTML element where UJS is enabled on.</p>"},{"location":"reference/types.requests/#parameters_4","title":"Parameters","text":"Parameter Type <code>input</code> <code>string</code> <code>options</code> <code>VisitProps</code> &amp; {<code>dataset</code>: {}; }"},{"location":"reference/types.requests/#returns_4","title":"Returns","text":"<p><code>Promise</code>\\&lt;<code>undefined</code> | <code>void</code> | <code>VisitMeta</code>&gt;</p>"},{"location":"reference/types.requests/#defined-in_4","title":"Defined in","text":"<p>lib/types/requests.ts:156</p>"}]}