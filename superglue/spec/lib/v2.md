V2 of superglue

V2 of Superglue will be adding stronger support for fragments, Giving parts of UI state a unique identity
that we can refer to and mutate.

## Motivation

There's no easy way of mutating the page state without creating a reduce reducer, and while we have a naive implementation fragments, it moreso a convience for redux.

## Goal

Give UI state an identity within the store and introduce `useFragment` to allow access to that peice of state. Since we're dealing with shaped UI props generated by the server as opposed to classical pull and shape approach, it may be easier to implement.

Here's how its usage could workL

```ruby
json.body do
   json.post(partial:["user/post", fragment: "headline"]) do
   end
end
```

props_template would generate

```js
{
  data: {
    body: {
      post: {
        title: "this is a headline"
        comment: {
          text: "this is a comment"
        }
      }
    }
  },
  fragments: [
    {path: "data.body.post", key: "headline}
  ]
}
```

Superglue would transform that into redux state:

```js
{
  pages: {
    "/post": {
      data: {
        body: {
          post: {__id: "headline"}
        }
      },
      fragments: [
        {path: "data.body.post", key: "headline}
      ]
    },
    fragments: {
      headline: {
        data: {
          title: "this is a headline"
          comment: {
            text: "this is a comment"
          }
        },
        moreMetaData: {}
      }
    }
  }
}
```

and we'd have a react component that looks like this:

```jsx
const IndexPage = () => {
  const { body }= useContent()
  return (
    <Post post={body.post} />
  )
}

const Post = ({post}: {post: FragmentRef}) => {
  const [post, setPost] = useFragment(post)

  return (
    <div>
        <h1>{post.title}<h1>
        <p>post.comment.text</p>
    </div>
  )
}
```

The backend controls the view shape, the frontend honors the structure without reshaping.

## Implementation

There are a few scenarios worth pointing out:

1. Happy path - Where a page consists of a few nested fragments
2. Deferment

- Where a generic node gets deferred with a fragment that is deeply nested
- Where a fragment has a deferred generic node
- where a fragment itself deferred
- where a fragment is deferred with a nesed fragment
- where a fragment is deferred with a nesed fragment
- Where a the results of a fragment is used as a placeholder

3. Fragment

- Should a fragmement be aware other fragments within itself?
- A fragment should be aware of it deferments for the purposes of generating
  placeholders.

4. How does deferments placehodlers work today

# Deferment

## Example

```
  defers: [{ url: '/foo?props_at=data.foo.bar', path: 'data.foo.bar' }],
```

## How it works today

Deferment works by NOT rendering an entire node and making the frontend rerequest it. When fragments
or defers are nested under that node, it simply does not get rendered. It is not until you request the deferment that the missing nested fragment / defer information and is appended to the page.

# In short, the flow:

1. props_template renders
2. props_template notices the defer, and decides NOT to render it, and appends meta data to defers.
3. Anything nested inside the defer node is no-op
4. template renders
5. superglue picks it up
6. Superglue decides to rekquest it as a graft

But that's not all

Defered nodes come with 2 types of placeholders. The first is the placeholder that you define using props_template:

```ruby
  json.avatar(defer: [:auto, placholder: {name: "waiting...."}]) do
    json.name "John smith"
  end
```

In that scenario the block does not render, instead it gets defered. The above would produce:

```js
  {
    data: {
      avatar: {
        name: "waiting..."
      },
    },
    defered: [
      { path: '/?props_at=data.avatar', type: "auto" }
    ]
  }
```

Where `defered` gives us enough information on how to grab the defered data, which we immutably graft when recieved.

The second version of deferred is when we're visiting a page for a second time (we get a new page props). In that scenario we don't want to use the new page's placeholder as that would force
a "waiting..." again. Instead we use the previous saved state's data as placeholders for the new page so we're more seamlessly. This happens when we receive the new page.

NOTE: That when recieving nested fragments we append them to the page
. With nested deferments we do nothing, that's because there's no need to deal with

# Answers to questions

## Where a generic node gets deferred with a fragment that is deeply nested

```
(defered - not fragment) -< (fragment)
```

### Currently:

We fetch the defered node, and we recieve the node with the nested fragment. The meta data
about the ndoe's nested fragments (and any additional deferred --- something smells here) are then joined with the page. UPDATE_FRAGMENTS is called (i think...) with the new fragments.

### Next

- Where a fragment has a deferred generic node

```
(fragment) -< (defered - not fragment)
```

Currently:

Differed behaves as usual, but UPDATE_FRAGMENT gets called once, only wih placeholder.... a bit of a bug.

- where a fragment itself deferred

```
(fragment defered) -< (anything else)
```

Currently:
UPDATE_FRAGMENT gets called twice, once for the original, then when deferred again.

- where a fragment is deferred with a nesed fragment

- Where a the results of a fragment is used as a placeholder

Currently:

Works exactly as a normal deferment. The new received page gets modified with placeholders
from the current page using a keypath to the nodes.

Fragments don't have a meaning other than HEY I FOUND IT, and hope someone listens.

## Next steps

We just need to resolve

(defered) -> fragment -> (defered)

and

(fragment) -> defered -> (fragment)
